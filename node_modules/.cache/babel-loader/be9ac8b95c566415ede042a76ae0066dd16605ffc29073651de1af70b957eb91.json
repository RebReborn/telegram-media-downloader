{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Hash = exports.CTR = exports.Counter = void 0;\nexports.createDecipheriv = createDecipheriv;\nexports.createCipheriv = createCipheriv;\nexports.randomBytes = randomBytes;\nexports.pbkdf2Sync = pbkdf2Sync;\nexports.createHash = createHash;\nconst aes_1 = __importDefault(require(\"@cryptography/aes\"));\nconst converters_1 = require(\"./converters\");\nconst words_1 = require(\"./words\");\nclass Counter {\n  constructor(initialValue) {\n    this._counter = Buffer.from(initialValue);\n  }\n  increment() {\n    for (let i = 15; i >= 0; i--) {\n      if (this._counter[i] === 255) {\n        this._counter[i] = 0;\n      } else {\n        this._counter[i]++;\n        break;\n      }\n    }\n  }\n}\nexports.Counter = Counter;\nclass CTR {\n  constructor(key, counter) {\n    if (!(counter instanceof Counter)) {\n      counter = new Counter(counter);\n    }\n    this._counter = counter;\n    this._remainingCounter = undefined;\n    this._remainingCounterIndex = 16;\n    this._aes = new aes_1.default((0, words_1.getWords)(key));\n  }\n  update(plainText) {\n    return this.encrypt(plainText);\n  }\n  encrypt(plainText) {\n    const encrypted = Buffer.from(plainText);\n    for (let i = 0; i < encrypted.length; i++) {\n      if (this._remainingCounterIndex === 16) {\n        this._remainingCounter = Buffer.from((0, converters_1.i2ab)(this._aes.encrypt((0, converters_1.ab2i)(this._counter._counter))));\n        this._remainingCounterIndex = 0;\n        this._counter.increment();\n      }\n      if (this._remainingCounter) {\n        encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];\n      }\n    }\n    return encrypted;\n  }\n}\nexports.CTR = CTR;\n// endregion\nfunction createDecipheriv(algorithm, key, iv) {\n  if (algorithm.includes(\"ECB\")) {\n    throw new Error(\"Not supported\");\n  } else {\n    return new CTR(key, iv);\n  }\n}\nfunction createCipheriv(algorithm, key, iv) {\n  if (algorithm.includes(\"ECB\")) {\n    throw new Error(\"Not supported\");\n  } else {\n    return new CTR(key, iv);\n  }\n}\nfunction randomBytes(count) {\n  const bytes = new Uint8Array(count);\n  crypto.getRandomValues(bytes);\n  return bytes;\n}\nclass Hash {\n  constructor(algorithm) {\n    this.algorithm = algorithm;\n  }\n  update(data) {\n    //We shouldn't be needing new Uint8Array but it doesn't\n    //work without it\n    this.data = new Uint8Array(data);\n  }\n  async digest() {\n    if (this.data) {\n      if (this.algorithm === \"sha1\") {\n        return Buffer.from(await self.crypto.subtle.digest(\"SHA-1\", this.data));\n      } else if (this.algorithm === \"sha256\") {\n        return Buffer.from(await self.crypto.subtle.digest(\"SHA-256\", this.data));\n      }\n    }\n    return Buffer.alloc(0);\n  }\n}\nexports.Hash = Hash;\nasync function pbkdf2Sync(password, salt, iterations) {\n  const passwordKey = await crypto.subtle.importKey(\"raw\", password, {\n    name: \"PBKDF2\"\n  }, false, [\"deriveBits\"]);\n  return Buffer.from(await crypto.subtle.deriveBits({\n    name: \"PBKDF2\",\n    hash: \"SHA-512\",\n    salt,\n    iterations\n  }, passwordKey, 512));\n}\nfunction createHash(algorithm) {\n  return new Hash(algorithm);\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}