{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObfuscatedConnection = exports.PacketCodec = exports.Connection = void 0;\nconst extensions_1 = require(\"../../extensions\");\n/**\n * The `Connection` class is a wrapper around ``asyncio.open_connection``.\n *\n * Subclasses will implement different transport modes as atomic operations,\n * which this class eases doing since the exposed interface simply puts and\n * gets complete data payloads to and from queues.\n *\n * The only error that will raise from send and receive methods is\n * ``ConnectionError``, which will raise when attempting to send if\n * the client is disconnected (includes remote disconnections).\n */\nclass Connection {\n  constructor(_ref) {\n    let {\n      ip,\n      port,\n      dcId,\n      loggers,\n      proxy,\n      socket,\n      testServers\n    } = _ref;\n    this._ip = ip;\n    this._port = port;\n    this._dcId = dcId;\n    this._log = loggers;\n    this._proxy = proxy;\n    this._connected = false;\n    this._sendTask = undefined;\n    this._recvTask = undefined;\n    this._codec = undefined;\n    this._obfuscation = undefined; // TcpObfuscated and MTProxy\n    this._sendArray = new extensions_1.AsyncQueue();\n    this._recvArray = new extensions_1.AsyncQueue();\n    this.socket = new socket(proxy);\n    this._testServers = testServers;\n  }\n  async _connect() {\n    this._log.debug(\"Connecting\");\n    this._codec = new this.PacketCodecClass(this);\n    await this.socket.connect(this._port, this._ip, this._testServers);\n    this._log.debug(\"Finished connecting\");\n    // await this.socket.connect({host: this._ip, port: this._port});\n    await this._initConn();\n  }\n  async connect() {\n    await this._connect();\n    this._connected = true;\n    if (!this._sendTask) {\n      this._sendTask = this._sendLoop();\n    }\n    this._recvTask = this._recvLoop();\n  }\n  async disconnect() {\n    if (!this._connected) {\n      return;\n    }\n    this._connected = false;\n    void this._recvArray.push(undefined);\n    await this.socket.close();\n  }\n  async send(data) {\n    if (!this._connected) {\n      throw new Error(\"Not connected\");\n    }\n    await this._sendArray.push(data);\n  }\n  async recv() {\n    while (this._connected) {\n      const result = await this._recvArray.pop();\n      // null = sentinel value = keep trying\n      if (result) {\n        return result;\n      }\n    }\n    throw new Error(\"Not connected\");\n  }\n  async _sendLoop() {\n    try {\n      while (this._connected) {\n        const data = await this._sendArray.pop();\n        if (!data) {\n          this._sendTask = undefined;\n          return;\n        }\n        await this._send(data);\n      }\n    } catch (e) {\n      this._log.info(\"The server closed the connection while sending\");\n    }\n  }\n  isConnected() {\n    return this._connected;\n  }\n  async _recvLoop() {\n    let data;\n    while (this._connected) {\n      try {\n        data = await this._recv();\n        if (!data) {\n          throw new Error(\"no data received\");\n        }\n      } catch (e) {\n        this._log.info(\"connection closed\");\n        // await this._recvArray.push()\n        this.disconnect();\n        return;\n      }\n      await this._recvArray.push(data);\n    }\n  }\n  async _initConn() {\n    if (this._codec.tag) {\n      await this.socket.write(this._codec.tag);\n    }\n  }\n  async _send(data) {\n    const encodedPacket = this._codec.encodePacket(data);\n    this.socket.write(encodedPacket);\n  }\n  async _recv() {\n    return await this._codec.readPacket(this.socket);\n  }\n  toString() {\n    return `${this._ip}:${this._port}/${this.constructor.name.replace(\"Connection\", \"\")}`;\n  }\n}\nexports.Connection = Connection;\nclass ObfuscatedConnection extends Connection {\n  constructor() {\n    super(...arguments);\n    this.ObfuscatedIO = undefined;\n  }\n  async _initConn() {\n    this._obfuscation = new this.ObfuscatedIO(this);\n    await this._obfuscation.initHeader();\n    this.socket.write(this._obfuscation.header);\n  }\n  async _send(data) {\n    this._obfuscation.write(this._codec.encodePacket(data));\n  }\n  async _recv() {\n    return await this._codec.readPacket(this._obfuscation);\n  }\n}\nexports.ObfuscatedConnection = ObfuscatedConnection;\nclass PacketCodec {\n  constructor(connection) {\n    this._conn = connection;\n  }\n  encodePacket(data) {\n    throw new Error(\"Not Implemented\");\n    // Override\n  }\n  async readPacket(reader) {\n    // override\n    throw new Error(\"Not Implemented\");\n  }\n}\nexports.PacketCodec = PacketCodec;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}