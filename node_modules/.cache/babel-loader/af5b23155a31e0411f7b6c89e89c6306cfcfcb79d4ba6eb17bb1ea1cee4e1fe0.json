{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Hash = exports.CTR = exports.Counter = void 0;\nexports.createDecipheriv = createDecipheriv;\nexports.createCipheriv = createCipheriv;\nexports.randomBytes = randomBytes;\nexports.pbkdf2Sync = pbkdf2Sync;\nexports.createHash = createHash;\nconst aes_1 = __importDefault(require(\"@cryptography/aes\"));\nconst converters_1 = require(\"./converters\");\nconst words_1 = require(\"./words\");\nclass Counter {\n  constructor(initialValue) {\n    this._counter = Buffer.from(initialValue);\n  }\n  increment() {\n    for (let i = 15; i >= 0; i--) {\n      if (this._counter[i] === 255) {\n        this._counter[i] = 0;\n      } else {\n        this._counter[i]++;\n        break;\n      }\n    }\n  }\n}\nexports.Counter = Counter;\nclass CTR {\n  constructor(key, counter) {\n    if (!(counter instanceof Counter)) {\n      counter = new Counter(counter);\n    }\n    this._counter = counter;\n    this._remainingCounter = undefined;\n    this._remainingCounterIndex = 16;\n    this._aes = new aes_1.default((0, words_1.getWords)(key));\n  }\n  update(plainText) {\n    return this.encrypt(plainText);\n  }\n  encrypt(plainText) {\n    const encrypted = Buffer.from(plainText);\n    for (let i = 0; i < encrypted.length; i++) {\n      if (this._remainingCounterIndex === 16) {\n        this._remainingCounter = Buffer.from((0, converters_1.i2ab)(this._aes.encrypt((0, converters_1.ab2i)(this._counter._counter))));\n        this._remainingCounterIndex = 0;\n        this._counter.increment();\n      }\n      if (this._remainingCounter) {\n        encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];\n      }\n    }\n    return encrypted;\n  }\n}\nexports.CTR = CTR;\n// endregion\nfunction createDecipheriv(algorithm, key, iv) {\n  if (algorithm.includes(\"ECB\")) {\n    throw new Error(\"Not supported\");\n  } else {\n    return new CTR(key, iv);\n  }\n}\nfunction createCipheriv(algorithm, key, iv) {\n  if (algorithm.includes(\"ECB\")) {\n    throw new Error(\"Not supported\");\n  } else {\n    return new CTR(key, iv);\n  }\n}\nfunction randomBytes(count) {\n  const bytes = new Uint8Array(count);\n  crypto.getRandomValues(bytes);\n  return bytes;\n}\nclass Hash {\n  constructor(algorithm) {\n    this.algorithm = algorithm;\n  }\n  update(data) {\n    //We shouldn't be needing new Uint8Array but it doesn't\n    //work without it\n    this.data = new Uint8Array(data);\n  }\n  async digest() {\n    if (this.data) {\n      if (this.algorithm === \"sha1\") {\n        return Buffer.from(await self.crypto.subtle.digest(\"SHA-1\", this.data));\n      } else if (this.algorithm === \"sha256\") {\n        return Buffer.from(await self.crypto.subtle.digest(\"SHA-256\", this.data));\n      }\n    }\n    return Buffer.alloc(0);\n  }\n}\nexports.Hash = Hash;\nasync function pbkdf2Sync(password, salt, iterations, ...args) {\n  const passwordKey = await crypto.subtle.importKey(\"raw\", password, {\n    name: \"PBKDF2\"\n  }, false, [\"deriveBits\"]);\n  return Buffer.from(await crypto.subtle.deriveBits({\n    name: \"PBKDF2\",\n    hash: \"SHA-512\",\n    salt,\n    iterations\n  }, passwordKey, 512));\n}\nfunction createHash(algorithm) {\n  return new Hash(algorithm);\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Hash","CTR","Counter","createDecipheriv","createCipheriv","randomBytes","pbkdf2Sync","createHash","aes_1","require","converters_1","words_1","constructor","initialValue","_counter","Buffer","from","increment","i","key","counter","_remainingCounter","undefined","_remainingCounterIndex","_aes","default","getWords","update","plainText","encrypt","encrypted","length","i2ab","ab2i","algorithm","iv","includes","Error","count","bytes","Uint8Array","crypto","getRandomValues","data","digest","self","subtle","alloc","password","salt","iterations","args","passwordKey","importKey","name","deriveBits","hash"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/crypto/crypto.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Hash = exports.CTR = exports.Counter = void 0;\nexports.createDecipheriv = createDecipheriv;\nexports.createCipheriv = createCipheriv;\nexports.randomBytes = randomBytes;\nexports.pbkdf2Sync = pbkdf2Sync;\nexports.createHash = createHash;\nconst aes_1 = __importDefault(require(\"@cryptography/aes\"));\nconst converters_1 = require(\"./converters\");\nconst words_1 = require(\"./words\");\nclass Counter {\n    constructor(initialValue) {\n        this._counter = Buffer.from(initialValue);\n    }\n    increment() {\n        for (let i = 15; i >= 0; i--) {\n            if (this._counter[i] === 255) {\n                this._counter[i] = 0;\n            }\n            else {\n                this._counter[i]++;\n                break;\n            }\n        }\n    }\n}\nexports.Counter = Counter;\nclass CTR {\n    constructor(key, counter) {\n        if (!(counter instanceof Counter)) {\n            counter = new Counter(counter);\n        }\n        this._counter = counter;\n        this._remainingCounter = undefined;\n        this._remainingCounterIndex = 16;\n        this._aes = new aes_1.default((0, words_1.getWords)(key));\n    }\n    update(plainText) {\n        return this.encrypt(plainText);\n    }\n    encrypt(plainText) {\n        const encrypted = Buffer.from(plainText);\n        for (let i = 0; i < encrypted.length; i++) {\n            if (this._remainingCounterIndex === 16) {\n                this._remainingCounter = Buffer.from((0, converters_1.i2ab)(this._aes.encrypt((0, converters_1.ab2i)(this._counter._counter))));\n                this._remainingCounterIndex = 0;\n                this._counter.increment();\n            }\n            if (this._remainingCounter) {\n                encrypted[i] ^=\n                    this._remainingCounter[this._remainingCounterIndex++];\n            }\n        }\n        return encrypted;\n    }\n}\nexports.CTR = CTR;\n// endregion\nfunction createDecipheriv(algorithm, key, iv) {\n    if (algorithm.includes(\"ECB\")) {\n        throw new Error(\"Not supported\");\n    }\n    else {\n        return new CTR(key, iv);\n    }\n}\nfunction createCipheriv(algorithm, key, iv) {\n    if (algorithm.includes(\"ECB\")) {\n        throw new Error(\"Not supported\");\n    }\n    else {\n        return new CTR(key, iv);\n    }\n}\nfunction randomBytes(count) {\n    const bytes = new Uint8Array(count);\n    crypto.getRandomValues(bytes);\n    return bytes;\n}\nclass Hash {\n    constructor(algorithm) {\n        this.algorithm = algorithm;\n    }\n    update(data) {\n        //We shouldn't be needing new Uint8Array but it doesn't\n        //work without it\n        this.data = new Uint8Array(data);\n    }\n    async digest() {\n        if (this.data) {\n            if (this.algorithm === \"sha1\") {\n                return Buffer.from(await self.crypto.subtle.digest(\"SHA-1\", this.data));\n            }\n            else if (this.algorithm === \"sha256\") {\n                return Buffer.from(await self.crypto.subtle.digest(\"SHA-256\", this.data));\n            }\n        }\n        return Buffer.alloc(0);\n    }\n}\nexports.Hash = Hash;\nasync function pbkdf2Sync(password, salt, iterations, ...args) {\n    const passwordKey = await crypto.subtle.importKey(\"raw\", password, { name: \"PBKDF2\" }, false, [\"deriveBits\"]);\n    return Buffer.from(await crypto.subtle.deriveBits({\n        name: \"PBKDF2\",\n        hash: \"SHA-512\",\n        salt,\n        iterations,\n    }, passwordKey, 512));\n}\nfunction createHash(algorithm) {\n    return new Hash(algorithm);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}