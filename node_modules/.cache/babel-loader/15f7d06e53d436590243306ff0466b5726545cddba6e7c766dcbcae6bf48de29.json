{"ast":null,"code":"\"use strict\";\n\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._IDsIter = exports._MessagesIter = void 0;\nexports.iterMessages = iterMessages;\nexports.getMessages = getMessages;\nexports.sendMessage = sendMessage;\nexports.forwardMessages = forwardMessages;\nexports.editMessage = editMessage;\nexports.deleteMessages = deleteMessages;\nexports.pinMessage = pinMessage;\nexports.unpinMessage = unpinMessage;\nexports._pin = _pin;\nexports.markAsRead = markAsRead;\nexports.getCommentData = getCommentData;\nconst tl_1 = require(\"../tl\");\nconst requestIter_1 = require(\"../requestIter\");\nconst Helpers_1 = require(\"../Helpers\");\nconst Utils_1 = require(\"../Utils\");\nconst __1 = require(\"../\");\nconst messageParse_1 = require(\"./messageParse\");\nconst users_1 = require(\"./users\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst uploads_1 = require(\"./uploads\");\nconst _MAX_CHUNK_SIZE = 100;\nclass _MessagesIter extends requestIter_1.RequestIter {\n  async _init({\n    entity,\n    offsetId,\n    minId,\n    maxId,\n    fromUser,\n    offsetDate,\n    addOffset,\n    filter,\n    search,\n    replyTo\n  }) {\n    var _a, e_1, _b, _c;\n    if (entity) {\n      this.entity = await this.client.getInputEntity(entity);\n    } else {\n      this.entity = undefined;\n      if (this.reverse) {\n        throw new Error(\"Cannot reverse global search\");\n      }\n    }\n    if (this.reverse) {\n      offsetId = Math.max(offsetId, minId);\n      if (offsetId && maxId) {\n        if (maxId - offsetId <= 1) {\n          return false;\n        }\n      }\n      if (!maxId) {\n        maxId = Number.MAX_SAFE_INTEGER;\n      }\n    } else {\n      offsetId = Math.max(offsetId, maxId);\n      if (offsetId && minId) {\n        if (offsetId - minId <= 1) {\n          return false;\n        }\n      }\n    }\n    if (this.reverse) {\n      if (offsetId) {\n        offsetId += 1;\n      } else if (!offsetDate) {\n        offsetId = 1;\n      }\n    }\n    if (fromUser) {\n      fromUser = await this.client.getInputEntity(fromUser);\n    }\n    if (!this.entity && fromUser) {\n      this.entity = new tl_1.Api.InputPeerEmpty();\n    }\n    if (!filter) {\n      filter = new tl_1.Api.InputMessagesFilterEmpty();\n    }\n    if (!this.entity) {\n      this.request = new tl_1.Api.messages.SearchGlobal({\n        q: search || \"\",\n        filter: filter,\n        minDate: undefined,\n        // TODO fix this smh\n        maxDate: offsetDate,\n        offsetRate: undefined,\n        offsetPeer: new tl_1.Api.InputPeerEmpty(),\n        offsetId: offsetId,\n        limit: 1\n      });\n    } else if (replyTo !== undefined) {\n      this.request = new tl_1.Api.messages.GetReplies({\n        peer: this.entity,\n        msgId: replyTo,\n        offsetId: offsetId,\n        offsetDate: offsetDate,\n        addOffset: addOffset,\n        limit: 0,\n        maxId: 0,\n        minId: 0,\n        hash: big_integer_1.default.zero\n      });\n    } else if (search !== undefined || !(filter instanceof tl_1.Api.InputMessagesFilterEmpty) || fromUser !== undefined) {\n      this.request = new tl_1.Api.messages.Search({\n        peer: this.entity,\n        q: search || \"\",\n        filter: typeof filter === \"function\" ? new filter() : filter,\n        minDate: undefined,\n        maxDate: offsetDate,\n        offsetId: offsetId,\n        addOffset: addOffset,\n        limit: 0,\n        maxId: 0,\n        minId: 0,\n        hash: (0, Helpers_1.generateRandomBigInt)(),\n        fromId: fromUser\n      });\n      if (!(filter instanceof tl_1.Api.InputMessagesFilterEmpty) && offsetDate && !search && !offsetId) {\n        try {\n          for (var _d = true, _e = __asyncValues(this.client.iterMessages(this.entity, {\n              limit: 1,\n              offsetDate: offsetDate\n            })), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {\n            _c = _f.value;\n            _d = false;\n            const m = _c;\n            this.request.offsetId = m.id + 1;\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      }\n    } else {\n      this.request = new tl_1.Api.messages.GetHistory({\n        peer: this.entity,\n        limit: 1,\n        offsetDate: offsetDate,\n        offsetId: offsetId,\n        minId: 0,\n        maxId: 0,\n        addOffset: addOffset,\n        hash: big_integer_1.default.zero\n      });\n    }\n    if (this.limit <= 0) {\n      const result = await this.client.invoke(this.request);\n      if (result instanceof tl_1.Api.messages.MessagesNotModified) {\n        this.total = result.count;\n      } else {\n        if (\"count\" in result) {\n          this.total = result.count;\n        } else {\n          this.total = result.messages.length;\n        }\n      }\n      return false;\n    }\n    if (!this.waitTime) {\n      this.waitTime = this.limit > 3000 ? 1 : 0;\n    }\n    if (this.reverse && !(this.request instanceof tl_1.Api.messages.SearchGlobal)) {\n      this.request.addOffset -= _MAX_CHUNK_SIZE;\n    }\n    this.addOffset = addOffset;\n    this.maxId = maxId;\n    this.minId = minId;\n    this.lastId = this.reverse ? 0 : Number.MAX_SAFE_INTEGER;\n  }\n  async _loadNextChunk() {\n    var _a;\n    if (!this.request) {\n      throw new Error(\"Request not set yet\");\n    }\n    this.request.limit = Math.min(this.left, _MAX_CHUNK_SIZE);\n    if (this.reverse && this.request.limit != _MAX_CHUNK_SIZE) {\n      if (!(this.request instanceof tl_1.Api.messages.SearchGlobal)) {\n        this.request.addOffset = this.addOffset - this.request.limit;\n      }\n    }\n    const r = await this.client.invoke(this.request);\n    if (r instanceof tl_1.Api.messages.MessagesNotModified) {\n      return true;\n    }\n    if (\"count\" in r) {\n      this.total = r.count;\n    } else {\n      this.total = r.messages.length;\n    }\n    const entities = new Map();\n    for (const x of [...r.users, ...r.chats]) {\n      entities.set((0, Utils_1.getPeerId)(x), x);\n    }\n    const messages = this.reverse ? r.messages.reverse() : r.messages;\n    for (const message of messages) {\n      if (!this._messageInRange(message)) {\n        return true;\n      }\n      this.lastId = message.id;\n      try {\n        // if this fails it shouldn't be a big problem\n        message._finishInit(this.client, entities, this.entity);\n      } catch (e) {}\n      message._entities = entities;\n      (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.push(message);\n    }\n    if (r.messages.length < this.request.limit) {\n      return true;\n    }\n    if (this.buffer) {\n      this._updateOffset(this.buffer[this.buffer.length - 1], r);\n    } else {\n      return true;\n    }\n  }\n  _messageInRange(message) {\n    if (this.entity) {\n      if (this.reverse) {\n        if (message.id <= this.lastId || message.id >= this.maxId) {\n          return false;\n        }\n      } else {\n        if (message.id >= this.lastId || message.id <= this.minId) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  [Symbol.asyncIterator]() {\n    return super[Symbol.asyncIterator]();\n  }\n  _updateOffset(lastMessage, response) {\n    if (!this.request) {\n      throw new Error(\"Request not set yet\");\n    }\n    this.request.offsetId = Number(lastMessage.id);\n    if (this.reverse) {\n      this.request.offsetId += 1;\n    }\n    if (this.request instanceof tl_1.Api.messages.Search) {\n      this.request.maxDate = -1;\n    } else {\n      if (!(this.request instanceof tl_1.Api.messages.SearchGlobal)) {\n        this.request.offsetDate = lastMessage.date;\n      }\n    }\n    if (this.request instanceof tl_1.Api.messages.SearchGlobal) {\n      if (lastMessage.inputChat) {\n        this.request.offsetPeer = lastMessage.inputChat;\n      } else {\n        this.request.offsetPeer = new tl_1.Api.InputPeerEmpty();\n      }\n      this.request.offsetRate = response.nextRate;\n    }\n  }\n}\nexports._MessagesIter = _MessagesIter;\nclass _IDsIter extends requestIter_1.RequestIter {\n  async _init({\n    entity,\n    ids\n  }) {\n    this.total = ids.length;\n    this._ids = this.reverse ? ids.reverse() : ids;\n    this._offset = 0;\n    this._entity = entity ? await this.client.getInputEntity(entity) : undefined;\n    this._ty = this._entity ? (0, Helpers_1._entityType)(this._entity) : undefined;\n    if (!this.waitTime) {\n      this.waitTime = this.limit > 300 ? 10 : 0;\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return super[Symbol.asyncIterator]();\n  }\n  async _loadNextChunk() {\n    var _a, _b, _c;\n    const ids = this._ids.slice(this._offset, this._offset + _MAX_CHUNK_SIZE);\n    if (!ids.length) {\n      return false;\n    }\n    this._offset += _MAX_CHUNK_SIZE;\n    let fromId;\n    let r;\n    if (this._ty == Helpers_1._EntityType.CHANNEL) {\n      try {\n        r = await this.client.invoke(new tl_1.Api.channels.GetMessages({\n          channel: this._entity,\n          id: ids\n        }));\n      } catch (e) {\n        if (e.errorMessage == \"MESSAGE_IDS_EMPTY\") {\n          r = new tl_1.Api.messages.MessagesNotModified({\n            count: ids.length\n          });\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      r = await this.client.invoke(new tl_1.Api.messages.GetMessages({\n        id: ids\n      }));\n      if (this._entity) {\n        fromId = await (0, users_1._getPeer)(this.client, this._entity);\n      }\n    }\n    if (r instanceof tl_1.Api.messages.MessagesNotModified) {\n      (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.push(...Array(ids.length));\n      return;\n    }\n    const entities = new Map();\n    for (const entity of [...r.users, ...r.chats]) {\n      entities.set(__1.utils.getPeerId(entity), entity);\n    }\n    let message;\n    for (message of r.messages) {\n      if (message instanceof tl_1.Api.MessageEmpty || fromId && __1.utils.getPeerId(message.peerId) != __1.utils.getPeerId(fromId)) {\n        (_b = this.buffer) === null || _b === void 0 ? void 0 : _b.push(undefined);\n      } else {\n        const temp = message;\n        temp._finishInit(this.client, entities, this._entity);\n        temp._entities = entities;\n        (_c = this.buffer) === null || _c === void 0 ? void 0 : _c.push(temp);\n      }\n    }\n  }\n}\nexports._IDsIter = _IDsIter;\nconst IterMessagesDefaults = {\n  limit: undefined,\n  offsetDate: undefined,\n  offsetId: 0,\n  maxId: 0,\n  minId: 0,\n  addOffset: 0,\n  search: undefined,\n  filter: undefined,\n  fromUser: undefined,\n  waitTime: undefined,\n  ids: undefined,\n  reverse: false,\n  replyTo: undefined,\n  scheduled: false\n};\n/** @hidden */\nfunction iterMessages(client, entity, options) {\n  const {\n    limit,\n    offsetDate,\n    offsetId,\n    maxId,\n    minId,\n    addOffset,\n    search,\n    filter,\n    fromUser,\n    waitTime,\n    ids,\n    reverse,\n    replyTo\n  } = Object.assign(Object.assign({}, IterMessagesDefaults), options);\n  if (ids) {\n    let idsArray;\n    if (!(0, Helpers_1.isArrayLike)(ids)) {\n      idsArray = [ids];\n    } else {\n      idsArray = ids;\n    }\n    return new _IDsIter(client, idsArray.length, {\n      reverse: reverse,\n      waitTime: waitTime\n    }, {\n      entity: entity,\n      ids: idsArray\n    });\n  }\n  return new _MessagesIter(client, limit, {\n    waitTime: waitTime,\n    reverse: reverse\n  }, {\n    entity: entity,\n    offsetId: offsetId,\n    minId: minId,\n    maxId: maxId,\n    fromUser: fromUser,\n    offsetDate: offsetDate,\n    addOffset: addOffset,\n    filter: filter,\n    search: search,\n    replyTo: replyTo\n  });\n}\n/** @hidden */\nasync function getMessages(client, entity, params) {\n  var _a, e_2, _b, _c;\n  if (Object.keys(params).length == 1 && params.limit === undefined) {\n    if (params.minId === undefined && params.maxId === undefined) {\n      params.limit = undefined;\n    } else {\n      params.limit = 1;\n    }\n  }\n  const it = client.iterMessages(entity, params);\n  const ids = params.ids;\n  if (ids && !(0, Helpers_1.isArrayLike)(ids)) {\n    try {\n      for (var _d = true, it_1 = __asyncValues(it), it_1_1; it_1_1 = await it_1.next(), _a = it_1_1.done, !_a; _d = true) {\n        _c = it_1_1.value;\n        _d = false;\n        const message = _c;\n        return [message];\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (!_d && !_a && (_b = it_1.return)) await _b.call(it_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return [];\n  }\n  return await it.collect();\n}\n// region Message\n/** @hidden */\nasync function sendMessage(client, /** To who will it be sent. */\nentity,\n/**  The message to be sent, or another message object to resend as a copy.<br/>\n * The maximum length for a message is 35,000 bytes or 4,096 characters.<br/>\n * Longer messages will not be sliced automatically, and you should slice them manually if the text to send is longer than said length. */\n{\n  message,\n  replyTo,\n  attributes,\n  parseMode,\n  formattingEntities,\n  linkPreview = true,\n  file,\n  thumb,\n  forceDocument,\n  clearDraft,\n  buttons,\n  silent,\n  supportStreaming,\n  schedule,\n  noforwards,\n  commentTo,\n  topMsgId\n} = {}) {\n  if (file) {\n    return client.sendFile(entity, {\n      file: file,\n      caption: message ? typeof message == \"string\" ? message : message.message : \"\",\n      forceDocument: forceDocument,\n      clearDraft: clearDraft,\n      replyTo: replyTo,\n      attributes: attributes,\n      thumb: thumb,\n      supportsStreaming: supportStreaming,\n      parseMode: parseMode,\n      formattingEntities: formattingEntities,\n      silent: silent,\n      scheduleDate: schedule,\n      buttons: buttons,\n      noforwards: noforwards,\n      commentTo: commentTo,\n      topMsgId: topMsgId\n    });\n  }\n  entity = await client.getInputEntity(entity);\n  if (commentTo != undefined) {\n    const discussionData = await getCommentData(client, entity, commentTo);\n    entity = discussionData.entity;\n    replyTo = discussionData.replyTo;\n  }\n  let markup, request;\n  let replyObject = undefined;\n  if (replyTo != undefined) {\n    replyObject = new tl_1.Api.InputReplyToMessage({\n      replyToMsgId: (0, Utils_1.getMessageId)(replyTo),\n      topMsgId: (0, Utils_1.getMessageId)(topMsgId)\n    });\n  }\n  if (message && message instanceof tl_1.Api.Message) {\n    if (buttons == undefined) {\n      markup = message.replyMarkup;\n    } else {\n      markup = client.buildReplyMarkup(buttons);\n    }\n    if (silent == undefined) {\n      silent = message.silent;\n    }\n    if (message.media && !(message.media instanceof tl_1.Api.MessageMediaWebPage)) {\n      return client.sendFile(entity, {\n        file: message.media,\n        caption: message.message,\n        silent: silent,\n        replyTo: replyTo,\n        buttons: markup,\n        formattingEntities: message.entities,\n        scheduleDate: schedule\n      });\n    }\n    request = new tl_1.Api.messages.SendMessage({\n      peer: entity,\n      message: message.message || \"\",\n      silent: silent,\n      replyTo: replyObject,\n      replyMarkup: markup,\n      entities: message.entities,\n      clearDraft: clearDraft,\n      noWebpage: !(message.media instanceof tl_1.Api.MessageMediaWebPage),\n      scheduleDate: schedule,\n      noforwards: noforwards\n    });\n    message = message.message;\n  } else {\n    if (formattingEntities == undefined) {\n      [message, formattingEntities] = await (0, messageParse_1._parseMessageText)(client, message || \"\", parseMode);\n    }\n    if (!message) {\n      throw new Error(\"The message cannot be empty unless a file is provided\");\n    }\n    request = new tl_1.Api.messages.SendMessage({\n      peer: entity,\n      message: message.toString(),\n      entities: formattingEntities,\n      noWebpage: !linkPreview,\n      replyTo: replyObject,\n      clearDraft: clearDraft,\n      silent: silent,\n      replyMarkup: client.buildReplyMarkup(buttons),\n      scheduleDate: schedule,\n      noforwards: noforwards\n    });\n  }\n  const result = await client.invoke(request);\n  if (result instanceof tl_1.Api.UpdateShortSentMessage) {\n    const msg = new tl_1.Api.Message({\n      id: result.id,\n      peerId: await (0, users_1._getPeer)(client, entity),\n      message: message,\n      date: result.date,\n      out: result.out,\n      media: result.media,\n      entities: result.entities,\n      replyMarkup: request.replyMarkup,\n      ttlPeriod: result.ttlPeriod\n    });\n    msg._finishInit(client, new Map(), entity);\n    return msg;\n  }\n  return client._getResponseMessage(request, result, entity);\n}\n/** @hidden */\nasync function forwardMessages(client, entity, {\n  messages,\n  fromPeer,\n  silent,\n  schedule,\n  noforwards,\n  dropAuthor\n}) {\n  if (!(0, Helpers_1.isArrayLike)(messages)) {\n    messages = [messages];\n  }\n  entity = await client.getInputEntity(entity);\n  let fromPeerId;\n  if (fromPeer) {\n    fromPeer = await client.getInputEntity(fromPeer);\n    fromPeerId = await client.getPeerId(fromPeer);\n  }\n  const getKey = m => {\n    if (m instanceof tl_1.Api.Message) {\n      return m.chatId;\n    }\n    let msgId = (0, Utils_1.parseID)(m);\n    if (msgId) {\n      if (fromPeerId !== undefined) {\n        return fromPeerId;\n      }\n      throw new Error(\"fromPeer must be given if integer IDs are used\");\n    } else {\n      throw new Error(`Cannot forward ${m}`);\n    }\n  };\n  const sent = [];\n  for (let [chatId, chunk] of (0, Helpers_1.groupBy)(messages, getKey)) {\n    let chat;\n    let numbers = [];\n    if (typeof chunk[0] == \"number\") {\n      chat = fromPeer;\n      numbers = chunk;\n    } else {\n      chat = await chunk[0].getInputChat();\n      numbers = chunk.map(m => m.id);\n    }\n    chunk.push();\n    const request = new tl_1.Api.messages.ForwardMessages({\n      fromPeer: chat,\n      id: numbers,\n      toPeer: entity,\n      silent: silent,\n      scheduleDate: schedule,\n      noforwards: noforwards,\n      dropAuthor: dropAuthor\n    });\n    const result = await client.invoke(request);\n    sent.push(client._getResponseMessage(request, result, entity));\n  }\n  return sent;\n}\n/** @hidden */\nasync function editMessage(client, entity, {\n  message,\n  text,\n  parseMode,\n  formattingEntities,\n  linkPreview = true,\n  file,\n  forceDocument,\n  buttons,\n  schedule\n}) {\n  if (typeof message === \"number\" && typeof text === \"undefined\" && !file && !schedule) {\n    throw Error(\"You have to provide either file or text or schedule property.\");\n  }\n  entity = await client.getInputEntity(entity);\n  let id;\n  let markup;\n  let entities;\n  let inputMedia;\n  if (file) {\n    const {\n      fileHandle,\n      media,\n      image\n    } = await (0, uploads_1._fileToMedia)(client, {\n      file,\n      forceDocument\n    });\n    inputMedia = media;\n  }\n  if (message instanceof tl_1.Api.Message) {\n    id = (0, Utils_1.getMessageId)(message);\n    text = message.message;\n    entities = message.entities;\n    if (buttons == undefined) {\n      markup = message.replyMarkup;\n    } else {\n      markup = client.buildReplyMarkup(buttons);\n    }\n    if (message.media) {\n      inputMedia = (0, Utils_1.getInputMedia)(message.media, {\n        forceDocument\n      });\n    }\n  } else {\n    if (typeof message !== \"number\") {\n      throw Error(\"editMessageParams.message must be either a number or a Api.Message type\");\n    }\n    id = message;\n    if (formattingEntities == undefined) {\n      [text, entities] = await (0, messageParse_1._parseMessageText)(client, text || \"\", parseMode);\n    } else {\n      entities = formattingEntities;\n    }\n    markup = client.buildReplyMarkup(buttons);\n  }\n  const request = new tl_1.Api.messages.EditMessage({\n    peer: entity,\n    id,\n    message: text,\n    noWebpage: !linkPreview,\n    entities,\n    media: inputMedia,\n    replyMarkup: markup,\n    scheduleDate: schedule\n  });\n  const result = await client.invoke(request);\n  return client._getResponseMessage(request, result, entity);\n}\n/** @hidden */\nasync function deleteMessages(client, entity, messageIds, {\n  revoke = false\n}) {\n  let ty = Helpers_1._EntityType.USER;\n  if (entity) {\n    entity = await client.getInputEntity(entity);\n    ty = (0, Helpers_1._entityType)(entity);\n  }\n  const ids = [];\n  for (const messageId of messageIds) {\n    if (messageId instanceof tl_1.Api.Message || messageId instanceof tl_1.Api.MessageService || messageId instanceof tl_1.Api.MessageEmpty) {\n      ids.push(messageId.id);\n    } else if (typeof messageId === \"number\") {\n      ids.push(messageId);\n    } else {\n      throw new Error(`Cannot convert ${messageId} to an integer`);\n    }\n  }\n  const results = [];\n  if (ty == Helpers_1._EntityType.CHANNEL) {\n    for (const chunk of __1.utils.chunks(ids)) {\n      results.push(client.invoke(new tl_1.Api.channels.DeleteMessages({\n        channel: entity,\n        id: chunk\n      })));\n    }\n  } else {\n    for (const chunk of __1.utils.chunks(ids)) {\n      results.push(client.invoke(new tl_1.Api.messages.DeleteMessages({\n        id: chunk,\n        revoke: revoke\n      })));\n    }\n  }\n  return Promise.all(results);\n}\n/** @hidden */\nasync function pinMessage(client, entity, message, pinMessageParams) {\n  return await _pin(client, entity, message, false, pinMessageParams === null || pinMessageParams === void 0 ? void 0 : pinMessageParams.notify, pinMessageParams === null || pinMessageParams === void 0 ? void 0 : pinMessageParams.pmOneSide);\n}\n/** @hidden */\nasync function unpinMessage(client, entity, message, unpinMessageParams) {\n  return await _pin(client, entity, message, true, unpinMessageParams === null || unpinMessageParams === void 0 ? void 0 : unpinMessageParams.notify, unpinMessageParams === null || unpinMessageParams === void 0 ? void 0 : unpinMessageParams.pmOneSide);\n}\n/** @hidden */\nasync function _pin(client, entity, message, unpin, notify = false, pmOneSide = false) {\n  message = __1.utils.getMessageId(message) || 0;\n  if (message === 0) {\n    return await client.invoke(new tl_1.Api.messages.UnpinAllMessages({\n      peer: entity\n    }));\n  }\n  entity = await client.getInputEntity(entity);\n  const request = new tl_1.Api.messages.UpdatePinnedMessage({\n    silent: !notify,\n    unpin,\n    pmOneside: pmOneSide,\n    peer: entity,\n    id: message\n  });\n  const result = await client.invoke(request);\n  /**\n   * Unpinning does not produce a service message.\n   * Pinning a message that was already pinned also produces no service message.\n   * Pinning a message in your own chat does not produce a service message,\n   * but pinning on a private conversation with someone else does.\n   */\n  if (unpin || !(\"updates\" in result) || \"updates\" in result && !result.updates) {\n    return;\n  }\n  // Pinning a message that doesn't exist would RPC-error earlier\n  return client._getResponseMessage(request, result, entity);\n}\n/** @hidden */\nasync function markAsRead(client, entity, message, markAsReadParams) {\n  let maxId = (markAsReadParams === null || markAsReadParams === void 0 ? void 0 : markAsReadParams.maxId) || 0;\n  const maxIdIsUndefined = (markAsReadParams === null || markAsReadParams === void 0 ? void 0 : markAsReadParams.maxId) === undefined;\n  if (maxIdIsUndefined) {\n    if (message) {\n      if (Array.isArray(message)) {\n        maxId = Math.max(...message.map(v => __1.utils.getMessageId(v)));\n      } else {\n        maxId = __1.utils.getMessageId(message);\n      }\n    }\n  }\n  entity = await client.getInputEntity(entity);\n  if (markAsReadParams && !markAsReadParams.clearMentions) {\n    await client.invoke(new tl_1.Api.messages.ReadMentions({\n      peer: entity\n    }));\n    if (maxIdIsUndefined && message === undefined) {\n      return true;\n    }\n  }\n  if ((0, Helpers_1._entityType)(entity) === Helpers_1._EntityType.CHANNEL) {\n    return await client.invoke(new tl_1.Api.channels.ReadHistory({\n      channel: entity,\n      maxId\n    }));\n  } else {\n    await client.invoke(new tl_1.Api.messages.ReadHistory({\n      peer: entity,\n      maxId\n    }));\n    return true;\n  }\n}\n/** @hidden */\nasync function getCommentData(client, entity, message) {\n  const result = await client.invoke(new tl_1.Api.messages.GetDiscussionMessage({\n    peer: entity,\n    msgId: __1.utils.getMessageId(message)\n  }));\n  const relevantMessage = result.messages.reduce((p, c) => p && p.id < c.id ? p : c);\n  let chat;\n  for (const c of result.chats) {\n    if (relevantMessage.peerId instanceof tl_1.Api.PeerChannel && c.id.eq(relevantMessage.peerId.channelId)) {\n      chat = c;\n      break;\n    }\n  }\n  return {\n    entity: __1.utils.getInputPeer(chat),\n    replyTo: relevantMessage.id\n  };\n}\n// TODO do the rest","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}