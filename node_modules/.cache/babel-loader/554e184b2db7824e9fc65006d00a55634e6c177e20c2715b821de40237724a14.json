{"ast":null,"code":"\"use strict\";\n\n/* eslint-disable prefer-destructuring */\n/* eslint-disable no-param-reassign */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address6 = void 0;\nconst common = __importStar(require(\"./common\"));\nconst constants4 = __importStar(require(\"./v4/constants\"));\nconst constants6 = __importStar(require(\"./v6/constants\"));\nconst helpers = __importStar(require(\"./v6/helpers\"));\nconst ipv4_1 = require(\"./ipv4\");\nconst regular_expressions_1 = require(\"./v6/regular-expressions\");\nconst address_error_1 = require(\"./address-error\");\nconst jsbn_1 = require(\"jsbn\");\nconst sprintf_js_1 = require(\"sprintf-js\");\nfunction assert(condition) {\n  if (!condition) {\n    throw new Error('Assertion failed.');\n  }\n}\nfunction addCommas(number) {\n  const r = /(\\d+)(\\d{3})/;\n  while (r.test(number)) {\n    number = number.replace(r, '$1,$2');\n  }\n  return number;\n}\nfunction spanLeadingZeroes4(n) {\n  n = n.replace(/^(0{1,})([1-9]+)$/, '<span class=\"parse-error\">$1</span>$2');\n  n = n.replace(/^(0{1,})(0)$/, '<span class=\"parse-error\">$1</span>$2');\n  return n;\n}\n/*\n * A helper function to compact an array\n */\nfunction compact(address, slice) {\n  const s1 = [];\n  const s2 = [];\n  let i;\n  for (i = 0; i < address.length; i++) {\n    if (i < slice[0]) {\n      s1.push(address[i]);\n    } else if (i > slice[1]) {\n      s2.push(address[i]);\n    }\n  }\n  return s1.concat(['compact']).concat(s2);\n}\nfunction paddedHex(octet) {\n  return (0, sprintf_js_1.sprintf)('%04x', parseInt(octet, 16));\n}\nfunction unsignByte(b) {\n  // eslint-disable-next-line no-bitwise\n  return b & 0xff;\n}\n/**\n * Represents an IPv6 address\n * @class Address6\n * @param {string} address - An IPv6 address string\n * @param {number} [groups=8] - How many octets to parse\n * @example\n * var address = new Address6('2001::/32');\n */\nclass Address6 {\n  constructor(address, optionalGroups) {\n    this.addressMinusSuffix = '';\n    this.parsedSubnet = '';\n    this.subnet = '/128';\n    this.subnetMask = 128;\n    this.v4 = false;\n    this.zone = '';\n    // #region Attributes\n    /**\n     * Returns true if the given address is in the subnet of the current address\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    this.isInSubnet = common.isInSubnet;\n    /**\n     * Returns true if the address is correct, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    this.isCorrect = common.isCorrect(constants6.BITS);\n    if (optionalGroups === undefined) {\n      this.groups = constants6.GROUPS;\n    } else {\n      this.groups = optionalGroups;\n    }\n    this.address = address;\n    const subnet = constants6.RE_SUBNET_STRING.exec(address);\n    if (subnet) {\n      this.parsedSubnet = subnet[0].replace('/', '');\n      this.subnetMask = parseInt(this.parsedSubnet, 10);\n      this.subnet = `/${this.subnetMask}`;\n      if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {\n        throw new address_error_1.AddressError('Invalid subnet mask.');\n      }\n      address = address.replace(constants6.RE_SUBNET_STRING, '');\n    } else if (/\\//.test(address)) {\n      throw new address_error_1.AddressError('Invalid subnet mask.');\n    }\n    const zone = constants6.RE_ZONE_STRING.exec(address);\n    if (zone) {\n      this.zone = zone[0];\n      address = address.replace(constants6.RE_ZONE_STRING, '');\n    }\n    this.addressMinusSuffix = address;\n    this.parsedAddress = this.parse(this.addressMinusSuffix);\n  }\n  static isValid(address) {\n    try {\n      // eslint-disable-next-line no-new\n      new Address6(address);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n   * Convert a BigInteger to a v6 address object\n   * @memberof Address6\n   * @static\n   * @param {BigInteger} bigInteger - a BigInteger to convert\n   * @returns {Address6}\n   * @example\n   * var bigInteger = new BigInteger('1000000000000');\n   * var address = Address6.fromBigInteger(bigInteger);\n   * address.correctForm(); // '::e8:d4a5:1000'\n   */\n  static fromBigInteger(bigInteger) {\n    const hex = bigInteger.toString(16).padStart(32, '0');\n    const groups = [];\n    let i;\n    for (i = 0; i < constants6.GROUPS; i++) {\n      groups.push(hex.slice(i * 4, (i + 1) * 4));\n    }\n    return new Address6(groups.join(':'));\n  }\n  /**\n   * Convert a URL (with optional port number) to an address object\n   * @memberof Address6\n   * @static\n   * @param {string} url - a URL with optional port number\n   * @example\n   * var addressAndPort = Address6.fromURL('http://[ffff::]:8080/foo/');\n   * addressAndPort.address.correctForm(); // 'ffff::'\n   * addressAndPort.port; // 8080\n   */\n  static fromURL(url) {\n    let host;\n    let port = null;\n    let result;\n    // If we have brackets parse them and find a port\n    if (url.indexOf('[') !== -1 && url.indexOf(']:') !== -1) {\n      result = constants6.RE_URL_WITH_PORT.exec(url);\n      if (result === null) {\n        return {\n          error: 'failed to parse address with port',\n          address: null,\n          port: null\n        };\n      }\n      host = result[1];\n      port = result[2];\n      // If there's a URL extract the address\n    } else if (url.indexOf('/') !== -1) {\n      // Remove the protocol prefix\n      url = url.replace(/^[a-z0-9]+:\\/\\//, '');\n      // Parse the address\n      result = constants6.RE_URL.exec(url);\n      if (result === null) {\n        return {\n          error: 'failed to parse address from URL',\n          address: null,\n          port: null\n        };\n      }\n      host = result[1];\n      // Otherwise just assign the URL to the host and let the library parse it\n    } else {\n      host = url;\n    }\n    // If there's a port convert it to an integer\n    if (port) {\n      port = parseInt(port, 10);\n      // squelch out of range ports\n      if (port < 0 || port > 65536) {\n        port = null;\n      }\n    } else {\n      // Standardize `undefined` to `null`\n      port = null;\n    }\n    return {\n      address: new Address6(host),\n      port\n    };\n  }\n  /**\n   * Create an IPv6-mapped address given an IPv4 address\n   * @memberof Address6\n   * @static\n   * @param {string} address - An IPv4 address string\n   * @returns {Address6}\n   * @example\n   * var address = Address6.fromAddress4('192.168.0.1');\n   * address.correctForm(); // '::ffff:c0a8:1'\n   * address.to4in6(); // '::ffff:192.168.0.1'\n   */\n  static fromAddress4(address) {\n    const address4 = new ipv4_1.Address4(address);\n    const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);\n    return new Address6(`::ffff:${address4.correctForm()}/${mask6}`);\n  }\n  /**\n   * Return an address from ip6.arpa form\n   * @memberof Address6\n   * @static\n   * @param {string} arpaFormAddress - an 'ip6.arpa' form address\n   * @returns {Adress6}\n   * @example\n   * var address = Address6.fromArpa(e.f.f.f.3.c.2.6.f.f.f.e.6.6.8.e.1.0.6.7.9.4.e.c.0.0.0.0.1.0.0.2.ip6.arpa.)\n   * address.correctForm(); // '2001:0:ce49:7601:e866:efff:62c3:fffe'\n   */\n  static fromArpa(arpaFormAddress) {\n    // remove ending \".ip6.arpa.\" or just \".\"\n    let address = arpaFormAddress.replace(/(\\.ip6\\.arpa)?\\.$/, '');\n    const semicolonAmount = 7;\n    // correct ip6.arpa form with ending removed will be 63 characters\n    if (address.length !== 63) {\n      throw new address_error_1.AddressError(\"Invalid 'ip6.arpa' form.\");\n    }\n    const parts = address.split('.').reverse();\n    for (let i = semicolonAmount; i > 0; i--) {\n      const insertIndex = i * 4;\n      parts.splice(insertIndex, 0, ':');\n    }\n    address = parts.join('');\n    return new Address6(address);\n  }\n  /**\n   * Return the Microsoft UNC transcription of the address\n   * @memberof Address6\n   * @instance\n   * @returns {String} the Microsoft UNC transcription of the address\n   */\n  microsoftTranscription() {\n    return (0, sprintf_js_1.sprintf)('%s.ipv6-literal.net', this.correctForm().replace(/:/g, '-'));\n  }\n  /**\n   * Return the first n bits of the address, defaulting to the subnet mask\n   * @memberof Address6\n   * @instance\n   * @param {number} [mask=subnet] - the number of bits to mask\n   * @returns {String} the first n bits of the address as a string\n   */\n  mask(mask = this.subnetMask) {\n    return this.getBitsBase2(0, mask);\n  }\n  /**\n   * Return the number of possible subnets of a given size in the address\n   * @memberof Address6\n   * @instance\n   * @param {number} [size=128] - the subnet size\n   * @returns {String}\n   */\n  // TODO: probably useful to have a numeric version of this too\n  possibleSubnets(subnetSize = 128) {\n    const availableBits = constants6.BITS - this.subnetMask;\n    const subnetBits = Math.abs(subnetSize - constants6.BITS);\n    const subnetPowers = availableBits - subnetBits;\n    if (subnetPowers < 0) {\n      return '0';\n    }\n    return addCommas(new jsbn_1.BigInteger('2', 10).pow(subnetPowers).toString(10));\n  }\n  /**\n   * Helper function getting start address.\n   * @memberof Address6\n   * @instance\n   * @returns {BigInteger}\n   */\n  _startAddress() {\n    return new jsbn_1.BigInteger(this.mask() + '0'.repeat(constants6.BITS - this.subnetMask), 2);\n  }\n  /**\n   * The first address in the range given by this address' subnet\n   * Often referred to as the Network Address.\n   * @memberof Address6\n   * @instance\n   * @returns {Address6}\n   */\n  startAddress() {\n    return Address6.fromBigInteger(this._startAddress());\n  }\n  /**\n   * The first host address in the range given by this address's subnet ie\n   * the first address after the Network Address\n   * @memberof Address6\n   * @instance\n   * @returns {Address6}\n   */\n  startAddressExclusive() {\n    const adjust = new jsbn_1.BigInteger('1');\n    return Address6.fromBigInteger(this._startAddress().add(adjust));\n  }\n  /**\n   * Helper function getting end address.\n   * @memberof Address6\n   * @instance\n   * @returns {BigInteger}\n   */\n  _endAddress() {\n    return new jsbn_1.BigInteger(this.mask() + '1'.repeat(constants6.BITS - this.subnetMask), 2);\n  }\n  /**\n   * The last address in the range given by this address' subnet\n   * Often referred to as the Broadcast\n   * @memberof Address6\n   * @instance\n   * @returns {Address6}\n   */\n  endAddress() {\n    return Address6.fromBigInteger(this._endAddress());\n  }\n  /**\n   * The last host address in the range given by this address's subnet ie\n   * the last address prior to the Broadcast Address\n   * @memberof Address6\n   * @instance\n   * @returns {Address6}\n   */\n  endAddressExclusive() {\n    const adjust = new jsbn_1.BigInteger('1');\n    return Address6.fromBigInteger(this._endAddress().subtract(adjust));\n  }\n  /**\n   * Return the scope of the address\n   * @memberof Address6\n   * @instance\n   * @returns {String}\n   */\n  getScope() {\n    let scope = constants6.SCOPES[this.getBits(12, 16).intValue()];\n    if (this.getType() === 'Global unicast' && scope !== 'Link local') {\n      scope = 'Global';\n    }\n    return scope || 'Unknown';\n  }\n  /**\n   * Return the type of the address\n   * @memberof Address6\n   * @instance\n   * @returns {String}\n   */\n  getType() {\n    for (const subnet of Object.keys(constants6.TYPES)) {\n      if (this.isInSubnet(new Address6(subnet))) {\n        return constants6.TYPES[subnet];\n      }\n    }\n    return 'Global unicast';\n  }\n  /**\n   * Return the bits in the given range as a BigInteger\n   * @memberof Address6\n   * @instance\n   * @returns {BigInteger}\n   */\n  getBits(start, end) {\n    return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);\n  }\n  /**\n   * Return the bits in the given range as a base-2 string\n   * @memberof Address6\n   * @instance\n   * @returns {String}\n   */\n  getBitsBase2(start, end) {\n    return this.binaryZeroPad().slice(start, end);\n  }\n  /**\n   * Return the bits in the given range as a base-16 string\n   * @memberof Address6\n   * @instance\n   * @returns {String}\n   */\n  getBitsBase16(start, end) {\n    const length = end - start;\n    if (length % 4 !== 0) {\n      throw new Error('Length of bits to retrieve must be divisible by four');\n    }\n    return this.getBits(start, end).toString(16).padStart(length / 4, '0');\n  }\n  /**\n   * Return the bits that are set past the subnet mask length\n   * @memberof Address6\n   * @instance\n   * @returns {String}\n   */\n  getBitsPastSubnet() {\n    return this.getBitsBase2(this.subnetMask, constants6.BITS);\n  }\n  /**\n   * Return the reversed ip6.arpa form of the address\n   * @memberof Address6\n   * @param {Object} options\n   * @param {boolean} options.omitSuffix - omit the \"ip6.arpa\" suffix\n   * @instance\n   * @returns {String}\n   */\n  reverseForm(options) {\n    if (!options) {\n      options = {};\n    }\n    const characters = Math.floor(this.subnetMask / 4);\n    const reversed = this.canonicalForm().replace(/:/g, '').split('').slice(0, characters).reverse().join('.');\n    if (characters > 0) {\n      if (options.omitSuffix) {\n        return reversed;\n      }\n      return (0, sprintf_js_1.sprintf)('%s.ip6.arpa.', reversed);\n    }\n    if (options.omitSuffix) {\n      return '';\n    }\n    return 'ip6.arpa.';\n  }\n  /**\n   * Return the correct form of the address\n   * @memberof Address6\n   * @instance\n   * @returns {String}\n   */\n  correctForm() {\n    let i;\n    let groups = [];\n    let zeroCounter = 0;\n    const zeroes = [];\n    for (i = 0; i < this.parsedAddress.length; i++) {\n      const value = parseInt(this.parsedAddress[i], 16);\n      if (value === 0) {\n        zeroCounter++;\n      }\n      if (value !== 0 && zeroCounter > 0) {\n        if (zeroCounter > 1) {\n          zeroes.push([i - zeroCounter, i - 1]);\n        }\n        zeroCounter = 0;\n      }\n    }\n    // Do we end with a string of zeroes?\n    if (zeroCounter > 1) {\n      zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);\n    }\n    const zeroLengths = zeroes.map(n => n[1] - n[0] + 1);\n    if (zeroes.length > 0) {\n      const index = zeroLengths.indexOf(Math.max(...zeroLengths));\n      groups = compact(this.parsedAddress, zeroes[index]);\n    } else {\n      groups = this.parsedAddress;\n    }\n    for (i = 0; i < groups.length; i++) {\n      if (groups[i] !== 'compact') {\n        groups[i] = parseInt(groups[i], 16).toString(16);\n      }\n    }\n    let correct = groups.join(':');\n    correct = correct.replace(/^compact$/, '::');\n    correct = correct.replace(/^compact|compact$/, ':');\n    correct = correct.replace(/compact/, '');\n    return correct;\n  }\n  /**\n   * Return a zero-padded base-2 string representation of the address\n   * @memberof Address6\n   * @instance\n   * @returns {String}\n   * @example\n   * var address = new Address6('2001:4860:4001:803::1011');\n   * address.binaryZeroPad();\n   * // '0010000000000001010010000110000001000000000000010000100000000011\n   * //  0000000000000000000000000000000000000000000000000001000000010001'\n   */\n  binaryZeroPad() {\n    return this.bigInteger().toString(2).padStart(constants6.BITS, '0');\n  }\n  // TODO: Improve the semantics of this helper function\n  parse4in6(address) {\n    const groups = address.split(':');\n    const lastGroup = groups.slice(-1)[0];\n    const address4 = lastGroup.match(constants4.RE_ADDRESS);\n    if (address4) {\n      this.parsedAddress4 = address4[0];\n      this.address4 = new ipv4_1.Address4(this.parsedAddress4);\n      for (let i = 0; i < this.address4.groups; i++) {\n        if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {\n          throw new address_error_1.AddressError(\"IPv4 addresses can't have leading zeroes.\", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join('.')));\n        }\n      }\n      this.v4 = true;\n      groups[groups.length - 1] = this.address4.toGroup6();\n      address = groups.join(':');\n    }\n    return address;\n  }\n  // TODO: Make private?\n  parse(address) {\n    address = this.parse4in6(address);\n    const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);\n    if (badCharacters) {\n      throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)('Bad character%s detected in address: %s', badCharacters.length > 1 ? 's' : '', badCharacters.join('')), address.replace(constants6.RE_BAD_CHARACTERS, '<span class=\"parse-error\">$1</span>'));\n    }\n    const badAddress = address.match(constants6.RE_BAD_ADDRESS);\n    if (badAddress) {\n      throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)('Address failed regex: %s', badAddress.join('')), address.replace(constants6.RE_BAD_ADDRESS, '<span class=\"parse-error\">$1</span>'));\n    }\n    let groups = [];\n    const halves = address.split('::');\n    if (halves.length === 2) {\n      let first = halves[0].split(':');\n      let last = halves[1].split(':');\n      if (first.length === 1 && first[0] === '') {\n        first = [];\n      }\n      if (last.length === 1 && last[0] === '') {\n        last = [];\n      }\n      const remaining = this.groups - (first.length + last.length);\n      if (!remaining) {\n        throw new address_error_1.AddressError('Error parsing groups');\n      }\n      this.elidedGroups = remaining;\n      this.elisionBegin = first.length;\n      this.elisionEnd = first.length + this.elidedGroups;\n      groups = groups.concat(first);\n      for (let i = 0; i < remaining; i++) {\n        groups.push('0');\n      }\n      groups = groups.concat(last);\n    } else if (halves.length === 1) {\n      groups = address.split(':');\n      this.elidedGroups = 0;\n    } else {\n      throw new address_error_1.AddressError('Too many :: groups found');\n    }\n    groups = groups.map(group => (0, sprintf_js_1.sprintf)('%x', parseInt(group, 16)));\n    if (groups.length !== this.groups) {\n      throw new address_error_1.AddressError('Incorrect number of groups found');\n    }\n    return groups;\n  }\n  /**\n   * Return the canonical form of the address\n   * @memberof Address6\n   * @instance\n   * @returns {String}\n   */\n  canonicalForm() {\n    return this.parsedAddress.map(paddedHex).join(':');\n  }\n  /**\n   * Return the decimal form of the address\n   * @memberof Address6\n   * @instance\n   * @returns {String}\n   */\n  decimal() {\n    return this.parsedAddress.map(n => (0, sprintf_js_1.sprintf)('%05d', parseInt(n, 16))).join(':');\n  }\n  /**\n   * Return the address as a BigInteger\n   * @memberof Address6\n   * @instance\n   * @returns {BigInteger}\n   */\n  bigInteger() {\n    return new jsbn_1.BigInteger(this.parsedAddress.map(paddedHex).join(''), 16);\n  }\n  /**\n   * Return the last two groups of this address as an IPv4 address string\n   * @memberof Address6\n   * @instance\n   * @returns {Address4}\n   * @example\n   * var address = new Address6('2001:4860:4001::1825:bf11');\n   * address.to4().correctForm(); // '24.37.191.17'\n   */\n  to4() {\n    const binary = this.binaryZeroPad().split('');\n    return ipv4_1.Address4.fromHex(new jsbn_1.BigInteger(binary.slice(96, 128).join(''), 2).toString(16));\n  }\n  /**\n   * Return the v4-in-v6 form of the address\n   * @memberof Address6\n   * @instance\n   * @returns {String}\n   */\n  to4in6() {\n    const address4 = this.to4();\n    const address6 = new Address6(this.parsedAddress.slice(0, 6).join(':'), 6);\n    const correct = address6.correctForm();\n    let infix = '';\n    if (!/:$/.test(correct)) {\n      infix = ':';\n    }\n    return correct + infix + address4.address;\n  }\n  /**\n   * Return an object containing the Teredo properties of the address\n   * @memberof Address6\n   * @instance\n   * @returns {Object}\n   */\n  inspectTeredo() {\n    /*\n    - Bits 0 to 31 are set to the Teredo prefix (normally 2001:0000::/32).\n    - Bits 32 to 63 embed the primary IPv4 address of the Teredo server that\n      is used.\n    - Bits 64 to 79 can be used to define some flags. Currently only the\n      higher order bit is used; it is set to 1 if the Teredo client is\n      located behind a cone NAT, 0 otherwise. For Microsoft's Windows Vista\n      and Windows Server 2008 implementations, more bits are used. In those\n      implementations, the format for these 16 bits is \"CRAAAAUG AAAAAAAA\",\n      where \"C\" remains the \"Cone\" flag. The \"R\" bit is reserved for future\n      use. The \"U\" bit is for the Universal/Local flag (set to 0). The \"G\" bit\n      is Individual/Group flag (set to 0). The A bits are set to a 12-bit\n      randomly generated number chosen by the Teredo client to introduce\n      additional protection for the Teredo node against IPv6-based scanning\n      attacks.\n    - Bits 80 to 95 contains the obfuscated UDP port number. This is the\n      port number that is mapped by the NAT to the Teredo client with all\n      bits inverted.\n    - Bits 96 to 127 contains the obfuscated IPv4 address. This is the\n      public IPv4 address of the NAT with all bits inverted.\n    */\n    const prefix = this.getBitsBase16(0, 32);\n    const udpPort = this.getBits(80, 96).xor(new jsbn_1.BigInteger('ffff', 16)).toString();\n    const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));\n    const client4 = ipv4_1.Address4.fromHex(this.getBits(96, 128).xor(new jsbn_1.BigInteger('ffffffff', 16)).toString(16));\n    const flags = this.getBits(64, 80);\n    const flagsBase2 = this.getBitsBase2(64, 80);\n    const coneNat = flags.testBit(15);\n    const reserved = flags.testBit(14);\n    const groupIndividual = flags.testBit(8);\n    const universalLocal = flags.testBit(9);\n    const nonce = new jsbn_1.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);\n    return {\n      prefix: (0, sprintf_js_1.sprintf)('%s:%s', prefix.slice(0, 4), prefix.slice(4, 8)),\n      server4: server4.address,\n      client4: client4.address,\n      flags: flagsBase2,\n      coneNat,\n      microsoft: {\n        reserved,\n        universalLocal,\n        groupIndividual,\n        nonce\n      },\n      udpPort\n    };\n  }\n  /**\n   * Return an object containing the 6to4 properties of the address\n   * @memberof Address6\n   * @instance\n   * @returns {Object}\n   */\n  inspect6to4() {\n    /*\n    - Bits 0 to 15 are set to the 6to4 prefix (2002::/16).\n    - Bits 16 to 48 embed the IPv4 address of the 6to4 gateway that is used.\n    */\n    const prefix = this.getBitsBase16(0, 16);\n    const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));\n    return {\n      prefix: (0, sprintf_js_1.sprintf)('%s', prefix.slice(0, 4)),\n      gateway: gateway.address\n    };\n  }\n  /**\n   * Return a v6 6to4 address from a v6 v4inv6 address\n   * @memberof Address6\n   * @instance\n   * @returns {Address6}\n   */\n  to6to4() {\n    if (!this.is4()) {\n      return null;\n    }\n    const addr6to4 = ['2002', this.getBitsBase16(96, 112), this.getBitsBase16(112, 128), '', '/16'].join(':');\n    return new Address6(addr6to4);\n  }\n  /**\n   * Return a byte array\n   * @memberof Address6\n   * @instance\n   * @returns {Array}\n   */\n  toByteArray() {\n    const byteArray = this.bigInteger().toByteArray();\n    // work around issue where `toByteArray` returns a leading 0 element\n    if (byteArray.length === 17 && byteArray[0] === 0) {\n      return byteArray.slice(1);\n    }\n    return byteArray;\n  }\n  /**\n   * Return an unsigned byte array\n   * @memberof Address6\n   * @instance\n   * @returns {Array}\n   */\n  toUnsignedByteArray() {\n    return this.toByteArray().map(unsignByte);\n  }\n  /**\n   * Convert a byte array to an Address6 object\n   * @memberof Address6\n   * @static\n   * @returns {Address6}\n   */\n  static fromByteArray(bytes) {\n    return this.fromUnsignedByteArray(bytes.map(unsignByte));\n  }\n  /**\n   * Convert an unsigned byte array to an Address6 object\n   * @memberof Address6\n   * @static\n   * @returns {Address6}\n   */\n  static fromUnsignedByteArray(bytes) {\n    const BYTE_MAX = new jsbn_1.BigInteger('256', 10);\n    let result = new jsbn_1.BigInteger('0', 10);\n    let multiplier = new jsbn_1.BigInteger('1', 10);\n    for (let i = bytes.length - 1; i >= 0; i--) {\n      result = result.add(multiplier.multiply(new jsbn_1.BigInteger(bytes[i].toString(10), 10)));\n      multiplier = multiplier.multiply(BYTE_MAX);\n    }\n    return Address6.fromBigInteger(result);\n  }\n  /**\n   * Returns true if the address is in the canonical form, false otherwise\n   * @memberof Address6\n   * @instance\n   * @returns {boolean}\n   */\n  isCanonical() {\n    return this.addressMinusSuffix === this.canonicalForm();\n  }\n  /**\n   * Returns true if the address is a link local address, false otherwise\n   * @memberof Address6\n   * @instance\n   * @returns {boolean}\n   */\n  isLinkLocal() {\n    // Zeroes are required, i.e. we can't check isInSubnet with 'fe80::/10'\n    if (this.getBitsBase2(0, 64) === '1111111010000000000000000000000000000000000000000000000000000000') {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Returns true if the address is a multicast address, false otherwise\n   * @memberof Address6\n   * @instance\n   * @returns {boolean}\n   */\n  isMulticast() {\n    return this.getType() === 'Multicast';\n  }\n  /**\n   * Returns true if the address is a v4-in-v6 address, false otherwise\n   * @memberof Address6\n   * @instance\n   * @returns {boolean}\n   */\n  is4() {\n    return this.v4;\n  }\n  /**\n   * Returns true if the address is a Teredo address, false otherwise\n   * @memberof Address6\n   * @instance\n   * @returns {boolean}\n   */\n  isTeredo() {\n    return this.isInSubnet(new Address6('2001::/32'));\n  }\n  /**\n   * Returns true if the address is a 6to4 address, false otherwise\n   * @memberof Address6\n   * @instance\n   * @returns {boolean}\n   */\n  is6to4() {\n    return this.isInSubnet(new Address6('2002::/16'));\n  }\n  /**\n   * Returns true if the address is a loopback address, false otherwise\n   * @memberof Address6\n   * @instance\n   * @returns {boolean}\n   */\n  isLoopback() {\n    return this.getType() === 'Loopback';\n  }\n  // #endregion\n  // #region HTML\n  /**\n   * @returns {String} the address in link form with a default port of 80\n   */\n  href(optionalPort) {\n    if (optionalPort === undefined) {\n      optionalPort = '';\n    } else {\n      optionalPort = (0, sprintf_js_1.sprintf)(':%s', optionalPort);\n    }\n    return (0, sprintf_js_1.sprintf)('http://[%s]%s/', this.correctForm(), optionalPort);\n  }\n  /**\n   * @returns {String} a link suitable for conveying the address via a URL hash\n   */\n  link(options) {\n    if (!options) {\n      options = {};\n    }\n    if (options.className === undefined) {\n      options.className = '';\n    }\n    if (options.prefix === undefined) {\n      options.prefix = '/#address=';\n    }\n    if (options.v4 === undefined) {\n      options.v4 = false;\n    }\n    let formFunction = this.correctForm;\n    if (options.v4) {\n      formFunction = this.to4in6;\n    }\n    if (options.className) {\n      return (0, sprintf_js_1.sprintf)('<a href=\"%1$s%2$s\" class=\"%3$s\">%2$s</a>', options.prefix, formFunction.call(this), options.className);\n    }\n    return (0, sprintf_js_1.sprintf)('<a href=\"%1$s%2$s\">%2$s</a>', options.prefix, formFunction.call(this));\n  }\n  /**\n   * Groups an address\n   * @returns {String}\n   */\n  group() {\n    if (this.elidedGroups === 0) {\n      // The simple case\n      return helpers.simpleGroup(this.address).join(':');\n    }\n    assert(typeof this.elidedGroups === 'number');\n    assert(typeof this.elisionBegin === 'number');\n    // The elided case\n    const output = [];\n    const [left, right] = this.address.split('::');\n    if (left.length) {\n      output.push(...helpers.simpleGroup(left));\n    } else {\n      output.push('');\n    }\n    const classes = ['hover-group'];\n    for (let i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {\n      classes.push((0, sprintf_js_1.sprintf)('group-%d', i));\n    }\n    output.push((0, sprintf_js_1.sprintf)('<span class=\"%s\"></span>', classes.join(' ')));\n    if (right.length) {\n      output.push(...helpers.simpleGroup(right, this.elisionEnd));\n    } else {\n      output.push('');\n    }\n    if (this.is4()) {\n      assert(this.address4 instanceof ipv4_1.Address4);\n      output.pop();\n      output.push(this.address4.groupForV6());\n    }\n    return output.join(':');\n  }\n  // #endregion\n  // #region Regular expressions\n  /**\n   * Generate a regular expression string that can be used to find or validate\n   * all variations of this address\n   * @memberof Address6\n   * @instance\n   * @param {boolean} substringSearch\n   * @returns {string}\n   */\n  regularExpressionString(substringSearch = false) {\n    let output = [];\n    // TODO: revisit why this is necessary\n    const address6 = new Address6(this.correctForm());\n    if (address6.elidedGroups === 0) {\n      // The simple case\n      output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));\n    } else if (address6.elidedGroups === constants6.GROUPS) {\n      // A completely elided address\n      output.push((0, regular_expressions_1.possibleElisions)(constants6.GROUPS));\n    } else {\n      // A partially elided address\n      const halves = address6.address.split('::');\n      if (halves[0].length) {\n        output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(':')));\n      }\n      assert(typeof address6.elidedGroups === 'number');\n      output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));\n      if (halves[1].length) {\n        output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(':')));\n      }\n      output = [output.join(':')];\n    }\n    if (!substringSearch) {\n      output = ['(?=^|', regular_expressions_1.ADDRESS_BOUNDARY, '|[^\\\\w\\\\:])(', ...output, ')(?=[^\\\\w\\\\:]|', regular_expressions_1.ADDRESS_BOUNDARY, '|$)'];\n    }\n    return output.join('');\n  }\n  /**\n   * Generate a regular expression that can be used to find or validate all\n   * variations of this address.\n   * @memberof Address6\n   * @instance\n   * @param {boolean} substringSearch\n   * @returns {RegExp}\n   */\n  regularExpression(substringSearch = false) {\n    return new RegExp(this.regularExpressionString(substringSearch), 'i');\n  }\n}\nexports.Address6 = Address6;\n//# sourceMappingURL=ipv6.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}