{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.doAuthentication = doAuthentication;\nconst Helpers_1 = require(\"../Helpers\");\nconst tl_1 = require(\"../tl\");\nconst errors_1 = require(\"../errors\");\nconst Factorizator_1 = require(\"../crypto/Factorizator\");\nconst RSA_1 = require(\"../crypto/RSA\");\nconst IGE_1 = require(\"../crypto/IGE\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst extensions_1 = require(\"../extensions\");\nconst AuthKey_1 = require(\"../crypto/AuthKey\");\nconst RETRIES = 20;\nasync function doAuthentication(sender, log) {\n  // Step 1 sending: PQ Request, endianness doesn't matter since it's random\n  let bytes = (0, Helpers_1.generateRandomBytes)(16);\n  const nonce = (0, Helpers_1.readBigIntFromBuffer)(bytes, false, true);\n  const resPQ = await sender.send(new tl_1.Api.ReqPqMulti({\n    nonce\n  }));\n  log.debug(\"Starting authKey generation step 1\");\n  if (!(resPQ instanceof tl_1.Api.ResPQ)) {\n    throw new errors_1.SecurityError(`Step 1 answer was ${resPQ}`);\n  }\n  if (resPQ.nonce.neq(nonce)) {\n    throw new errors_1.SecurityError(\"Step 1 invalid nonce from server\");\n  }\n  const pq = (0, Helpers_1.readBigIntFromBuffer)(resPQ.pq, false, true);\n  log.debug(\"Finished authKey generation step 1\");\n  // Step 2 sending: DH Exchange\n  const {\n    p,\n    q\n  } = Factorizator_1.Factorizator.factorize(pq);\n  const pBuffer = (0, Helpers_1.getByteArray)(p);\n  const qBuffer = (0, Helpers_1.getByteArray)(q);\n  bytes = (0, Helpers_1.generateRandomBytes)(32);\n  const newNonce = (0, Helpers_1.readBigIntFromBuffer)(bytes, true, true);\n  const pqInnerData = new tl_1.Api.PQInnerData({\n    pq: (0, Helpers_1.getByteArray)(pq),\n    // unsigned\n    p: pBuffer,\n    q: qBuffer,\n    nonce: resPQ.nonce,\n    serverNonce: resPQ.serverNonce,\n    newNonce\n  }).getBytes();\n  if (pqInnerData.length > 144) {\n    throw new errors_1.SecurityError(\"Step 1 invalid nonce from server\");\n  }\n  let targetFingerprint;\n  let targetKey;\n  for (const fingerprint of resPQ.serverPublicKeyFingerprints) {\n    targetKey = RSA_1._serverKeys.get(fingerprint.toString());\n    if (targetKey !== undefined) {\n      targetFingerprint = fingerprint;\n      break;\n    }\n  }\n  if (targetFingerprint === undefined || targetKey === undefined) {\n    throw new errors_1.SecurityError(\"Step 2 could not find a valid key for fingerprints\");\n  }\n  // Value should be padded to be made 192 exactly\n  const padding = (0, Helpers_1.generateRandomBytes)(192 - pqInnerData.length);\n  const dataWithPadding = Buffer.concat([pqInnerData, padding]);\n  const dataPadReversed = Buffer.from(dataWithPadding).reverse();\n  let encryptedData;\n  for (let i = 0; i < RETRIES; i++) {\n    const tempKey = (0, Helpers_1.generateRandomBytes)(32);\n    const shaDigestKeyWithData = await (0, Helpers_1.sha256)(Buffer.concat([tempKey, dataWithPadding]));\n    const dataWithHash = Buffer.concat([dataPadReversed, shaDigestKeyWithData]);\n    const ige = new IGE_1.IGE(tempKey, Buffer.alloc(32));\n    const aesEncrypted = ige.encryptIge(dataWithHash);\n    const tempKeyXor = (0, Helpers_1.bufferXor)(tempKey, await (0, Helpers_1.sha256)(aesEncrypted));\n    const keyAesEncrypted = Buffer.concat([tempKeyXor, aesEncrypted]);\n    const keyAesEncryptedInt = (0, Helpers_1.readBigIntFromBuffer)(keyAesEncrypted, false, false);\n    if (keyAesEncryptedInt.greaterOrEquals(targetKey.n)) {\n      log.debug(\"Aes key greater than RSA. retrying\");\n      continue;\n    }\n    const encryptedDataBuffer = (0, Helpers_1.modExp)(keyAesEncryptedInt, (0, big_integer_1.default)(targetKey.e), targetKey.n);\n    encryptedData = (0, Helpers_1.readBufferFromBigInt)(encryptedDataBuffer, 256, false, false);\n    break;\n  }\n  if (encryptedData === undefined) {\n    throw new errors_1.SecurityError(\"Step 2 could create a secure encrypted key\");\n  }\n  log.debug(\"Step 2 : Generated a secure aes encrypted data\");\n  const serverDhParams = await sender.send(new tl_1.Api.ReqDHParams({\n    nonce: resPQ.nonce,\n    serverNonce: resPQ.serverNonce,\n    p: pBuffer,\n    q: qBuffer,\n    publicKeyFingerprint: targetFingerprint,\n    encryptedData\n  }));\n  if (!(serverDhParams instanceof tl_1.Api.ServerDHParamsOk || serverDhParams instanceof tl_1.Api.ServerDHParamsFail)) {\n    throw new Error(`Step 2.1 answer was ${serverDhParams}`);\n  }\n  if (serverDhParams.nonce.neq(resPQ.nonce)) {\n    throw new errors_1.SecurityError(\"Step 2 invalid nonce from server\");\n  }\n  if (serverDhParams.serverNonce.neq(resPQ.serverNonce)) {\n    throw new errors_1.SecurityError(\"Step 2 invalid server nonce from server\");\n  }\n  if (serverDhParams instanceof tl_1.Api.ServerDHParamsFail) {\n    const sh = await (0, Helpers_1.sha1)((0, Helpers_1.toSignedLittleBuffer)(newNonce, 32).slice(4, 20));\n    const nnh = (0, Helpers_1.readBigIntFromBuffer)(sh, true, true);\n    if (serverDhParams.newNonceHash.neq(nnh)) {\n      throw new errors_1.SecurityError(\"Step 2 invalid DH fail nonce from server\");\n    }\n  }\n  if (!(serverDhParams instanceof tl_1.Api.ServerDHParamsOk)) {\n    throw new Error(`Step 2.2 answer was ${serverDhParams}`);\n  }\n  log.debug(\"Finished authKey generation step 2\");\n  log.debug(\"Starting authKey generation step 3\");\n  // Step 3 sending: Complete DH Exchange\n  const {\n    key,\n    iv\n  } = await (0, Helpers_1.generateKeyDataFromNonce)(resPQ.serverNonce, newNonce);\n  if (serverDhParams.encryptedAnswer.length % 16 !== 0) {\n    // See PR#453\n    throw new errors_1.SecurityError(\"Step 3 AES block size mismatch\");\n  }\n  const ige = new IGE_1.IGE(key, iv);\n  const plainTextAnswer = ige.decryptIge(serverDhParams.encryptedAnswer);\n  const reader = new extensions_1.BinaryReader(plainTextAnswer);\n  reader.read(20); // hash sum\n  const serverDhInner = reader.tgReadObject();\n  if (!(serverDhInner instanceof tl_1.Api.ServerDHInnerData)) {\n    throw new Error(`Step 3 answer was ${serverDhInner}`);\n  }\n  if (serverDhInner.nonce.neq(resPQ.nonce)) {\n    throw new errors_1.SecurityError(\"Step 3 Invalid nonce in encrypted answer\");\n  }\n  if (serverDhInner.serverNonce.neq(resPQ.serverNonce)) {\n    throw new errors_1.SecurityError(\"Step 3 Invalid server nonce in encrypted answer\");\n  }\n  const dhPrime = (0, Helpers_1.readBigIntFromBuffer)(serverDhInner.dhPrime, false, false);\n  const ga = (0, Helpers_1.readBigIntFromBuffer)(serverDhInner.gA, false, false);\n  const timeOffset = serverDhInner.serverTime - Math.floor(new Date().getTime() / 1000);\n  const b = (0, Helpers_1.readBigIntFromBuffer)((0, Helpers_1.generateRandomBytes)(256), false, false);\n  const gb = (0, Helpers_1.modExp)((0, big_integer_1.default)(serverDhInner.g), b, dhPrime);\n  const gab = (0, Helpers_1.modExp)(ga, b, dhPrime);\n  // Prepare client DH Inner Data\n  const clientDhInner = new tl_1.Api.ClientDHInnerData({\n    nonce: resPQ.nonce,\n    serverNonce: resPQ.serverNonce,\n    retryId: big_integer_1.default.zero,\n    // TODO Actual retry ID\n    gB: (0, Helpers_1.getByteArray)(gb, false)\n  }).getBytes();\n  const clientDdhInnerHashed = Buffer.concat([await (0, Helpers_1.sha1)(clientDhInner), clientDhInner]);\n  // Encryption\n  const clientDhEncrypted = ige.encryptIge(clientDdhInnerHashed);\n  const dhGen = await sender.send(new tl_1.Api.SetClientDHParams({\n    nonce: resPQ.nonce,\n    serverNonce: resPQ.serverNonce,\n    encryptedData: clientDhEncrypted\n  }));\n  const nonceTypes = [tl_1.Api.DhGenOk, tl_1.Api.DhGenRetry, tl_1.Api.DhGenFail];\n  // TS being weird again.\n  const nonceTypesString = [\"DhGenOk\", \"DhGenRetry\", \"DhGenFail\"];\n  if (!(dhGen instanceof nonceTypes[0] || dhGen instanceof nonceTypes[1] || dhGen instanceof nonceTypes[2])) {\n    throw new Error(`Step 3.1 answer was ${dhGen}`);\n  }\n  const {\n    name\n  } = dhGen.constructor;\n  if (dhGen.nonce.neq(resPQ.nonce)) {\n    throw new errors_1.SecurityError(`Step 3 invalid ${name} nonce from server`);\n  }\n  if (dhGen.serverNonce.neq(resPQ.serverNonce)) {\n    throw new errors_1.SecurityError(`Step 3 invalid ${name} server nonce from server`);\n  }\n  const authKey = new AuthKey_1.AuthKey();\n  await authKey.setKey((0, Helpers_1.getByteArray)(gab));\n  const nonceNumber = 1 + nonceTypesString.indexOf(dhGen.className);\n  const newNonceHash = await authKey.calcNewNonceHash(newNonce, nonceNumber);\n  // @ts-ignore\n  const dhHash = dhGen[`newNonceHash${nonceNumber}`];\n  if (dhHash.neq(newNonceHash)) {\n    throw new errors_1.SecurityError(\"Step 3 invalid new nonce hash\");\n  }\n  if (!(dhGen instanceof tl_1.Api.DhGenOk)) {\n    throw new Error(`Step 3.2 answer was ${dhGen}`);\n  }\n  log.debug(\"Finished authKey generation step 3\");\n  return {\n    authKey,\n    timeOffset\n  };\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}