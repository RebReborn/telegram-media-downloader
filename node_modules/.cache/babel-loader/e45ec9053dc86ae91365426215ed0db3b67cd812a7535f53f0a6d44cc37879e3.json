{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConnectionTCPAbridged = exports.AbridgedPacketCodec = void 0;\nconst Helpers_1 = require(\"../../Helpers\");\nconst Connection_1 = require(\"./Connection\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nclass AbridgedPacketCodec extends Connection_1.PacketCodec {\n  constructor(props) {\n    super(props);\n    this.tag = AbridgedPacketCodec.tag;\n    this.obfuscateTag = AbridgedPacketCodec.obfuscateTag;\n  }\n  encodePacket(data) {\n    let length = data.length >> 2;\n    let temp;\n    if (length < 127) {\n      const b = Buffer.alloc(1);\n      b.writeUInt8(length, 0);\n      temp = b;\n    } else {\n      temp = Buffer.concat([Buffer.from(\"7f\", \"hex\"), (0, Helpers_1.readBufferFromBigInt)((0, big_integer_1.default)(length), 3)]);\n    }\n    return Buffer.concat([temp, data]);\n  }\n  async readPacket(reader) {\n    const readData = await reader.read(1);\n    let length = readData[0];\n    if (length >= 127) {\n      length = Buffer.concat([await reader.read(3), Buffer.alloc(1)]).readInt32LE(0);\n    }\n    return reader.read(length << 2);\n  }\n}\nexports.AbridgedPacketCodec = AbridgedPacketCodec;\nAbridgedPacketCodec.tag = Buffer.from(\"ef\", \"hex\");\nAbridgedPacketCodec.obfuscateTag = Buffer.from(\"efefefef\", \"hex\");\n/**\n * This is the mode with the lowest overhead, as it will\n * only require 1 byte if the packet length is less than\n * 508 bytes (127 << 2, which is very common).\n */\nclass ConnectionTCPAbridged extends Connection_1.Connection {\n  constructor() {\n    super(...arguments);\n    this.PacketCodecClass = AbridgedPacketCodec;\n  }\n}\nexports.ConnectionTCPAbridged = ConnectionTCPAbridged;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}