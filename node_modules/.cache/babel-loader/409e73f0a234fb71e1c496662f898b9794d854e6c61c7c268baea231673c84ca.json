{"ast":null,"code":"\"use strict\";\n\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._IDsIter = exports._MessagesIter = void 0;\nexports.iterMessages = iterMessages;\nexports.getMessages = getMessages;\nexports.sendMessage = sendMessage;\nexports.forwardMessages = forwardMessages;\nexports.editMessage = editMessage;\nexports.deleteMessages = deleteMessages;\nexports.pinMessage = pinMessage;\nexports.unpinMessage = unpinMessage;\nexports._pin = _pin;\nexports.markAsRead = markAsRead;\nexports.getCommentData = getCommentData;\nconst tl_1 = require(\"../tl\");\nconst requestIter_1 = require(\"../requestIter\");\nconst Helpers_1 = require(\"../Helpers\");\nconst Utils_1 = require(\"../Utils\");\nconst __1 = require(\"../\");\nconst messageParse_1 = require(\"./messageParse\");\nconst users_1 = require(\"./users\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst uploads_1 = require(\"./uploads\");\nconst _MAX_CHUNK_SIZE = 100;\nclass _MessagesIter extends requestIter_1.RequestIter {\n  async _init({\n    entity,\n    offsetId,\n    minId,\n    maxId,\n    fromUser,\n    offsetDate,\n    addOffset,\n    filter,\n    search,\n    replyTo\n  }) {\n    var _a, e_1, _b, _c;\n    if (entity) {\n      this.entity = await this.client.getInputEntity(entity);\n    } else {\n      this.entity = undefined;\n      if (this.reverse) {\n        throw new Error(\"Cannot reverse global search\");\n      }\n    }\n    if (this.reverse) {\n      offsetId = Math.max(offsetId, minId);\n      if (offsetId && maxId) {\n        if (maxId - offsetId <= 1) {\n          return false;\n        }\n      }\n      if (!maxId) {\n        maxId = Number.MAX_SAFE_INTEGER;\n      }\n    } else {\n      offsetId = Math.max(offsetId, maxId);\n      if (offsetId && minId) {\n        if (offsetId - minId <= 1) {\n          return false;\n        }\n      }\n    }\n    if (this.reverse) {\n      if (offsetId) {\n        offsetId += 1;\n      } else if (!offsetDate) {\n        offsetId = 1;\n      }\n    }\n    if (fromUser) {\n      fromUser = await this.client.getInputEntity(fromUser);\n    }\n    if (!this.entity && fromUser) {\n      this.entity = new tl_1.Api.InputPeerEmpty();\n    }\n    if (!filter) {\n      filter = new tl_1.Api.InputMessagesFilterEmpty();\n    }\n    if (!this.entity) {\n      this.request = new tl_1.Api.messages.SearchGlobal({\n        q: search || \"\",\n        filter: filter,\n        minDate: undefined,\n        // TODO fix this smh\n        maxDate: offsetDate,\n        offsetRate: undefined,\n        offsetPeer: new tl_1.Api.InputPeerEmpty(),\n        offsetId: offsetId,\n        limit: 1\n      });\n    } else if (replyTo !== undefined) {\n      this.request = new tl_1.Api.messages.GetReplies({\n        peer: this.entity,\n        msgId: replyTo,\n        offsetId: offsetId,\n        offsetDate: offsetDate,\n        addOffset: addOffset,\n        limit: 0,\n        maxId: 0,\n        minId: 0,\n        hash: big_integer_1.default.zero\n      });\n    } else if (search !== undefined || !(filter instanceof tl_1.Api.InputMessagesFilterEmpty) || fromUser !== undefined) {\n      this.request = new tl_1.Api.messages.Search({\n        peer: this.entity,\n        q: search || \"\",\n        filter: typeof filter === \"function\" ? new filter() : filter,\n        minDate: undefined,\n        maxDate: offsetDate,\n        offsetId: offsetId,\n        addOffset: addOffset,\n        limit: 0,\n        maxId: 0,\n        minId: 0,\n        hash: (0, Helpers_1.generateRandomBigInt)(),\n        fromId: fromUser\n      });\n      if (!(filter instanceof tl_1.Api.InputMessagesFilterEmpty) && offsetDate && !search && !offsetId) {\n        try {\n          for (var _d = true, _e = __asyncValues(this.client.iterMessages(this.entity, {\n              limit: 1,\n              offsetDate: offsetDate\n            })), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {\n            _c = _f.value;\n            _d = false;\n            const m = _c;\n            this.request.offsetId = m.id + 1;\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      }\n    } else {\n      this.request = new tl_1.Api.messages.GetHistory({\n        peer: this.entity,\n        limit: 1,\n        offsetDate: offsetDate,\n        offsetId: offsetId,\n        minId: 0,\n        maxId: 0,\n        addOffset: addOffset,\n        hash: big_integer_1.default.zero\n      });\n    }\n    if (this.limit <= 0) {\n      const result = await this.client.invoke(this.request);\n      if (result instanceof tl_1.Api.messages.MessagesNotModified) {\n        this.total = result.count;\n      } else {\n        if (\"count\" in result) {\n          this.total = result.count;\n        } else {\n          this.total = result.messages.length;\n        }\n      }\n      return false;\n    }\n    if (!this.waitTime) {\n      this.waitTime = this.limit > 3000 ? 1 : 0;\n    }\n    if (this.reverse && !(this.request instanceof tl_1.Api.messages.SearchGlobal)) {\n      this.request.addOffset -= _MAX_CHUNK_SIZE;\n    }\n    this.addOffset = addOffset;\n    this.maxId = maxId;\n    this.minId = minId;\n    this.lastId = this.reverse ? 0 : Number.MAX_SAFE_INTEGER;\n  }\n  async _loadNextChunk() {\n    var _a;\n    if (!this.request) {\n      throw new Error(\"Request not set yet\");\n    }\n    this.request.limit = Math.min(this.left, _MAX_CHUNK_SIZE);\n    if (this.reverse && this.request.limit != _MAX_CHUNK_SIZE) {\n      if (!(this.request instanceof tl_1.Api.messages.SearchGlobal)) {\n        this.request.addOffset = this.addOffset - this.request.limit;\n      }\n    }\n    const r = await this.client.invoke(this.request);\n    if (r instanceof tl_1.Api.messages.MessagesNotModified) {\n      return true;\n    }\n    if (\"count\" in r) {\n      this.total = r.count;\n    } else {\n      this.total = r.messages.length;\n    }\n    const entities = new Map();\n    for (const x of [...r.users, ...r.chats]) {\n      entities.set((0, Utils_1.getPeerId)(x), x);\n    }\n    const messages = this.reverse ? r.messages.reverse() : r.messages;\n    for (const message of messages) {\n      if (!this._messageInRange(message)) {\n        return true;\n      }\n      this.lastId = message.id;\n      try {\n        // if this fails it shouldn't be a big problem\n        message._finishInit(this.client, entities, this.entity);\n      } catch (e) {}\n      message._entities = entities;\n      (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.push(message);\n    }\n    if (r.messages.length < this.request.limit) {\n      return true;\n    }\n    if (this.buffer) {\n      this._updateOffset(this.buffer[this.buffer.length - 1], r);\n    } else {\n      return true;\n    }\n  }\n  _messageInRange(message) {\n    if (this.entity) {\n      if (this.reverse) {\n        if (message.id <= this.lastId || message.id >= this.maxId) {\n          return false;\n        }\n      } else {\n        if (message.id >= this.lastId || message.id <= this.minId) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  [Symbol.asyncIterator]() {\n    return super[Symbol.asyncIterator]();\n  }\n  _updateOffset(lastMessage, response) {\n    if (!this.request) {\n      throw new Error(\"Request not set yet\");\n    }\n    this.request.offsetId = Number(lastMessage.id);\n    if (this.reverse) {\n      this.request.offsetId += 1;\n    }\n    if (this.request instanceof tl_1.Api.messages.Search) {\n      this.request.maxDate = -1;\n    } else {\n      if (!(this.request instanceof tl_1.Api.messages.SearchGlobal)) {\n        this.request.offsetDate = lastMessage.date;\n      }\n    }\n    if (this.request instanceof tl_1.Api.messages.SearchGlobal) {\n      if (lastMessage.inputChat) {\n        this.request.offsetPeer = lastMessage.inputChat;\n      } else {\n        this.request.offsetPeer = new tl_1.Api.InputPeerEmpty();\n      }\n      this.request.offsetRate = response.nextRate;\n    }\n  }\n}\nexports._MessagesIter = _MessagesIter;\nclass _IDsIter extends requestIter_1.RequestIter {\n  async _init({\n    entity,\n    ids\n  }) {\n    this.total = ids.length;\n    this._ids = this.reverse ? ids.reverse() : ids;\n    this._offset = 0;\n    this._entity = entity ? await this.client.getInputEntity(entity) : undefined;\n    this._ty = this._entity ? (0, Helpers_1._entityType)(this._entity) : undefined;\n    if (!this.waitTime) {\n      this.waitTime = this.limit > 300 ? 10 : 0;\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return super[Symbol.asyncIterator]();\n  }\n  async _loadNextChunk() {\n    var _a, _b, _c;\n    const ids = this._ids.slice(this._offset, this._offset + _MAX_CHUNK_SIZE);\n    if (!ids.length) {\n      return false;\n    }\n    this._offset += _MAX_CHUNK_SIZE;\n    let fromId;\n    let r;\n    if (this._ty == Helpers_1._EntityType.CHANNEL) {\n      try {\n        r = await this.client.invoke(new tl_1.Api.channels.GetMessages({\n          channel: this._entity,\n          id: ids\n        }));\n      } catch (e) {\n        if (e.errorMessage == \"MESSAGE_IDS_EMPTY\") {\n          r = new tl_1.Api.messages.MessagesNotModified({\n            count: ids.length\n          });\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      r = await this.client.invoke(new tl_1.Api.messages.GetMessages({\n        id: ids\n      }));\n      if (this._entity) {\n        fromId = await (0, users_1._getPeer)(this.client, this._entity);\n      }\n    }\n    if (r instanceof tl_1.Api.messages.MessagesNotModified) {\n      (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.push(...Array(ids.length));\n      return;\n    }\n    const entities = new Map();\n    for (const entity of [...r.users, ...r.chats]) {\n      entities.set(__1.utils.getPeerId(entity), entity);\n    }\n    let message;\n    for (message of r.messages) {\n      if (message instanceof tl_1.Api.MessageEmpty || fromId && __1.utils.getPeerId(message.peerId) != __1.utils.getPeerId(fromId)) {\n        (_b = this.buffer) === null || _b === void 0 ? void 0 : _b.push(undefined);\n      } else {\n        const temp = message;\n        temp._finishInit(this.client, entities, this._entity);\n        temp._entities = entities;\n        (_c = this.buffer) === null || _c === void 0 ? void 0 : _c.push(temp);\n      }\n    }\n  }\n}\nexports._IDsIter = _IDsIter;\nconst IterMessagesDefaults = {\n  limit: undefined,\n  offsetDate: undefined,\n  offsetId: 0,\n  maxId: 0,\n  minId: 0,\n  addOffset: 0,\n  search: undefined,\n  filter: undefined,\n  fromUser: undefined,\n  waitTime: undefined,\n  ids: undefined,\n  reverse: false,\n  replyTo: undefined,\n  scheduled: false\n};\n/** @hidden */\nfunction iterMessages(client, entity, options) {\n  const {\n    limit,\n    offsetDate,\n    offsetId,\n    maxId,\n    minId,\n    addOffset,\n    search,\n    filter,\n    fromUser,\n    waitTime,\n    ids,\n    reverse,\n    replyTo\n  } = Object.assign(Object.assign({}, IterMessagesDefaults), options);\n  if (ids) {\n    let idsArray;\n    if (!(0, Helpers_1.isArrayLike)(ids)) {\n      idsArray = [ids];\n    } else {\n      idsArray = ids;\n    }\n    return new _IDsIter(client, idsArray.length, {\n      reverse: reverse,\n      waitTime: waitTime\n    }, {\n      entity: entity,\n      ids: idsArray\n    });\n  }\n  return new _MessagesIter(client, limit, {\n    waitTime: waitTime,\n    reverse: reverse\n  }, {\n    entity: entity,\n    offsetId: offsetId,\n    minId: minId,\n    maxId: maxId,\n    fromUser: fromUser,\n    offsetDate: offsetDate,\n    addOffset: addOffset,\n    filter: filter,\n    search: search,\n    replyTo: replyTo\n  });\n}\n/** @hidden */\nasync function getMessages(client, entity, params) {\n  var _a, e_2, _b, _c;\n  if (Object.keys(params).length == 1 && params.limit === undefined) {\n    if (params.minId === undefined && params.maxId === undefined) {\n      params.limit = undefined;\n    } else {\n      params.limit = 1;\n    }\n  }\n  const it = client.iterMessages(entity, params);\n  const ids = params.ids;\n  if (ids && !(0, Helpers_1.isArrayLike)(ids)) {\n    try {\n      for (var _d = true, it_1 = __asyncValues(it), it_1_1; it_1_1 = await it_1.next(), _a = it_1_1.done, !_a; _d = true) {\n        _c = it_1_1.value;\n        _d = false;\n        const message = _c;\n        return [message];\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (!_d && !_a && (_b = it_1.return)) await _b.call(it_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return [];\n  }\n  return await it.collect();\n}\n// region Message\n/** @hidden */\nasync function sendMessage(client, /** To who will it be sent. */\nentity,\n/**  The message to be sent, or another message object to resend as a copy.<br/>\n * The maximum length for a message is 35,000 bytes or 4,096 characters.<br/>\n * Longer messages will not be sliced automatically, and you should slice them manually if the text to send is longer than said length. */\n{\n  message,\n  replyTo,\n  attributes,\n  parseMode,\n  formattingEntities,\n  linkPreview = true,\n  file,\n  thumb,\n  forceDocument,\n  clearDraft,\n  buttons,\n  silent,\n  supportStreaming,\n  schedule,\n  noforwards,\n  commentTo,\n  topMsgId\n} = {}) {\n  if (file) {\n    return client.sendFile(entity, {\n      file: file,\n      caption: message ? typeof message == \"string\" ? message : message.message : \"\",\n      forceDocument: forceDocument,\n      clearDraft: clearDraft,\n      replyTo: replyTo,\n      attributes: attributes,\n      thumb: thumb,\n      supportsStreaming: supportStreaming,\n      parseMode: parseMode,\n      formattingEntities: formattingEntities,\n      silent: silent,\n      scheduleDate: schedule,\n      buttons: buttons,\n      noforwards: noforwards,\n      commentTo: commentTo,\n      topMsgId: topMsgId\n    });\n  }\n  entity = await client.getInputEntity(entity);\n  if (commentTo != undefined) {\n    const discussionData = await getCommentData(client, entity, commentTo);\n    entity = discussionData.entity;\n    replyTo = discussionData.replyTo;\n  }\n  let markup, request;\n  let replyObject = undefined;\n  if (replyTo != undefined) {\n    replyObject = new tl_1.Api.InputReplyToMessage({\n      replyToMsgId: (0, Utils_1.getMessageId)(replyTo),\n      topMsgId: (0, Utils_1.getMessageId)(topMsgId)\n    });\n  }\n  if (message && message instanceof tl_1.Api.Message) {\n    if (buttons == undefined) {\n      markup = message.replyMarkup;\n    } else {\n      markup = client.buildReplyMarkup(buttons);\n    }\n    if (silent == undefined) {\n      silent = message.silent;\n    }\n    if (message.media && !(message.media instanceof tl_1.Api.MessageMediaWebPage)) {\n      return client.sendFile(entity, {\n        file: message.media,\n        caption: message.message,\n        silent: silent,\n        replyTo: replyTo,\n        buttons: markup,\n        formattingEntities: message.entities,\n        scheduleDate: schedule\n      });\n    }\n    request = new tl_1.Api.messages.SendMessage({\n      peer: entity,\n      message: message.message || \"\",\n      silent: silent,\n      replyTo: replyObject,\n      replyMarkup: markup,\n      entities: message.entities,\n      clearDraft: clearDraft,\n      noWebpage: !(message.media instanceof tl_1.Api.MessageMediaWebPage),\n      scheduleDate: schedule,\n      noforwards: noforwards\n    });\n    message = message.message;\n  } else {\n    if (formattingEntities == undefined) {\n      [message, formattingEntities] = await (0, messageParse_1._parseMessageText)(client, message || \"\", parseMode);\n    }\n    if (!message) {\n      throw new Error(\"The message cannot be empty unless a file is provided\");\n    }\n    request = new tl_1.Api.messages.SendMessage({\n      peer: entity,\n      message: message.toString(),\n      entities: formattingEntities,\n      noWebpage: !linkPreview,\n      replyTo: replyObject,\n      clearDraft: clearDraft,\n      silent: silent,\n      replyMarkup: client.buildReplyMarkup(buttons),\n      scheduleDate: schedule,\n      noforwards: noforwards\n    });\n  }\n  const result = await client.invoke(request);\n  if (result instanceof tl_1.Api.UpdateShortSentMessage) {\n    const msg = new tl_1.Api.Message({\n      id: result.id,\n      peerId: await (0, users_1._getPeer)(client, entity),\n      message: message,\n      date: result.date,\n      out: result.out,\n      media: result.media,\n      entities: result.entities,\n      replyMarkup: request.replyMarkup,\n      ttlPeriod: result.ttlPeriod\n    });\n    msg._finishInit(client, new Map(), entity);\n    return msg;\n  }\n  return client._getResponseMessage(request, result, entity);\n}\n/** @hidden */\nasync function forwardMessages(client, entity, {\n  messages,\n  fromPeer,\n  silent,\n  schedule,\n  noforwards,\n  dropAuthor\n}) {\n  if (!(0, Helpers_1.isArrayLike)(messages)) {\n    messages = [messages];\n  }\n  entity = await client.getInputEntity(entity);\n  let fromPeerId;\n  if (fromPeer) {\n    fromPeer = await client.getInputEntity(fromPeer);\n    fromPeerId = await client.getPeerId(fromPeer);\n  }\n  const getKey = m => {\n    if (m instanceof tl_1.Api.Message) {\n      return m.chatId;\n    }\n    let msgId = (0, Utils_1.parseID)(m);\n    if (msgId) {\n      if (fromPeerId !== undefined) {\n        return fromPeerId;\n      }\n      throw new Error(\"fromPeer must be given if integer IDs are used\");\n    } else {\n      throw new Error(`Cannot forward ${m}`);\n    }\n  };\n  const sent = [];\n  for (let [chatId, chunk] of (0, Helpers_1.groupBy)(messages, getKey)) {\n    let chat;\n    let numbers = [];\n    if (typeof chunk[0] == \"number\") {\n      chat = fromPeer;\n      numbers = chunk;\n    } else {\n      chat = await chunk[0].getInputChat();\n      numbers = chunk.map(m => m.id);\n    }\n    chunk.push();\n    const request = new tl_1.Api.messages.ForwardMessages({\n      fromPeer: chat,\n      id: numbers,\n      toPeer: entity,\n      silent: silent,\n      scheduleDate: schedule,\n      noforwards: noforwards,\n      dropAuthor: dropAuthor\n    });\n    const result = await client.invoke(request);\n    sent.push(client._getResponseMessage(request, result, entity));\n  }\n  return sent;\n}\n/** @hidden */\nasync function editMessage(client, entity, {\n  message,\n  text,\n  parseMode,\n  formattingEntities,\n  linkPreview = true,\n  file,\n  forceDocument,\n  buttons,\n  schedule\n}) {\n  if (typeof message === \"number\" && typeof text === \"undefined\" && !file && !schedule) {\n    throw Error(\"You have to provide either file or text or schedule property.\");\n  }\n  entity = await client.getInputEntity(entity);\n  let id;\n  let markup;\n  let entities;\n  let inputMedia;\n  if (file) {\n    const {\n      fileHandle,\n      media,\n      image\n    } = await (0, uploads_1._fileToMedia)(client, {\n      file,\n      forceDocument\n    });\n    inputMedia = media;\n  }\n  if (message instanceof tl_1.Api.Message) {\n    id = (0, Utils_1.getMessageId)(message);\n    text = message.message;\n    entities = message.entities;\n    if (buttons == undefined) {\n      markup = message.replyMarkup;\n    } else {\n      markup = client.buildReplyMarkup(buttons);\n    }\n    if (message.media) {\n      inputMedia = (0, Utils_1.getInputMedia)(message.media, {\n        forceDocument\n      });\n    }\n  } else {\n    if (typeof message !== \"number\") {\n      throw Error(\"editMessageParams.message must be either a number or a Api.Message type\");\n    }\n    id = message;\n    if (formattingEntities == undefined) {\n      [text, entities] = await (0, messageParse_1._parseMessageText)(client, text || \"\", parseMode);\n    } else {\n      entities = formattingEntities;\n    }\n    markup = client.buildReplyMarkup(buttons);\n  }\n  const request = new tl_1.Api.messages.EditMessage({\n    peer: entity,\n    id,\n    message: text,\n    noWebpage: !linkPreview,\n    entities,\n    media: inputMedia,\n    replyMarkup: markup,\n    scheduleDate: schedule\n  });\n  const result = await client.invoke(request);\n  return client._getResponseMessage(request, result, entity);\n}\n/** @hidden */\nasync function deleteMessages(client, entity, messageIds, {\n  revoke = false\n}) {\n  let ty = Helpers_1._EntityType.USER;\n  if (entity) {\n    entity = await client.getInputEntity(entity);\n    ty = (0, Helpers_1._entityType)(entity);\n  }\n  const ids = [];\n  for (const messageId of messageIds) {\n    if (messageId instanceof tl_1.Api.Message || messageId instanceof tl_1.Api.MessageService || messageId instanceof tl_1.Api.MessageEmpty) {\n      ids.push(messageId.id);\n    } else if (typeof messageId === \"number\") {\n      ids.push(messageId);\n    } else {\n      throw new Error(`Cannot convert ${messageId} to an integer`);\n    }\n  }\n  const results = [];\n  if (ty == Helpers_1._EntityType.CHANNEL) {\n    for (const chunk of __1.utils.chunks(ids)) {\n      results.push(client.invoke(new tl_1.Api.channels.DeleteMessages({\n        channel: entity,\n        id: chunk\n      })));\n    }\n  } else {\n    for (const chunk of __1.utils.chunks(ids)) {\n      results.push(client.invoke(new tl_1.Api.messages.DeleteMessages({\n        id: chunk,\n        revoke: revoke\n      })));\n    }\n  }\n  return Promise.all(results);\n}\n/** @hidden */\nasync function pinMessage(client, entity, message, pinMessageParams) {\n  return await _pin(client, entity, message, false, pinMessageParams === null || pinMessageParams === void 0 ? void 0 : pinMessageParams.notify, pinMessageParams === null || pinMessageParams === void 0 ? void 0 : pinMessageParams.pmOneSide);\n}\n/** @hidden */\nasync function unpinMessage(client, entity, message, unpinMessageParams) {\n  return await _pin(client, entity, message, true, unpinMessageParams === null || unpinMessageParams === void 0 ? void 0 : unpinMessageParams.notify, unpinMessageParams === null || unpinMessageParams === void 0 ? void 0 : unpinMessageParams.pmOneSide);\n}\n/** @hidden */\nasync function _pin(client, entity, message, unpin, notify = false, pmOneSide = false) {\n  message = __1.utils.getMessageId(message) || 0;\n  if (message === 0) {\n    return await client.invoke(new tl_1.Api.messages.UnpinAllMessages({\n      peer: entity\n    }));\n  }\n  entity = await client.getInputEntity(entity);\n  const request = new tl_1.Api.messages.UpdatePinnedMessage({\n    silent: !notify,\n    unpin,\n    pmOneside: pmOneSide,\n    peer: entity,\n    id: message\n  });\n  const result = await client.invoke(request);\n  /**\n   * Unpinning does not produce a service message.\n   * Pinning a message that was already pinned also produces no service message.\n   * Pinning a message in your own chat does not produce a service message,\n   * but pinning on a private conversation with someone else does.\n   */\n  if (unpin || !(\"updates\" in result) || \"updates\" in result && !result.updates) {\n    return;\n  }\n  // Pinning a message that doesn't exist would RPC-error earlier\n  return client._getResponseMessage(request, result, entity);\n}\n/** @hidden */\nasync function markAsRead(client, entity, message, markAsReadParams) {\n  let maxId = (markAsReadParams === null || markAsReadParams === void 0 ? void 0 : markAsReadParams.maxId) || 0;\n  const maxIdIsUndefined = (markAsReadParams === null || markAsReadParams === void 0 ? void 0 : markAsReadParams.maxId) === undefined;\n  if (maxIdIsUndefined) {\n    if (message) {\n      if (Array.isArray(message)) {\n        maxId = Math.max(...message.map(v => __1.utils.getMessageId(v)));\n      } else {\n        maxId = __1.utils.getMessageId(message);\n      }\n    }\n  }\n  entity = await client.getInputEntity(entity);\n  if (markAsReadParams && !markAsReadParams.clearMentions) {\n    await client.invoke(new tl_1.Api.messages.ReadMentions({\n      peer: entity\n    }));\n    if (maxIdIsUndefined && message === undefined) {\n      return true;\n    }\n  }\n  if ((0, Helpers_1._entityType)(entity) === Helpers_1._EntityType.CHANNEL) {\n    return await client.invoke(new tl_1.Api.channels.ReadHistory({\n      channel: entity,\n      maxId\n    }));\n  } else {\n    await client.invoke(new tl_1.Api.messages.ReadHistory({\n      peer: entity,\n      maxId\n    }));\n    return true;\n  }\n}\n/** @hidden */\nasync function getCommentData(client, entity, message) {\n  const result = await client.invoke(new tl_1.Api.messages.GetDiscussionMessage({\n    peer: entity,\n    msgId: __1.utils.getMessageId(message)\n  }));\n  const relevantMessage = result.messages.reduce((p, c) => p && p.id < c.id ? p : c);\n  let chat;\n  for (const c of result.chats) {\n    if (relevantMessage.peerId instanceof tl_1.Api.PeerChannel && c.id.eq(relevantMessage.peerId.channelId)) {\n      chat = c;\n      break;\n    }\n  }\n  return {\n    entity: __1.utils.getInputPeer(chat),\n    replyTo: relevantMessage.id\n  };\n}\n// TODO do the rest","map":{"version":3,"names":["__asyncValues","o","Symbol","asyncIterator","TypeError","m","i","call","__values","iterator","verb","n","v","Promise","resolve","reject","settle","done","value","d","then","__importDefault","mod","__esModule","Object","defineProperty","exports","_IDsIter","_MessagesIter","iterMessages","getMessages","sendMessage","forwardMessages","editMessage","deleteMessages","pinMessage","unpinMessage","_pin","markAsRead","getCommentData","tl_1","require","requestIter_1","Helpers_1","Utils_1","__1","messageParse_1","users_1","big_integer_1","uploads_1","_MAX_CHUNK_SIZE","RequestIter","_init","entity","offsetId","minId","maxId","fromUser","offsetDate","addOffset","filter","search","replyTo","_a","e_1","_b","_c","client","getInputEntity","undefined","reverse","Error","Math","max","Number","MAX_SAFE_INTEGER","Api","InputPeerEmpty","InputMessagesFilterEmpty","request","messages","SearchGlobal","q","minDate","maxDate","offsetRate","offsetPeer","limit","GetReplies","peer","msgId","hash","default","zero","Search","generateRandomBigInt","fromId","_d","_e","_f","next","id","e_1_1","error","return","GetHistory","result","invoke","MessagesNotModified","total","count","length","waitTime","lastId","_loadNextChunk","min","left","r","entities","Map","x","users","chats","set","getPeerId","message","_messageInRange","_finishInit","e","_entities","buffer","push","_updateOffset","lastMessage","response","date","inputChat","nextRate","ids","_ids","_offset","_entity","_ty","_entityType","slice","_EntityType","CHANNEL","channels","GetMessages","channel","errorMessage","_getPeer","Array","utils","MessageEmpty","peerId","temp","IterMessagesDefaults","scheduled","options","assign","idsArray","isArrayLike","params","e_2","keys","it","it_1","it_1_1","e_2_1","collect","attributes","parseMode","formattingEntities","linkPreview","file","thumb","forceDocument","clearDraft","buttons","silent","supportStreaming","schedule","noforwards","commentTo","topMsgId","sendFile","caption","supportsStreaming","scheduleDate","discussionData","markup","replyObject","InputReplyToMessage","replyToMsgId","getMessageId","Message","replyMarkup","buildReplyMarkup","media","MessageMediaWebPage","SendMessage","noWebpage","_parseMessageText","toString","UpdateShortSentMessage","msg","out","ttlPeriod","_getResponseMessage","fromPeer","dropAuthor","fromPeerId","getKey","chatId","parseID","sent","chunk","groupBy","chat","numbers","getInputChat","map","ForwardMessages","toPeer","text","inputMedia","fileHandle","image","_fileToMedia","getInputMedia","EditMessage","messageIds","revoke","ty","USER","messageId","MessageService","results","chunks","DeleteMessages","all","pinMessageParams","notify","pmOneSide","unpinMessageParams","unpin","UnpinAllMessages","UpdatePinnedMessage","pmOneside","updates","markAsReadParams","maxIdIsUndefined","isArray","clearMentions","ReadMentions","ReadHistory","GetDiscussionMessage","relevantMessage","reduce","p","c","PeerChannel","eq","channelId","getInputPeer"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/client/messages.js"],"sourcesContent":["\"use strict\";\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._IDsIter = exports._MessagesIter = void 0;\nexports.iterMessages = iterMessages;\nexports.getMessages = getMessages;\nexports.sendMessage = sendMessage;\nexports.forwardMessages = forwardMessages;\nexports.editMessage = editMessage;\nexports.deleteMessages = deleteMessages;\nexports.pinMessage = pinMessage;\nexports.unpinMessage = unpinMessage;\nexports._pin = _pin;\nexports.markAsRead = markAsRead;\nexports.getCommentData = getCommentData;\nconst tl_1 = require(\"../tl\");\nconst requestIter_1 = require(\"../requestIter\");\nconst Helpers_1 = require(\"../Helpers\");\nconst Utils_1 = require(\"../Utils\");\nconst __1 = require(\"../\");\nconst messageParse_1 = require(\"./messageParse\");\nconst users_1 = require(\"./users\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst uploads_1 = require(\"./uploads\");\nconst _MAX_CHUNK_SIZE = 100;\nclass _MessagesIter extends requestIter_1.RequestIter {\n    async _init({ entity, offsetId, minId, maxId, fromUser, offsetDate, addOffset, filter, search, replyTo, }) {\n        var _a, e_1, _b, _c;\n        if (entity) {\n            this.entity = await this.client.getInputEntity(entity);\n        }\n        else {\n            this.entity = undefined;\n            if (this.reverse) {\n                throw new Error(\"Cannot reverse global search\");\n            }\n        }\n        if (this.reverse) {\n            offsetId = Math.max(offsetId, minId);\n            if (offsetId && maxId) {\n                if (maxId - offsetId <= 1) {\n                    return false;\n                }\n            }\n            if (!maxId) {\n                maxId = Number.MAX_SAFE_INTEGER;\n            }\n        }\n        else {\n            offsetId = Math.max(offsetId, maxId);\n            if (offsetId && minId) {\n                if (offsetId - minId <= 1) {\n                    return false;\n                }\n            }\n        }\n        if (this.reverse) {\n            if (offsetId) {\n                offsetId += 1;\n            }\n            else if (!offsetDate) {\n                offsetId = 1;\n            }\n        }\n        if (fromUser) {\n            fromUser = await this.client.getInputEntity(fromUser);\n        }\n        if (!this.entity && fromUser) {\n            this.entity = new tl_1.Api.InputPeerEmpty();\n        }\n        if (!filter) {\n            filter = new tl_1.Api.InputMessagesFilterEmpty();\n        }\n        if (!this.entity) {\n            this.request = new tl_1.Api.messages.SearchGlobal({\n                q: search || \"\",\n                filter: filter,\n                minDate: undefined,\n                // TODO fix this smh\n                maxDate: offsetDate,\n                offsetRate: undefined,\n                offsetPeer: new tl_1.Api.InputPeerEmpty(),\n                offsetId: offsetId,\n                limit: 1,\n            });\n        }\n        else if (replyTo !== undefined) {\n            this.request = new tl_1.Api.messages.GetReplies({\n                peer: this.entity,\n                msgId: replyTo,\n                offsetId: offsetId,\n                offsetDate: offsetDate,\n                addOffset: addOffset,\n                limit: 0,\n                maxId: 0,\n                minId: 0,\n                hash: big_integer_1.default.zero,\n            });\n        }\n        else if (search !== undefined ||\n            !(filter instanceof tl_1.Api.InputMessagesFilterEmpty) ||\n            fromUser !== undefined) {\n            this.request = new tl_1.Api.messages.Search({\n                peer: this.entity,\n                q: search || \"\",\n                filter: typeof filter === \"function\" ? new filter() : filter,\n                minDate: undefined,\n                maxDate: offsetDate,\n                offsetId: offsetId,\n                addOffset: addOffset,\n                limit: 0,\n                maxId: 0,\n                minId: 0,\n                hash: (0, Helpers_1.generateRandomBigInt)(),\n                fromId: fromUser,\n            });\n            if (!(filter instanceof tl_1.Api.InputMessagesFilterEmpty) &&\n                offsetDate &&\n                !search &&\n                !offsetId) {\n                try {\n                    for (var _d = true, _e = __asyncValues(this.client.iterMessages(this.entity, {\n                        limit: 1,\n                        offsetDate: offsetDate,\n                    })), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {\n                        _c = _f.value;\n                        _d = false;\n                        const m = _c;\n                        this.request.offsetId = m.id + 1;\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n        }\n        else {\n            this.request = new tl_1.Api.messages.GetHistory({\n                peer: this.entity,\n                limit: 1,\n                offsetDate: offsetDate,\n                offsetId: offsetId,\n                minId: 0,\n                maxId: 0,\n                addOffset: addOffset,\n                hash: big_integer_1.default.zero,\n            });\n        }\n        if (this.limit <= 0) {\n            const result = await this.client.invoke(this.request);\n            if (result instanceof tl_1.Api.messages.MessagesNotModified) {\n                this.total = result.count;\n            }\n            else {\n                if (\"count\" in result) {\n                    this.total = result.count;\n                }\n                else {\n                    this.total = result.messages.length;\n                }\n            }\n            return false;\n        }\n        if (!this.waitTime) {\n            this.waitTime = this.limit > 3000 ? 1 : 0;\n        }\n        if (this.reverse &&\n            !(this.request instanceof tl_1.Api.messages.SearchGlobal)) {\n            this.request.addOffset -= _MAX_CHUNK_SIZE;\n        }\n        this.addOffset = addOffset;\n        this.maxId = maxId;\n        this.minId = minId;\n        this.lastId = this.reverse ? 0 : Number.MAX_SAFE_INTEGER;\n    }\n    async _loadNextChunk() {\n        var _a;\n        if (!this.request) {\n            throw new Error(\"Request not set yet\");\n        }\n        this.request.limit = Math.min(this.left, _MAX_CHUNK_SIZE);\n        if (this.reverse && this.request.limit != _MAX_CHUNK_SIZE) {\n            if (!(this.request instanceof tl_1.Api.messages.SearchGlobal)) {\n                this.request.addOffset = this.addOffset - this.request.limit;\n            }\n        }\n        const r = await this.client.invoke(this.request);\n        if (r instanceof tl_1.Api.messages.MessagesNotModified) {\n            return true;\n        }\n        if (\"count\" in r) {\n            this.total = r.count;\n        }\n        else {\n            this.total = r.messages.length;\n        }\n        const entities = new Map();\n        for (const x of [...r.users, ...r.chats]) {\n            entities.set((0, Utils_1.getPeerId)(x), x);\n        }\n        const messages = this.reverse\n            ? r.messages.reverse()\n            : r.messages;\n        for (const message of messages) {\n            if (!this._messageInRange(message)) {\n                return true;\n            }\n            this.lastId = message.id;\n            try {\n                // if this fails it shouldn't be a big problem\n                message._finishInit(this.client, entities, this.entity);\n            }\n            catch (e) { }\n            message._entities = entities;\n            (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.push(message);\n        }\n        if (r.messages.length < this.request.limit) {\n            return true;\n        }\n        if (this.buffer) {\n            this._updateOffset(this.buffer[this.buffer.length - 1], r);\n        }\n        else {\n            return true;\n        }\n    }\n    _messageInRange(message) {\n        if (this.entity) {\n            if (this.reverse) {\n                if (message.id <= this.lastId || message.id >= this.maxId) {\n                    return false;\n                }\n            }\n            else {\n                if (message.id >= this.lastId || message.id <= this.minId) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    [Symbol.asyncIterator]() {\n        return super[Symbol.asyncIterator]();\n    }\n    _updateOffset(lastMessage, response) {\n        if (!this.request) {\n            throw new Error(\"Request not set yet\");\n        }\n        this.request.offsetId = Number(lastMessage.id);\n        if (this.reverse) {\n            this.request.offsetId += 1;\n        }\n        if (this.request instanceof tl_1.Api.messages.Search) {\n            this.request.maxDate = -1;\n        }\n        else {\n            if (!(this.request instanceof tl_1.Api.messages.SearchGlobal)) {\n                this.request.offsetDate = lastMessage.date;\n            }\n        }\n        if (this.request instanceof tl_1.Api.messages.SearchGlobal) {\n            if (lastMessage.inputChat) {\n                this.request.offsetPeer = lastMessage.inputChat;\n            }\n            else {\n                this.request.offsetPeer = new tl_1.Api.InputPeerEmpty();\n            }\n            this.request.offsetRate = response.nextRate;\n        }\n    }\n}\nexports._MessagesIter = _MessagesIter;\nclass _IDsIter extends requestIter_1.RequestIter {\n    async _init({ entity, ids }) {\n        this.total = ids.length;\n        this._ids = this.reverse ? ids.reverse() : ids;\n        this._offset = 0;\n        this._entity = entity\n            ? await this.client.getInputEntity(entity)\n            : undefined;\n        this._ty = this._entity ? (0, Helpers_1._entityType)(this._entity) : undefined;\n        if (!this.waitTime) {\n            this.waitTime = this.limit > 300 ? 10 : 0;\n        }\n    }\n    [Symbol.asyncIterator]() {\n        return super[Symbol.asyncIterator]();\n    }\n    async _loadNextChunk() {\n        var _a, _b, _c;\n        const ids = this._ids.slice(this._offset, this._offset + _MAX_CHUNK_SIZE);\n        if (!ids.length) {\n            return false;\n        }\n        this._offset += _MAX_CHUNK_SIZE;\n        let fromId;\n        let r;\n        if (this._ty == Helpers_1._EntityType.CHANNEL) {\n            try {\n                r = await this.client.invoke(new tl_1.Api.channels.GetMessages({\n                    channel: this._entity,\n                    id: ids,\n                }));\n            }\n            catch (e) {\n                if (e.errorMessage == \"MESSAGE_IDS_EMPTY\") {\n                    r = new tl_1.Api.messages.MessagesNotModified({\n                        count: ids.length,\n                    });\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        else {\n            r = await this.client.invoke(new tl_1.Api.messages.GetMessages({\n                id: ids,\n            }));\n            if (this._entity) {\n                fromId = await (0, users_1._getPeer)(this.client, this._entity);\n            }\n        }\n        if (r instanceof tl_1.Api.messages.MessagesNotModified) {\n            (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.push(...Array(ids.length));\n            return;\n        }\n        const entities = new Map();\n        for (const entity of [...r.users, ...r.chats]) {\n            entities.set(__1.utils.getPeerId(entity), entity);\n        }\n        let message;\n        for (message of r.messages) {\n            if (message instanceof tl_1.Api.MessageEmpty ||\n                (fromId &&\n                    __1.utils.getPeerId(message.peerId) != __1.utils.getPeerId(fromId))) {\n                (_b = this.buffer) === null || _b === void 0 ? void 0 : _b.push(undefined);\n            }\n            else {\n                const temp = message;\n                temp._finishInit(this.client, entities, this._entity);\n                temp._entities = entities;\n                (_c = this.buffer) === null || _c === void 0 ? void 0 : _c.push(temp);\n            }\n        }\n    }\n}\nexports._IDsIter = _IDsIter;\nconst IterMessagesDefaults = {\n    limit: undefined,\n    offsetDate: undefined,\n    offsetId: 0,\n    maxId: 0,\n    minId: 0,\n    addOffset: 0,\n    search: undefined,\n    filter: undefined,\n    fromUser: undefined,\n    waitTime: undefined,\n    ids: undefined,\n    reverse: false,\n    replyTo: undefined,\n    scheduled: false,\n};\n/** @hidden */\nfunction iterMessages(client, entity, options) {\n    const { limit, offsetDate, offsetId, maxId, minId, addOffset, search, filter, fromUser, waitTime, ids, reverse, replyTo, } = Object.assign(Object.assign({}, IterMessagesDefaults), options);\n    if (ids) {\n        let idsArray;\n        if (!(0, Helpers_1.isArrayLike)(ids)) {\n            idsArray = [ids];\n        }\n        else {\n            idsArray = ids;\n        }\n        return new _IDsIter(client, idsArray.length, {\n            reverse: reverse,\n            waitTime: waitTime,\n        }, {\n            entity: entity,\n            ids: idsArray,\n        });\n    }\n    return new _MessagesIter(client, limit, {\n        waitTime: waitTime,\n        reverse: reverse,\n    }, {\n        entity: entity,\n        offsetId: offsetId,\n        minId: minId,\n        maxId: maxId,\n        fromUser: fromUser,\n        offsetDate: offsetDate,\n        addOffset: addOffset,\n        filter: filter,\n        search: search,\n        replyTo: replyTo,\n    });\n}\n/** @hidden */\nasync function getMessages(client, entity, params) {\n    var _a, e_2, _b, _c;\n    if (Object.keys(params).length == 1 && params.limit === undefined) {\n        if (params.minId === undefined && params.maxId === undefined) {\n            params.limit = undefined;\n        }\n        else {\n            params.limit = 1;\n        }\n    }\n    const it = client.iterMessages(entity, params);\n    const ids = params.ids;\n    if (ids && !(0, Helpers_1.isArrayLike)(ids)) {\n        try {\n            for (var _d = true, it_1 = __asyncValues(it), it_1_1; it_1_1 = await it_1.next(), _a = it_1_1.done, !_a; _d = true) {\n                _c = it_1_1.value;\n                _d = false;\n                const message = _c;\n                return [message];\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (!_d && !_a && (_b = it_1.return)) await _b.call(it_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return [];\n    }\n    return (await it.collect());\n}\n// region Message\n/** @hidden */\nasync function sendMessage(client, \n/** To who will it be sent. */\nentity, \n/**  The message to be sent, or another message object to resend as a copy.<br/>\n * The maximum length for a message is 35,000 bytes or 4,096 characters.<br/>\n * Longer messages will not be sliced automatically, and you should slice them manually if the text to send is longer than said length. */\n{ message, replyTo, attributes, parseMode, formattingEntities, linkPreview = true, file, thumb, forceDocument, clearDraft, buttons, silent, supportStreaming, schedule, noforwards, commentTo, topMsgId, } = {}) {\n    if (file) {\n        return client.sendFile(entity, {\n            file: file,\n            caption: message\n                ? typeof message == \"string\"\n                    ? message\n                    : message.message\n                : \"\",\n            forceDocument: forceDocument,\n            clearDraft: clearDraft,\n            replyTo: replyTo,\n            attributes: attributes,\n            thumb: thumb,\n            supportsStreaming: supportStreaming,\n            parseMode: parseMode,\n            formattingEntities: formattingEntities,\n            silent: silent,\n            scheduleDate: schedule,\n            buttons: buttons,\n            noforwards: noforwards,\n            commentTo: commentTo,\n            topMsgId: topMsgId,\n        });\n    }\n    entity = await client.getInputEntity(entity);\n    if (commentTo != undefined) {\n        const discussionData = await getCommentData(client, entity, commentTo);\n        entity = discussionData.entity;\n        replyTo = discussionData.replyTo;\n    }\n    let markup, request;\n    let replyObject = undefined;\n    if (replyTo != undefined) {\n        replyObject = new tl_1.Api.InputReplyToMessage({\n            replyToMsgId: (0, Utils_1.getMessageId)(replyTo),\n            topMsgId: (0, Utils_1.getMessageId)(topMsgId),\n        });\n    }\n    if (message && message instanceof tl_1.Api.Message) {\n        if (buttons == undefined) {\n            markup = message.replyMarkup;\n        }\n        else {\n            markup = client.buildReplyMarkup(buttons);\n        }\n        if (silent == undefined) {\n            silent = message.silent;\n        }\n        if (message.media &&\n            !(message.media instanceof tl_1.Api.MessageMediaWebPage)) {\n            return client.sendFile(entity, {\n                file: message.media,\n                caption: message.message,\n                silent: silent,\n                replyTo: replyTo,\n                buttons: markup,\n                formattingEntities: message.entities,\n                scheduleDate: schedule,\n            });\n        }\n        request = new tl_1.Api.messages.SendMessage({\n            peer: entity,\n            message: message.message || \"\",\n            silent: silent,\n            replyTo: replyObject,\n            replyMarkup: markup,\n            entities: message.entities,\n            clearDraft: clearDraft,\n            noWebpage: !(message.media instanceof tl_1.Api.MessageMediaWebPage),\n            scheduleDate: schedule,\n            noforwards: noforwards,\n        });\n        message = message.message;\n    }\n    else {\n        if (formattingEntities == undefined) {\n            [message, formattingEntities] = await (0, messageParse_1._parseMessageText)(client, message || \"\", parseMode);\n        }\n        if (!message) {\n            throw new Error(\"The message cannot be empty unless a file is provided\");\n        }\n        request = new tl_1.Api.messages.SendMessage({\n            peer: entity,\n            message: message.toString(),\n            entities: formattingEntities,\n            noWebpage: !linkPreview,\n            replyTo: replyObject,\n            clearDraft: clearDraft,\n            silent: silent,\n            replyMarkup: client.buildReplyMarkup(buttons),\n            scheduleDate: schedule,\n            noforwards: noforwards,\n        });\n    }\n    const result = await client.invoke(request);\n    if (result instanceof tl_1.Api.UpdateShortSentMessage) {\n        const msg = new tl_1.Api.Message({\n            id: result.id,\n            peerId: await (0, users_1._getPeer)(client, entity),\n            message: message,\n            date: result.date,\n            out: result.out,\n            media: result.media,\n            entities: result.entities,\n            replyMarkup: request.replyMarkup,\n            ttlPeriod: result.ttlPeriod,\n        });\n        msg._finishInit(client, new Map(), entity);\n        return msg;\n    }\n    return client._getResponseMessage(request, result, entity);\n}\n/** @hidden */\nasync function forwardMessages(client, entity, { messages, fromPeer, silent, schedule, noforwards, dropAuthor, }) {\n    if (!(0, Helpers_1.isArrayLike)(messages)) {\n        messages = [messages];\n    }\n    entity = await client.getInputEntity(entity);\n    let fromPeerId;\n    if (fromPeer) {\n        fromPeer = await client.getInputEntity(fromPeer);\n        fromPeerId = await client.getPeerId(fromPeer);\n    }\n    const getKey = (m) => {\n        if (m instanceof tl_1.Api.Message) {\n            return m.chatId;\n        }\n        let msgId = (0, Utils_1.parseID)(m);\n        if (msgId) {\n            if (fromPeerId !== undefined) {\n                return fromPeerId;\n            }\n            throw new Error(\"fromPeer must be given if integer IDs are used\");\n        }\n        else {\n            throw new Error(`Cannot forward ${m}`);\n        }\n    };\n    const sent = [];\n    for (let [chatId, chunk] of (0, Helpers_1.groupBy)(messages, getKey)) {\n        let chat;\n        let numbers = [];\n        if (typeof chunk[0] == \"number\") {\n            chat = fromPeer;\n            numbers = chunk;\n        }\n        else {\n            chat = await chunk[0].getInputChat();\n            numbers = chunk.map((m) => m.id);\n        }\n        chunk.push();\n        const request = new tl_1.Api.messages.ForwardMessages({\n            fromPeer: chat,\n            id: numbers,\n            toPeer: entity,\n            silent: silent,\n            scheduleDate: schedule,\n            noforwards: noforwards,\n            dropAuthor: dropAuthor,\n        });\n        const result = await client.invoke(request);\n        sent.push(client._getResponseMessage(request, result, entity));\n    }\n    return sent;\n}\n/** @hidden */\nasync function editMessage(client, entity, { message, text, parseMode, formattingEntities, linkPreview = true, file, forceDocument, buttons, schedule, }) {\n    if (typeof message === \"number\" &&\n        typeof text === \"undefined\" &&\n        !file &&\n        !schedule) {\n        throw Error(\"You have to provide either file or text or schedule property.\");\n    }\n    entity = await client.getInputEntity(entity);\n    let id;\n    let markup;\n    let entities;\n    let inputMedia;\n    if (file) {\n        const { fileHandle, media, image } = await (0, uploads_1._fileToMedia)(client, {\n            file,\n            forceDocument,\n        });\n        inputMedia = media;\n    }\n    if (message instanceof tl_1.Api.Message) {\n        id = (0, Utils_1.getMessageId)(message);\n        text = message.message;\n        entities = message.entities;\n        if (buttons == undefined) {\n            markup = message.replyMarkup;\n        }\n        else {\n            markup = client.buildReplyMarkup(buttons);\n        }\n        if (message.media) {\n            inputMedia = (0, Utils_1.getInputMedia)(message.media, { forceDocument });\n        }\n    }\n    else {\n        if (typeof message !== \"number\") {\n            throw Error(\"editMessageParams.message must be either a number or a Api.Message type\");\n        }\n        id = message;\n        if (formattingEntities == undefined) {\n            [text, entities] = await (0, messageParse_1._parseMessageText)(client, text || \"\", parseMode);\n        }\n        else {\n            entities = formattingEntities;\n        }\n        markup = client.buildReplyMarkup(buttons);\n    }\n    const request = new tl_1.Api.messages.EditMessage({\n        peer: entity,\n        id,\n        message: text,\n        noWebpage: !linkPreview,\n        entities,\n        media: inputMedia,\n        replyMarkup: markup,\n        scheduleDate: schedule,\n    });\n    const result = await client.invoke(request);\n    return client._getResponseMessage(request, result, entity);\n}\n/** @hidden */\nasync function deleteMessages(client, entity, messageIds, { revoke = false }) {\n    let ty = Helpers_1._EntityType.USER;\n    if (entity) {\n        entity = await client.getInputEntity(entity);\n        ty = (0, Helpers_1._entityType)(entity);\n    }\n    const ids = [];\n    for (const messageId of messageIds) {\n        if (messageId instanceof tl_1.Api.Message ||\n            messageId instanceof tl_1.Api.MessageService ||\n            messageId instanceof tl_1.Api.MessageEmpty) {\n            ids.push(messageId.id);\n        }\n        else if (typeof messageId === \"number\") {\n            ids.push(messageId);\n        }\n        else {\n            throw new Error(`Cannot convert ${messageId} to an integer`);\n        }\n    }\n    const results = [];\n    if (ty == Helpers_1._EntityType.CHANNEL) {\n        for (const chunk of __1.utils.chunks(ids)) {\n            results.push(client.invoke(new tl_1.Api.channels.DeleteMessages({\n                channel: entity,\n                id: chunk,\n            })));\n        }\n    }\n    else {\n        for (const chunk of __1.utils.chunks(ids)) {\n            results.push(client.invoke(new tl_1.Api.messages.DeleteMessages({\n                id: chunk,\n                revoke: revoke,\n            })));\n        }\n    }\n    return Promise.all(results);\n}\n/** @hidden */\nasync function pinMessage(client, entity, message, pinMessageParams) {\n    return await _pin(client, entity, message, false, pinMessageParams === null || pinMessageParams === void 0 ? void 0 : pinMessageParams.notify, pinMessageParams === null || pinMessageParams === void 0 ? void 0 : pinMessageParams.pmOneSide);\n}\n/** @hidden */\nasync function unpinMessage(client, entity, message, unpinMessageParams) {\n    return await _pin(client, entity, message, true, unpinMessageParams === null || unpinMessageParams === void 0 ? void 0 : unpinMessageParams.notify, unpinMessageParams === null || unpinMessageParams === void 0 ? void 0 : unpinMessageParams.pmOneSide);\n}\n/** @hidden */\nasync function _pin(client, entity, message, unpin, notify = false, pmOneSide = false) {\n    message = __1.utils.getMessageId(message) || 0;\n    if (message === 0) {\n        return await client.invoke(new tl_1.Api.messages.UnpinAllMessages({\n            peer: entity,\n        }));\n    }\n    entity = await client.getInputEntity(entity);\n    const request = new tl_1.Api.messages.UpdatePinnedMessage({\n        silent: !notify,\n        unpin,\n        pmOneside: pmOneSide,\n        peer: entity,\n        id: message,\n    });\n    const result = await client.invoke(request);\n    /**\n     * Unpinning does not produce a service message.\n     * Pinning a message that was already pinned also produces no service message.\n     * Pinning a message in your own chat does not produce a service message,\n     * but pinning on a private conversation with someone else does.\n     */\n    if (unpin ||\n        !(\"updates\" in result) ||\n        (\"updates\" in result && !result.updates)) {\n        return;\n    }\n    // Pinning a message that doesn't exist would RPC-error earlier\n    return client._getResponseMessage(request, result, entity);\n}\n/** @hidden */\nasync function markAsRead(client, entity, message, markAsReadParams) {\n    let maxId = (markAsReadParams === null || markAsReadParams === void 0 ? void 0 : markAsReadParams.maxId) || 0;\n    const maxIdIsUndefined = (markAsReadParams === null || markAsReadParams === void 0 ? void 0 : markAsReadParams.maxId) === undefined;\n    if (maxIdIsUndefined) {\n        if (message) {\n            if (Array.isArray(message)) {\n                maxId = Math.max(...message.map((v) => __1.utils.getMessageId(v)));\n            }\n            else {\n                maxId = __1.utils.getMessageId(message);\n            }\n        }\n    }\n    entity = await client.getInputEntity(entity);\n    if (markAsReadParams && !markAsReadParams.clearMentions) {\n        await client.invoke(new tl_1.Api.messages.ReadMentions({ peer: entity }));\n        if (maxIdIsUndefined && message === undefined) {\n            return true;\n        }\n    }\n    if ((0, Helpers_1._entityType)(entity) === Helpers_1._EntityType.CHANNEL) {\n        return await client.invoke(new tl_1.Api.channels.ReadHistory({ channel: entity, maxId }));\n    }\n    else {\n        await client.invoke(new tl_1.Api.messages.ReadHistory({ peer: entity, maxId }));\n        return true;\n    }\n}\n/** @hidden */\nasync function getCommentData(client, entity, message) {\n    const result = await client.invoke(new tl_1.Api.messages.GetDiscussionMessage({\n        peer: entity,\n        msgId: __1.utils.getMessageId(message),\n    }));\n    const relevantMessage = result.messages.reduce((p, c) => (p && p.id < c.id ? p : c));\n    let chat;\n    for (const c of result.chats) {\n        if (relevantMessage.peerId instanceof tl_1.Api.PeerChannel &&\n            c.id.eq(relevantMessage.peerId.channelId)) {\n            chat = c;\n            break;\n        }\n    }\n    return {\n        entity: __1.utils.getInputPeer(chat),\n        replyTo: relevantMessage.id,\n    };\n}\n// TODO do the rest\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}