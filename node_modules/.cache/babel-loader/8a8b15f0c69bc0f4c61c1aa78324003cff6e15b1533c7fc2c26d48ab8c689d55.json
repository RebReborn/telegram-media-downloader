{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._EntityType = exports.TotalList = exports.sleep = exports.isArrayLike = void 0;\nexports.readBigIntFromBuffer = readBigIntFromBuffer;\nexports.generateRandomBigInt = generateRandomBigInt;\nexports.escapeRegex = escapeRegex;\nexports.groupBy = groupBy;\nexports.betterConsoleLog = betterConsoleLog;\nexports.toSignedLittleBuffer = toSignedLittleBuffer;\nexports.readBufferFromBigInt = readBufferFromBigInt;\nexports.generateRandomLong = generateRandomLong;\nexports.mod = mod;\nexports.bigIntMod = bigIntMod;\nexports.generateRandomBytes = generateRandomBytes;\nexports.stripText = stripText;\nexports.generateKeyDataFromNonce = generateKeyDataFromNonce;\nexports.convertToLittle = convertToLittle;\nexports.sha1 = sha1;\nexports.sha256 = sha256;\nexports.modExp = modExp;\nexports.getByteArray = getByteArray;\nexports.returnBigInt = returnBigInt;\nexports.getMinBigInt = getMinBigInt;\nexports.getRandomInt = getRandomInt;\nexports.bufferXor = bufferXor;\nexports.crc32 = crc32;\nexports._entityType = _entityType;\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst CryptoFile_1 = __importDefault(require(\"./CryptoFile\"));\nconst platform_1 = require(\"./platform\");\n/**\n * converts a buffer to big int\n * @param buffer\n * @param little\n * @param signed\n * @returns {bigInt.BigInteger}\n */\nfunction readBigIntFromBuffer(buffer, little = true, signed = false) {\n  let randBuffer = Buffer.from(buffer);\n  const bytesNumber = randBuffer.length;\n  if (little) {\n    randBuffer = randBuffer.reverse();\n  }\n  let bigIntVar = (0, big_integer_1.default)(randBuffer.toString(\"hex\"), 16);\n  if (signed && Math.floor(bigIntVar.toString(2).length / 8) >= bytesNumber) {\n    bigIntVar = bigIntVar.subtract((0, big_integer_1.default)(2).pow((0, big_integer_1.default)(bytesNumber * 8)));\n  }\n  return bigIntVar;\n}\nfunction generateRandomBigInt() {\n  return readBigIntFromBuffer(generateRandomBytes(8), false);\n}\nfunction escapeRegex(string) {\n  return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nfunction groupBy(list, keyGetter) {\n  const map = new Map();\n  list.forEach(item => {\n    const key = keyGetter(item);\n    const collection = map.get(key);\n    if (!collection) {\n      map.set(key, [item]);\n    } else {\n      collection.push(item);\n    }\n  });\n  return map;\n}\n/**\n * Outputs the object in a better way by hiding all the private methods/attributes.\n * @param object - the class to use\n */\nfunction betterConsoleLog(object) {\n  const toPrint = {};\n  for (const key in object) {\n    if (object.hasOwnProperty(key)) {\n      if (!key.startsWith(\"_\") && key != \"originalArgs\") {\n        toPrint[key] = object[key];\n      }\n    }\n  }\n  return toPrint;\n}\n/**\n * Helper to find if a given object is an array (or similar)\n */\nconst isArrayLike = x => x && typeof x.length === \"number\" && typeof x !== \"function\" && typeof x !== \"string\";\nexports.isArrayLike = isArrayLike;\n/*\nexport function addSurrogate(text: string) {\n    let temp = \"\";\n    for (const letter of text) {\n        const t = letter.charCodeAt(0);\n        if (0x1000 < t && t < 0x10FFFF) {\n            const b = Buffer.from(letter, \"utf16le\");\n            const r = String.fromCharCode(b.readUInt16LE(0)) + String.fromCharCode(b.readUInt16LE(2));\n            temp += r;\n        } else {\n            text += letter;\n        }\n    }\n    return temp;\n}\n\n */\n/**\n * Special case signed little ints\n * @param big\n * @param number\n * @returns {Buffer}\n */\nfunction toSignedLittleBuffer(big, number = 8) {\n  const bigNumber = returnBigInt(big);\n  const byteArray = [];\n  for (let i = 0; i < number; i++) {\n    byteArray[i] = bigNumber.shiftRight(8 * i).and(255);\n  }\n  // smh hacks\n  return Buffer.from(byteArray);\n}\n/**\n * converts a big int to a buffer\n * @param bigIntVar {BigInteger}\n * @param bytesNumber\n * @param little\n * @param signed\n * @returns {Buffer}\n */\nfunction readBufferFromBigInt(bigIntVar, bytesNumber, little = true, signed = false) {\n  bigIntVar = (0, big_integer_1.default)(bigIntVar);\n  const bitLength = bigIntVar.bitLength().toJSNumber();\n  const bytes = Math.ceil(bitLength / 8);\n  if (bytesNumber < bytes) {\n    throw new Error(\"OverflowError: int too big to convert\");\n  }\n  if (!signed && bigIntVar.lesser((0, big_integer_1.default)(0))) {\n    throw new Error(\"Cannot convert to unsigned\");\n  }\n  if (signed && bigIntVar.lesser((0, big_integer_1.default)(0))) {\n    bigIntVar = (0, big_integer_1.default)(2).pow((0, big_integer_1.default)(bytesNumber).multiply(8)).add(bigIntVar);\n  }\n  const hex = bigIntVar.toString(16).padStart(bytesNumber * 2, \"0\");\n  let buffer = Buffer.from(hex, \"hex\");\n  if (little) {\n    buffer = buffer.reverse();\n  }\n  return buffer;\n}\n/**\n * Generates a random long integer (8 bytes), which is optionally signed\n * @returns {BigInteger}\n */\nfunction generateRandomLong(signed = true) {\n  return readBigIntFromBuffer(generateRandomBytes(8), true, signed);\n}\n/**\n * .... really javascript\n * @param n {number}\n * @param m {number}\n * @returns {number}\n */\nfunction mod(n, m) {\n  return (n % m + m) % m;\n}\n/**\n * returns a positive bigInt\n * @param n {bigInt.BigInteger}\n * @param m {bigInt.BigInteger}\n * @returns {bigInt.BigInteger}\n */\nfunction bigIntMod(n, m) {\n  return n.remainder(m).add(m).remainder(m);\n}\n/**\n * Generates a random bytes array\n * @param count\n * @returns {Buffer}\n */\nfunction generateRandomBytes(count) {\n  return Buffer.from(CryptoFile_1.default.randomBytes(count));\n}\n/**\n * Calculate the key based on Telegram guidelines, specifying whether it's the client or not\n * @param sharedKey\n * @param msgKey\n * @param client\n * @returns {{iv: Buffer, key: Buffer}}\n */\n/*CONTEST\nthis is mtproto 1 (mostly used for secret chats)\nasync function calcKey(sharedKey, msgKey, client) {\n    const x = client === true ? 0 : 8\n    const [sha1a, sha1b, sha1c, sha1d] = await Promise.all([\n        sha1(Buffer.concat([msgKey, sharedKey.slice(x, x + 32)])),\n        sha1(Buffer.concat([sharedKey.slice(x + 32, x + 48), msgKey, sharedKey.slice(x + 48, x + 64)])),\n        sha1(Buffer.concat([sharedKey.slice(x + 64, x + 96), msgKey])),\n        sha1(Buffer.concat([msgKey, sharedKey.slice(x + 96, x + 128)]))\n    ])\n    const key = Buffer.concat([sha1a.slice(0, 8), sha1b.slice(8, 20), sha1c.slice(4, 16)])\n    const iv = Buffer.concat([sha1a.slice(8, 20), sha1b.slice(0, 8), sha1c.slice(16, 20), sha1d.slice(0, 8)])\n    return {\n        key,\n        iv\n    }\n}\n\n */\nfunction stripText(text, entities) {\n  if (!entities || !entities.length) {\n    return text.trim();\n  }\n  while (text && text[text.length - 1].trim() === \"\") {\n    const e = entities[entities.length - 1];\n    if (e.offset + e.length == text.length) {\n      if (e.length == 1) {\n        entities.pop();\n        if (!entities.length) {\n          return text.trim();\n        }\n      } else {\n        e.length -= 1;\n      }\n    }\n    text = text.slice(0, -1);\n  }\n  while (text && text[0].trim() === \"\") {\n    for (let i = 0; i < entities.length; i++) {\n      const e = entities[i];\n      if (e.offset != 0) {\n        e.offset--;\n        continue;\n      }\n      if (e.length == 1) {\n        entities.shift();\n        if (!entities.length) {\n          return text.trimLeft();\n        }\n      } else {\n        e.length -= 1;\n      }\n    }\n    text = text.slice(1);\n  }\n  return text;\n}\n/**\n * Generates the key data corresponding to the given nonces\n * @param serverNonceBigInt\n * @param newNonceBigInt\n * @returns {{key: Buffer, iv: Buffer}}\n */\nasync function generateKeyDataFromNonce(serverNonceBigInt, newNonceBigInt) {\n  const serverNonce = toSignedLittleBuffer(serverNonceBigInt, 16);\n  const newNonce = toSignedLittleBuffer(newNonceBigInt, 32);\n  const [hash1, hash2, hash3] = await Promise.all([sha1(Buffer.concat([newNonce, serverNonce])), sha1(Buffer.concat([serverNonce, newNonce])), sha1(Buffer.concat([newNonce, newNonce]))]);\n  const keyBuffer = Buffer.concat([hash1, hash2.slice(0, 12)]);\n  const ivBuffer = Buffer.concat([hash2.slice(12, 20), hash3, newNonce.slice(0, 4)]);\n  return {\n    key: keyBuffer,\n    iv: ivBuffer\n  };\n}\nfunction convertToLittle(buf) {\n  const correct = Buffer.alloc(buf.length * 4);\n  for (let i = 0; i < buf.length; i++) {\n    correct.writeUInt32BE(buf[i], i * 4);\n  }\n  return correct;\n}\n/**\n * Calculates the SHA1 digest for the given data\n * @param data\n * @returns {Promise}\n */\nfunction sha1(data) {\n  const shaSum = CryptoFile_1.default.createHash(\"sha1\");\n  shaSum.update(data);\n  // @ts-ignore\n  return shaSum.digest();\n}\n/**\n * Calculates the SHA256 digest for the given data\n * @param data\n * @returns {Promise}\n */\nfunction sha256(data) {\n  const shaSum = CryptoFile_1.default.createHash(\"sha256\");\n  shaSum.update(data);\n  // @ts-ignore\n  return shaSum.digest();\n}\n/**\n * Fast mod pow for RSA calculation. a^b % n\n * @param a\n * @param b\n * @param n\n * @returns {bigInt.BigInteger}\n */\nfunction modExp(a, b, n) {\n  a = a.remainder(n);\n  let result = big_integer_1.default.one;\n  let x = a;\n  while (b.greater(big_integer_1.default.zero)) {\n    const leastSignificantBit = b.remainder((0, big_integer_1.default)(2));\n    b = b.divide((0, big_integer_1.default)(2));\n    if (leastSignificantBit.eq(big_integer_1.default.one)) {\n      result = result.multiply(x);\n      result = result.remainder(n);\n    }\n    x = x.multiply(x);\n    x = x.remainder(n);\n  }\n  return result;\n}\n/**\n * Gets the arbitrary-length byte array corresponding to the given integer\n * @param integer {number,BigInteger}\n * @param signed {boolean}\n * @returns {Buffer}\n */\nfunction getByteArray(integer, signed = false) {\n  const bits = integer.toString(2).length;\n  const byteLength = Math.floor((bits + 8 - 1) / 8);\n  return readBufferFromBigInt(typeof integer == \"number\" ? (0, big_integer_1.default)(integer) : integer, byteLength, false, signed);\n}\nfunction returnBigInt(num) {\n  if (big_integer_1.default.isInstance(num)) {\n    return num;\n  }\n  if (typeof num == \"number\") {\n    return (0, big_integer_1.default)(num);\n  }\n  if (typeof num == \"bigint\") {\n    return (0, big_integer_1.default)(num);\n  }\n  return (0, big_integer_1.default)(num);\n}\n/**\n * Helper function to return the smaller big int in an array\n * @param arrayOfBigInts\n */\nfunction getMinBigInt(arrayOfBigInts) {\n  if (arrayOfBigInts.length == 0) {\n    return big_integer_1.default.zero;\n  }\n  if (arrayOfBigInts.length == 1) {\n    return returnBigInt(arrayOfBigInts[0]);\n  }\n  let smallest = returnBigInt(arrayOfBigInts[0]);\n  for (let i = 1; i < arrayOfBigInts.length; i++) {\n    if (returnBigInt(arrayOfBigInts[i]).lesser(smallest)) {\n      smallest = returnBigInt(arrayOfBigInts[i]);\n    }\n  }\n  return smallest;\n}\n/**\n * returns a random int from min (inclusive) and max (inclusive)\n * @param min\n * @param max\n * @returns {number}\n */\nfunction getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n/**\n * Sleeps a specified amount of time\n * @param ms time in milliseconds\n * @param isUnref make a timer unref'ed\n * @returns {Promise}\n */\nconst sleep = (ms, isUnref = false) => new Promise(resolve => isUnref && platform_1.isNode ? setTimeout(resolve, ms).unref() : setTimeout(resolve, ms));\nexports.sleep = sleep;\n/**\n * Helper to export two buffers of same length\n * @returns {Buffer}\n */\nfunction bufferXor(a, b) {\n  const res = [];\n  for (let i = 0; i < a.length; i++) {\n    res.push(a[i] ^ b[i]);\n  }\n  return Buffer.from(res);\n}\n// Taken from https://stackoverflow.com/questions/18638900/javascript-crc32/18639999#18639999\nfunction makeCRCTable() {\n  let c;\n  const crcTable = [];\n  for (let n = 0; n < 256; n++) {\n    c = n;\n    for (let k = 0; k < 8; k++) {\n      c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;\n    }\n    crcTable[n] = c;\n  }\n  return crcTable;\n}\nlet crcTable = undefined;\nfunction crc32(buf) {\n  if (!crcTable) {\n    crcTable = makeCRCTable();\n  }\n  if (!Buffer.isBuffer(buf)) {\n    buf = Buffer.from(buf);\n  }\n  let crc = -1;\n  for (let index = 0; index < buf.length; index++) {\n    const byte = buf[index];\n    crc = crcTable[(crc ^ byte) & 0xff] ^ crc >>> 8;\n  }\n  return (crc ^ -1) >>> 0;\n}\nclass TotalList extends Array {\n  constructor() {\n    super();\n    this.total = 0;\n  }\n}\nexports.TotalList = TotalList;\nexports._EntityType = {\n  USER: 0,\n  CHAT: 1,\n  CHANNEL: 2\n};\nObject.freeze(exports._EntityType);\nfunction _entityType(entity) {\n  if (typeof entity !== \"object\" || !(\"SUBCLASS_OF_ID\" in entity)) {\n    throw new Error(`${entity} is not a TLObject, cannot determine entity type`);\n  }\n  if (![0x2d45687,\n  // crc32('Peer')\n  0xc91c90b6,\n  // crc32('InputPeer')\n  0xe669bf46,\n  // crc32('InputUser')\n  0x40f202fd,\n  // crc32('InputChannel')\n  0x2da17977,\n  // crc32('User')\n  0xc5af5d94,\n  // crc32('Chat')\n  0x1f4661b9,\n  // crc32('UserFull')\n  0xd49a2697 // crc32('ChatFull')\n  ].includes(entity.SUBCLASS_OF_ID)) {\n    throw new Error(`${entity} does not have any entity type`);\n  }\n  const name = entity.className;\n  if (name.includes(\"User\")) {\n    return exports._EntityType.USER;\n  } else if (name.includes(\"Chat\")) {\n    return exports._EntityType.CHAT;\n  } else if (name.includes(\"Channel\")) {\n    return exports._EntityType.CHANNEL;\n  } else if (name.includes(\"Self\")) {\n    return exports._EntityType.USER;\n  }\n  // 'Empty' in name or not found, we don't care, not a valid entity.\n  throw new Error(`${entity} does not have any entity type`);\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}