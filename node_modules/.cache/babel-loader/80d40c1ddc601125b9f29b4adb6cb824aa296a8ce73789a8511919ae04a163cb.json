{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PromisedWebSockets = void 0;\nconst websocket_1 = require(\"websocket\");\nconst async_mutex_1 = require(\"async-mutex\");\nconst platform_1 = require(\"../platform\");\nconst mutex = new async_mutex_1.Mutex();\nconst closeError = new Error(\"WebSocket was closed\");\nclass PromisedWebSockets {\n  constructor() {\n    this.client = undefined;\n    this.stream = Buffer.alloc(0);\n    this.closed = true;\n  }\n  async readExactly(number) {\n    let readData = Buffer.alloc(0);\n    while (true) {\n      const thisTime = await this.read(number);\n      readData = Buffer.concat([readData, thisTime]);\n      number = number - thisTime.length;\n      if (!number) {\n        return readData;\n      }\n    }\n  }\n  async read(number) {\n    if (this.closed) {\n      throw closeError;\n    }\n    await this.canRead;\n    if (this.closed) {\n      throw closeError;\n    }\n    const toReturn = this.stream.slice(0, number);\n    this.stream = this.stream.slice(number);\n    if (this.stream.length === 0) {\n      this.canRead = new Promise(resolve => {\n        this.resolveRead = resolve;\n      });\n    }\n    return toReturn;\n  }\n  async readAll() {\n    if (this.closed || !(await this.canRead)) {\n      throw closeError;\n    }\n    const toReturn = this.stream;\n    this.stream = Buffer.alloc(0);\n    this.canRead = new Promise(resolve => {\n      this.resolveRead = resolve;\n    });\n    return toReturn;\n  }\n  getWebSocketLink(ip, port, testServers) {\n    if (port === 443) {\n      return `wss://${ip}:${port}/apiws${testServers ? \"_test\" : \"\"}`;\n    } else {\n      return `ws://${ip}:${port}/apiws${testServers ? \"_test\" : \"\"}`;\n    }\n  }\n  async connect(port, ip) {\n    let testServers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this.stream = Buffer.alloc(0);\n    this.canRead = new Promise(resolve => {\n      this.resolveRead = resolve;\n    });\n    this.closed = false;\n    this.website = this.getWebSocketLink(ip, port, testServers);\n    this.client = new websocket_1.w3cwebsocket(this.website, \"binary\");\n    return new Promise((resolve, reject) => {\n      if (this.client) {\n        this.client.onopen = () => {\n          this.receive();\n          resolve(this);\n        };\n        this.client.onerror = error => {\n          reject(error);\n        };\n        this.client.onclose = () => {\n          if (this.resolveRead) {\n            this.resolveRead(false);\n          }\n          this.closed = true;\n        };\n        //CONTEST\n        if (platform_1.isBrowser) {\n          window.addEventListener(\"offline\", async () => {\n            await this.close();\n            if (this.resolveRead) {\n              this.resolveRead(false);\n            }\n          });\n        }\n      }\n    });\n  }\n  write(data) {\n    if (this.closed) {\n      throw closeError;\n    }\n    if (this.client) {\n      this.client.send(data);\n    }\n  }\n  async close() {\n    if (this.client) {\n      await this.client.close();\n    }\n    this.closed = true;\n  }\n  async receive() {\n    if (this.client) {\n      this.client.onmessage = async message => {\n        const release = await mutex.acquire();\n        try {\n          let data;\n          //CONTEST BROWSER\n          data = Buffer.from(await new Response(message.data).arrayBuffer());\n          this.stream = Buffer.concat([this.stream, data]);\n          if (this.resolveRead) {\n            this.resolveRead(true);\n          }\n        } finally {\n          release();\n        }\n      };\n    }\n  }\n  toString() {\n    return \"PromisedWebSocket\";\n  }\n}\nexports.PromisedWebSockets = PromisedWebSockets;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}