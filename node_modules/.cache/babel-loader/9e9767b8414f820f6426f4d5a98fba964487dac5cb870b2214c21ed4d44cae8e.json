{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NewMessageEvent = exports.NewMessage = void 0;\nconst common_1 = require(\"./common\");\nconst tl_1 = require(\"../tl\");\nconst Logger_1 = require(\"../extensions/Logger\");\n/**\n * Occurs whenever a new text message or a message with media arrives.\n * @example\n * ```ts\n * async function eventPrint(event: NewMessageEvent) {\n * const message = event.message;\n *\n *   // Checks if it's a private message (from user or bot)\n *   if (event.isPrivate){\n *       // prints sender id\n *       console.log(message.senderId);\n *       // read message\n *       if (message.text == \"hello\"){\n *           const sender = await message.getSender();\n *           console.log(\"sender is\",sender);\n *           await client.sendMessage(sender,{\n *               message:`hi your id is ${message.senderId}`\n *           });\n *       }\n *   }\n * }\n * // adds an event handler for new messages\n * client.addEventHandler(eventPrint, new NewMessage({}));\n * ```\n */\nclass NewMessage extends common_1.EventBuilder {\n  constructor(newMessageParams = {}) {\n    let {\n      chats,\n      func,\n      incoming,\n      outgoing,\n      fromUsers,\n      forwards,\n      pattern,\n      blacklistChats = false\n    } = newMessageParams;\n    if (incoming && outgoing) {\n      incoming = outgoing = undefined;\n    } else if (incoming != undefined && outgoing == undefined) {\n      outgoing = !incoming;\n    } else if (outgoing != undefined && incoming == undefined) {\n      incoming = !outgoing;\n    } else if (outgoing == false && incoming == false) {\n      throw new Error(\"Don't create an event handler if you don't want neither incoming nor outgoing!\");\n    }\n    super({\n      chats,\n      blacklistChats,\n      func\n    });\n    this.incoming = incoming;\n    this.outgoing = outgoing;\n    this.fromUsers = fromUsers;\n    this.forwards = forwards;\n    this.pattern = pattern;\n    this._noCheck = [incoming, outgoing, chats, pattern, fromUsers, forwards, func].every(v => v == undefined);\n  }\n  async _resolve(client) {\n    await super._resolve(client);\n    this.fromUsers = await (0, common_1._intoIdSet)(client, this.fromUsers);\n  }\n  build(update, callback, selfId) {\n    if (update instanceof tl_1.Api.UpdateNewMessage || update instanceof tl_1.Api.UpdateNewChannelMessage) {\n      if (!(update.message instanceof tl_1.Api.Message)) {\n        return undefined;\n      }\n      const event = new NewMessageEvent(update.message, update);\n      this.addAttributes(event);\n      return event;\n    } else if (update instanceof tl_1.Api.UpdateShortMessage) {\n      return new NewMessageEvent(new tl_1.Api.Message({\n        out: update.out,\n        mentioned: update.mentioned,\n        mediaUnread: update.mediaUnread,\n        silent: update.silent,\n        id: update.id,\n        peerId: new tl_1.Api.PeerUser({\n          userId: update.userId\n        }),\n        fromId: new tl_1.Api.PeerUser({\n          userId: update.out ? selfId : update.userId\n        }),\n        message: update.message,\n        date: update.date,\n        fwdFrom: update.fwdFrom,\n        viaBotId: update.viaBotId,\n        replyTo: update.replyTo,\n        entities: update.entities,\n        ttlPeriod: update.ttlPeriod\n      }), update);\n    } else if (update instanceof tl_1.Api.UpdateShortChatMessage) {\n      return new NewMessageEvent(new tl_1.Api.Message({\n        out: update.out,\n        mentioned: update.mentioned,\n        mediaUnread: update.mediaUnread,\n        silent: update.silent,\n        id: update.id,\n        peerId: new tl_1.Api.PeerChat({\n          chatId: update.chatId\n        }),\n        fromId: new tl_1.Api.PeerUser({\n          userId: update.out ? selfId : update.fromId\n        }),\n        message: update.message,\n        date: update.date,\n        fwdFrom: update.fwdFrom,\n        viaBotId: update.viaBotId,\n        replyTo: update.replyTo,\n        entities: update.entities,\n        ttlPeriod: update.ttlPeriod\n      }), update);\n    }\n  }\n  filter(event) {\n    var _a;\n    if (this._noCheck) {\n      return event;\n    }\n    if (this.incoming && event.message.out) {\n      return;\n    }\n    if (this.outgoing && !event.message.out) {\n      return;\n    }\n    if (this.forwards != undefined) {\n      if (this.forwards != !!event.message.fwdFrom) {\n        return;\n      }\n    }\n    if (this.fromUsers != undefined) {\n      if (!event.message.senderId || !this.fromUsers.includes(event.message.senderId.toString())) {\n        return;\n      }\n    }\n    if (this.pattern) {\n      const match = (_a = event.message.message) === null || _a === void 0 ? void 0 : _a.match(this.pattern);\n      if (!match) {\n        return;\n      }\n      event.message.patternMatch = match;\n    }\n    return super.filter(event);\n  }\n  addAttributes(update) {\n    //update.patternMatch =\n  }\n}\nexports.NewMessage = NewMessage;\nclass NewMessageEvent extends common_1.EventCommon {\n  constructor(message, originalUpdate) {\n    super({\n      msgId: message.id,\n      chatPeer: message.peerId,\n      broadcast: message.post\n    });\n    this.originalUpdate = originalUpdate;\n    this.message = message;\n  }\n  _setClient(client) {\n    super._setClient(client);\n    const m = this.message;\n    try {\n      // todo make sure this never fails\n      m._finishInit(client, this.originalUpdate._entities || new Map(), undefined);\n    } catch (e) {\n      client._log.error(\"Got error while trying to finish init message with id \" + m.id);\n      if (client._errorHandler) {\n        client._errorHandler(e);\n      }\n      if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\n        console.error(e);\n      }\n    }\n  }\n}\nexports.NewMessageEvent = NewMessageEvent;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}