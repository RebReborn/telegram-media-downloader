{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._ParticipantsIter = void 0;\nexports.iterParticipants = iterParticipants;\nexports.getParticipants = getParticipants;\nexports.kickParticipant = kickParticipant;\nconst Helpers_1 = require(\"../Helpers\");\nconst requestIter_1 = require(\"../requestIter\");\nconst __1 = require(\"../\");\nconst tl_1 = require(\"../tl\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst inspect_1 = require(\"../inspect\");\nconst Utils_1 = require(\"../Utils\");\nconst _MAX_PARTICIPANTS_CHUNK_SIZE = 200;\nconst _MAX_ADMIN_LOG_CHUNK_SIZE = 100;\nconst _MAX_PROFILE_PHOTO_CHUNK_SIZE = 100;\nclass _ChatAction {\n  [inspect_1.inspect.custom]() {\n    return (0, Helpers_1.betterConsoleLog)(this);\n  }\n  constructor(client, chat, action) {\n    let params = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n      delay: 4,\n      autoCancel: true\n    };\n    this._client = client;\n    this._chat = chat;\n    this._action = action;\n    this._delay = params.delay;\n    this.autoCancel = params.autoCancel;\n    this._request = undefined;\n    this._task = null;\n    this._running = false;\n  }\n  async start() {\n    this._request = new tl_1.Api.messages.SetTyping({\n      peer: this._chat,\n      action: this._action\n    });\n    this._running = true;\n    this._update();\n  }\n  async stop() {\n    this._running = false;\n    if (this.autoCancel) {\n      await this._client.invoke(new tl_1.Api.messages.SetTyping({\n        peer: this._chat,\n        action: new tl_1.Api.SendMessageCancelAction()\n      }));\n    }\n  }\n  async _update() {\n    while (this._running) {\n      if (this._request != undefined) {\n        await this._client.invoke(this._request);\n      }\n      await (0, Helpers_1.sleep)(this._delay * 1000);\n    }\n  }\n  progress(current, total) {\n    if (\"progress\" in this._action) {\n      this._action.progress = 100 * Math.round(current / total);\n    }\n  }\n}\n_ChatAction._str_mapping = {\n  typing: new tl_1.Api.SendMessageTypingAction(),\n  contact: new tl_1.Api.SendMessageChooseContactAction(),\n  game: new tl_1.Api.SendMessageGamePlayAction(),\n  location: new tl_1.Api.SendMessageGeoLocationAction(),\n  \"record-audio\": new tl_1.Api.SendMessageRecordAudioAction(),\n  \"record-voice\": new tl_1.Api.SendMessageRecordAudioAction(),\n  //alias\n  \"record-round\": new tl_1.Api.SendMessageRecordRoundAction(),\n  \"record-video\": new tl_1.Api.SendMessageRecordVideoAction(),\n  audio: new tl_1.Api.SendMessageUploadAudioAction({\n    progress: 1\n  }),\n  voice: new tl_1.Api.SendMessageUploadAudioAction({\n    progress: 1\n  }),\n  // alias\n  song: new tl_1.Api.SendMessageUploadAudioAction({\n    progress: 1\n  }),\n  // alias\n  round: new tl_1.Api.SendMessageUploadRoundAction({\n    progress: 1\n  }),\n  video: new tl_1.Api.SendMessageUploadVideoAction({\n    progress: 1\n  }),\n  photo: new tl_1.Api.SendMessageUploadPhotoAction({\n    progress: 1\n  }),\n  document: new tl_1.Api.SendMessageUploadDocumentAction({\n    progress: 1\n  }),\n  file: new tl_1.Api.SendMessageUploadDocumentAction({\n    progress: 1\n  }),\n  // alias\n  cancel: new tl_1.Api.SendMessageCancelAction()\n};\nclass _ParticipantsIter extends requestIter_1.RequestIter {\n  [inspect_1.inspect.custom]() {\n    return (0, Helpers_1.betterConsoleLog)(this);\n  }\n  async _init(_ref) {\n    let {\n      entity,\n      filter,\n      offset,\n      search,\n      showTotal\n    } = _ref;\n    var _a, _b;\n    if (!offset) {\n      offset = 0;\n    }\n    if (filter && filter.constructor === Function) {\n      if ([tl_1.Api.ChannelParticipantsBanned, tl_1.Api.ChannelParticipantsKicked, tl_1.Api.ChannelParticipantsSearch, tl_1.Api.ChannelParticipantsContacts].includes(filter)) {\n        filter = new filter({\n          q: \"\"\n        });\n      } else {\n        filter = new filter();\n      }\n    }\n    entity = await this.client.getInputEntity(entity);\n    const ty = __1.helpers._entityType(entity);\n    if (search && (filter || ty != __1.helpers._EntityType.CHANNEL)) {\n      // We need to 'search' ourselves unless we have a PeerChannel\n      search = search.toLowerCase();\n      this.filterEntity = entity => {\n        return __1.utils.getDisplayName(entity).toLowerCase().includes(search) || (\"username\" in entity ? entity.username || \"\" : \"\").toLowerCase().includes(search);\n      };\n    } else {\n      this.filterEntity = entity => true;\n    }\n    // Only used for channels, but we should always set the attribute\n    this.requests = [];\n    if (ty == __1.helpers._EntityType.CHANNEL) {\n      if (showTotal) {\n        const channel = await this.client.invoke(new tl_1.Api.channels.GetFullChannel({\n          channel: entity\n        }));\n        if (!(channel.fullChat instanceof tl_1.Api.ChatFull)) {\n          this.total = channel.fullChat.participantsCount;\n        }\n      }\n      if (this.total && this.total <= 0) {\n        return false;\n      }\n      this.requests.push(new tl_1.Api.channels.GetParticipants({\n        channel: entity,\n        filter: filter || new tl_1.Api.ChannelParticipantsSearch({\n          q: search || \"\"\n        }),\n        offset,\n        limit: _MAX_PARTICIPANTS_CHUNK_SIZE,\n        hash: big_integer_1.default.zero\n      }));\n    } else if (ty == __1.helpers._EntityType.CHAT) {\n      if (!(\"chatId\" in entity)) {\n        throw new Error(\"Found chat without id \" + JSON.stringify(entity));\n      }\n      const full = await this.client.invoke(new tl_1.Api.messages.GetFullChat({\n        chatId: entity.chatId\n      }));\n      if (full.fullChat instanceof tl_1.Api.ChatFull) {\n        if (!(full.fullChat.participants instanceof tl_1.Api.ChatParticipantsForbidden)) {\n          this.total = full.fullChat.participants.participants.length;\n        } else {\n          this.total = 0;\n          return false;\n        }\n        const users = new Map();\n        for (const user of full.users) {\n          users.set(user.id.toString(), user);\n        }\n        for (const participant of full.fullChat.participants.participants) {\n          const user = users.get(participant.userId.toString());\n          if (!this.filterEntity(user)) {\n            continue;\n          }\n          user.participant = participant;\n          (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.push(user);\n        }\n        return true;\n      }\n    } else {\n      this.total = 1;\n      if (this.limit != 0) {\n        const user = await this.client.getEntity(entity);\n        if (this.filterEntity(user)) {\n          user.participant = undefined;\n          (_b = this.buffer) === null || _b === void 0 ? void 0 : _b.push(user);\n        }\n      }\n      return true;\n    }\n  }\n  async _loadNextChunk() {\n    var _a, _b;\n    if (!((_a = this.requests) === null || _a === void 0 ? void 0 : _a.length)) {\n      return true;\n    }\n    this.requests[0].limit = Math.min(this.limit - this.requests[0].offset, _MAX_PARTICIPANTS_CHUNK_SIZE);\n    const results = [];\n    for (const request of this.requests) {\n      results.push(await this.client.invoke(request));\n    }\n    for (let i = this.requests.length - 1; i >= 0; i--) {\n      const participants = results[i];\n      if (participants instanceof tl_1.Api.channels.ChannelParticipantsNotModified || !participants.users.length) {\n        this.requests.splice(i, 1);\n        continue;\n      }\n      this.requests[i].offset += participants.participants.length;\n      const users = new Map();\n      for (const user of participants.users) {\n        users.set(user.id.toString(), user);\n      }\n      for (const participant of participants.participants) {\n        if (!(\"userId\" in participant)) {\n          continue;\n        }\n        const user = users.get(participant.userId.toString());\n        if (this.filterEntity && !this.filterEntity(user)) {\n          continue;\n        }\n        user.participant = participant;\n        (_b = this.buffer) === null || _b === void 0 ? void 0 : _b.push(user);\n      }\n    }\n    return undefined;\n  }\n  [Symbol.asyncIterator]() {\n    return super[Symbol.asyncIterator]();\n  }\n}\nexports._ParticipantsIter = _ParticipantsIter;\nclass _AdminLogIter extends requestIter_1.RequestIter {\n  [inspect_1.inspect.custom]() {\n    return (0, Helpers_1.betterConsoleLog)(this);\n  }\n  async _init(entity, searchArgs, filterArgs) {\n    let eventsFilter = undefined;\n    if (filterArgs && Object.values(filterArgs).find(element => element === true)) {\n      eventsFilter = new tl_1.Api.ChannelAdminLogEventsFilter(Object.assign({}, filterArgs));\n    }\n    this.entity = await this.client.getInputEntity(entity);\n    const adminList = [];\n    if (searchArgs && searchArgs.admins) {\n      for (const admin of searchArgs.admins) {\n        adminList.push(await this.client.getInputEntity(admin));\n      }\n    }\n    this.request = new tl_1.Api.channels.GetAdminLog({\n      channel: this.entity,\n      q: (searchArgs === null || searchArgs === void 0 ? void 0 : searchArgs.search) || \"\",\n      minId: searchArgs === null || searchArgs === void 0 ? void 0 : searchArgs.minId,\n      maxId: searchArgs === null || searchArgs === void 0 ? void 0 : searchArgs.maxId,\n      limit: 0,\n      eventsFilter: eventsFilter,\n      admins: adminList || undefined\n    });\n  }\n  async _loadNextChunk() {\n    if (!this.request) {\n      return true;\n    }\n    this.request.limit = Math.min(this.left, _MAX_ADMIN_LOG_CHUNK_SIZE);\n    const r = await this.client.invoke(this.request);\n    const entities = new Map();\n    for (const entity of [...r.users, ...r.chats]) {\n      entities.set(__1.utils.getPeerId(entity), entity);\n    }\n    const eventIds = [];\n    for (const e of r.events) {\n      eventIds.push(e.id);\n    }\n    this.request.maxId = (0, Helpers_1.getMinBigInt)([big_integer_1.default.zero, ...eventIds]);\n    for (const ev of r.events) {\n      if (ev.action instanceof tl_1.Api.ChannelAdminLogEventActionEditMessage) {\n        // @ts-ignore\n        // TODO ev.action.prevMessage._finishInit(this.client, entities, this.entity);\n        // @ts-ignore\n        // TODO ev.action.newMessage._finishInit(this.client, entities, this.entity);\n      }\n    }\n  }\n}\n/** @hidden */\nfunction iterParticipants(client, entity, _ref2) {\n  let {\n    limit,\n    offset,\n    search,\n    filter,\n    showTotal = true\n  } = _ref2;\n  return new _ParticipantsIter(client, limit !== null && limit !== void 0 ? limit : Number.MAX_SAFE_INTEGER, {}, {\n    entity: entity,\n    filter: filter,\n    offset: offset !== null && offset !== void 0 ? offset : 0,\n    search: search,\n    showTotal: showTotal\n  });\n}\n/** @hidden */\nasync function getParticipants(client, entity, params) {\n  const it = client.iterParticipants(entity, params);\n  return await it.collect();\n}\n/** @hidden */\nasync function kickParticipant(client, entity, participant) {\n  const peer = await client.getInputEntity(entity);\n  const user = await client.getInputEntity(participant);\n  let resp;\n  let request;\n  const type = __1.helpers._entityType(peer);\n  if (type === __1.helpers._EntityType.CHAT) {\n    request = new tl_1.Api.messages.DeleteChatUser({\n      chatId: (0, Helpers_1.returnBigInt)((0, Utils_1.getPeerId)(entity)),\n      userId: (0, Helpers_1.returnBigInt)((0, Utils_1.getPeerId)(participant))\n    });\n    resp = await client.invoke(request);\n  } else if (type === __1.helpers._EntityType.CHANNEL) {\n    if (user instanceof tl_1.Api.InputPeerSelf) {\n      request = new tl_1.Api.channels.LeaveChannel({\n        channel: peer\n      });\n      resp = await client.invoke(request);\n    } else {\n      request = new tl_1.Api.channels.EditBanned({\n        channel: peer,\n        participant: user,\n        bannedRights: new tl_1.Api.ChatBannedRights({\n          untilDate: 0,\n          viewMessages: true\n        })\n      });\n      resp = await client.invoke(request);\n      await (0, Helpers_1.sleep)(500);\n      await client.invoke(new tl_1.Api.channels.EditBanned({\n        channel: peer,\n        participant: user,\n        bannedRights: new tl_1.Api.ChatBannedRights({\n          untilDate: 0\n        })\n      }));\n    }\n  } else {\n    throw new Error(\"You must pass either a channel or a chat\");\n  }\n  return client._getResponseMessage(request, resp, entity);\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}