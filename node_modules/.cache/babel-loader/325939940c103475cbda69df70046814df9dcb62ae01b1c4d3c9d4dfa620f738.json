{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessagePacker = void 0;\nconst core_1 = require(\"../tl/core\");\nconst core_2 = require(\"../tl/core\");\nconst BinaryWriter_1 = require(\"./BinaryWriter\");\nconst USE_INVOKE_AFTER_WITH = new Set([\"messages.SendMessage\", \"messages.SendMedia\", \"messages.SendMultiMedia\", \"messages.ForwardMessages\", \"messages.SendInlineBotResult\"]);\nclass MessagePacker {\n  constructor(state, logger) {\n    this._state = state;\n    this._queue = [];\n    this._pendingStates = [];\n    this._ready = new Promise(resolve => {\n      this.setReady = resolve;\n    });\n    this._log = logger;\n  }\n  values() {\n    return this._queue;\n  }\n  append(state, setReady = true, atStart = false) {\n    var _a, _b;\n    // We need to check if there is already a `USE_INVOKE_AFTER_WITH` request\n    if (state && USE_INVOKE_AFTER_WITH.has(state.request.className)) {\n      if (atStart) {\n        // Assign `after` for the previously first `USE_INVOKE_AFTER_WITH` request\n        for (let i = 0; i < this._queue.length; i++) {\n          if (USE_INVOKE_AFTER_WITH.has((_a = this._queue[i]) === null || _a === void 0 ? void 0 : _a.request.className)) {\n            this._queue[i].after = state;\n            break;\n          }\n        }\n      } else {\n        // Assign after for the previous `USE_INVOKE_AFTER_WITH` request\n        for (let i = this._queue.length - 1; i >= 0; i--) {\n          if (USE_INVOKE_AFTER_WITH.has((_b = this._queue[i]) === null || _b === void 0 ? void 0 : _b.request.className)) {\n            state.after = this._queue[i];\n            break;\n          }\n        }\n      }\n    }\n    if (atStart) {\n      this._queue.unshift(state);\n    } else {\n      this._queue.push(state);\n    }\n    if (setReady && this.setReady) {\n      this.setReady(true);\n    }\n    // 1658238041=MsgsAck, we don't care about MsgsAck here because they never resolve anyway.\n    if (state && state.request.CONSTRUCTOR_ID !== 1658238041) {\n      this._pendingStates.push(state);\n      state.promise // Using finally causes triggering `unhandledrejection` event\n      .catch(err => {}).finally(() => {\n        this._pendingStates = this._pendingStates.filter(s => s !== state);\n      });\n    }\n  }\n  prepend(states) {\n    states.reverse().forEach(state => {\n      this.append(state, false, true);\n    });\n    if (this.setReady) {\n      this.setReady(true);\n    }\n  }\n  extend(states) {\n    states.forEach(state => {\n      this.append(state, false);\n    });\n    if (this.setReady) {\n      this.setReady(true);\n    }\n  }\n  clear() {\n    this._queue = [];\n    this.append(undefined);\n  }\n  async wait() {\n    if (!this._queue.length) {\n      this._ready = new Promise(resolve => {\n        this.setReady = resolve;\n      });\n      await this._ready;\n    }\n  }\n  async get() {\n    if (!this._queue[this._queue.length - 1]) {\n      this._queue = this._queue.filter(Boolean);\n      return undefined;\n    }\n    let data;\n    let buffer = new BinaryWriter_1.BinaryWriter(Buffer.alloc(0));\n    const batch = [];\n    let size = 0;\n    while (this._queue.length && batch.length <= core_1.MessageContainer.MAXIMUM_LENGTH) {\n      const state = this._queue.shift();\n      if (!state) {\n        continue;\n      }\n      size += state.data.length + core_2.TLMessage.SIZE_OVERHEAD;\n      if (size <= core_1.MessageContainer.MAXIMUM_SIZE) {\n        let afterId;\n        if (state.after) {\n          afterId = state.after.msgId;\n        }\n        if (state.after) {\n          afterId = state.after.msgId;\n        }\n        state.msgId = await this._state.writeDataAsMessage(buffer, state.data, state.request.classType === \"request\", afterId);\n        this._log.debug(`Assigned msgId = ${state.msgId} to ${state.request.className || state.request.constructor.name}`);\n        batch.push(state);\n        continue;\n      }\n      if (batch.length) {\n        this._queue.unshift(state);\n        break;\n      }\n      this._log.warn(`Message payload for ${state.request.className || state.request.constructor.name} is too long ${state.data.length} and cannot be sent`);\n      state.promise.reject(\"Request Payload is too big\");\n      size = 0;\n    }\n    if (!batch.length) {\n      return null;\n    }\n    if (batch.length > 1) {\n      const b = Buffer.alloc(8);\n      b.writeUInt32LE(core_1.MessageContainer.CONSTRUCTOR_ID, 0);\n      b.writeInt32LE(batch.length, 4);\n      data = Buffer.concat([b, buffer.getValue()]);\n      buffer = new BinaryWriter_1.BinaryWriter(Buffer.alloc(0));\n      const containerId = await this._state.writeDataAsMessage(buffer, data, false);\n      for (const s of batch) {\n        s.containerId = containerId;\n      }\n    }\n    data = buffer.getValue();\n    return {\n      batch,\n      data\n    };\n  }\n}\nexports.MessagePacker = MessagePacker;","map":{"version":3,"names":["Object","defineProperty","exports","value","MessagePacker","core_1","require","core_2","BinaryWriter_1","USE_INVOKE_AFTER_WITH","Set","constructor","state","logger","_state","_queue","_pendingStates","_ready","Promise","resolve","setReady","_log","values","append","atStart","_a","_b","has","request","className","i","length","after","unshift","push","CONSTRUCTOR_ID","promise","catch","err","finally","filter","s","prepend","states","reverse","forEach","extend","clear","undefined","wait","get","Boolean","data","buffer","BinaryWriter","Buffer","alloc","batch","size","MessageContainer","MAXIMUM_LENGTH","shift","TLMessage","SIZE_OVERHEAD","MAXIMUM_SIZE","afterId","msgId","writeDataAsMessage","classType","debug","name","warn","reject","b","writeUInt32LE","writeInt32LE","concat","getValue","containerId"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/extensions/MessagePacker.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessagePacker = void 0;\nconst core_1 = require(\"../tl/core\");\nconst core_2 = require(\"../tl/core\");\nconst BinaryWriter_1 = require(\"./BinaryWriter\");\nconst USE_INVOKE_AFTER_WITH = new Set([\n    \"messages.SendMessage\",\n    \"messages.SendMedia\",\n    \"messages.SendMultiMedia\",\n    \"messages.ForwardMessages\",\n    \"messages.SendInlineBotResult\",\n]);\nclass MessagePacker {\n    constructor(state, logger) {\n        this._state = state;\n        this._queue = [];\n        this._pendingStates = [];\n        this._ready = new Promise((resolve) => {\n            this.setReady = resolve;\n        });\n        this._log = logger;\n    }\n    values() {\n        return this._queue;\n    }\n    append(state, setReady = true, atStart = false) {\n        var _a, _b;\n        // We need to check if there is already a `USE_INVOKE_AFTER_WITH` request\n        if (state && USE_INVOKE_AFTER_WITH.has(state.request.className)) {\n            if (atStart) {\n                // Assign `after` for the previously first `USE_INVOKE_AFTER_WITH` request\n                for (let i = 0; i < this._queue.length; i++) {\n                    if (USE_INVOKE_AFTER_WITH.has((_a = this._queue[i]) === null || _a === void 0 ? void 0 : _a.request.className)) {\n                        this._queue[i].after = state;\n                        break;\n                    }\n                }\n            }\n            else {\n                // Assign after for the previous `USE_INVOKE_AFTER_WITH` request\n                for (let i = this._queue.length - 1; i >= 0; i--) {\n                    if (USE_INVOKE_AFTER_WITH.has((_b = this._queue[i]) === null || _b === void 0 ? void 0 : _b.request.className)) {\n                        state.after = this._queue[i];\n                        break;\n                    }\n                }\n            }\n        }\n        if (atStart) {\n            this._queue.unshift(state);\n        }\n        else {\n            this._queue.push(state);\n        }\n        if (setReady && this.setReady) {\n            this.setReady(true);\n        }\n        // 1658238041=MsgsAck, we don't care about MsgsAck here because they never resolve anyway.\n        if (state && state.request.CONSTRUCTOR_ID !== 1658238041) {\n            this._pendingStates.push(state);\n            state\n                .promise // Using finally causes triggering `unhandledrejection` event\n                .catch((err) => { })\n                .finally(() => {\n                this._pendingStates = this._pendingStates.filter((s) => s !== state);\n            });\n        }\n    }\n    prepend(states) {\n        states.reverse().forEach((state) => {\n            this.append(state, false, true);\n        });\n        if (this.setReady) {\n            this.setReady(true);\n        }\n    }\n    extend(states) {\n        states.forEach((state) => {\n            this.append(state, false);\n        });\n        if (this.setReady) {\n            this.setReady(true);\n        }\n    }\n    clear() {\n        this._queue = [];\n        this.append(undefined);\n    }\n    async wait() {\n        if (!this._queue.length) {\n            this._ready = new Promise((resolve) => {\n                this.setReady = resolve;\n            });\n            await this._ready;\n        }\n    }\n    async get() {\n        if (!this._queue[this._queue.length - 1]) {\n            this._queue = this._queue.filter(Boolean);\n            return undefined;\n        }\n        let data;\n        let buffer = new BinaryWriter_1.BinaryWriter(Buffer.alloc(0));\n        const batch = [];\n        let size = 0;\n        while (this._queue.length &&\n            batch.length <= core_1.MessageContainer.MAXIMUM_LENGTH) {\n            const state = this._queue.shift();\n            if (!state) {\n                continue;\n            }\n            size += state.data.length + core_2.TLMessage.SIZE_OVERHEAD;\n            if (size <= core_1.MessageContainer.MAXIMUM_SIZE) {\n                let afterId;\n                if (state.after) {\n                    afterId = state.after.msgId;\n                }\n                if (state.after) {\n                    afterId = state.after.msgId;\n                }\n                state.msgId = await this._state.writeDataAsMessage(buffer, state.data, state.request.classType === \"request\", afterId);\n                this._log.debug(`Assigned msgId = ${state.msgId} to ${state.request.className ||\n                    state.request.constructor.name}`);\n                batch.push(state);\n                continue;\n            }\n            if (batch.length) {\n                this._queue.unshift(state);\n                break;\n            }\n            this._log.warn(`Message payload for ${state.request.className || state.request.constructor.name} is too long ${state.data.length} and cannot be sent`);\n            state.promise.reject(\"Request Payload is too big\");\n            size = 0;\n        }\n        if (!batch.length) {\n            return null;\n        }\n        if (batch.length > 1) {\n            const b = Buffer.alloc(8);\n            b.writeUInt32LE(core_1.MessageContainer.CONSTRUCTOR_ID, 0);\n            b.writeInt32LE(batch.length, 4);\n            data = Buffer.concat([b, buffer.getValue()]);\n            buffer = new BinaryWriter_1.BinaryWriter(Buffer.alloc(0));\n            const containerId = await this._state.writeDataAsMessage(buffer, data, false);\n            for (const s of batch) {\n                s.containerId = containerId;\n            }\n        }\n        data = buffer.getValue();\n        return { batch, data };\n    }\n}\nexports.MessagePacker = MessagePacker;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}