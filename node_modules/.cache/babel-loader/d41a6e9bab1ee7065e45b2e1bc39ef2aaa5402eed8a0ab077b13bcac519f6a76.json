{"ast":null,"code":"'use strict';\n\nmodule.exports = writeFile;\nmodule.exports.sync = writeFileSync;\nmodule.exports._getTmpname = getTmpname; // for testing\n\nvar fs = require('graceful-fs');\nvar chain = require('slide').chain;\nvar MurmurHash3 = require('imurmurhash');\nvar extend = Object.assign || require('util')._extend;\nvar invocations = 0;\nfunction getTmpname(filename) {\n  return filename + '.' + MurmurHash3(__filename).hash(String(process.pid)).hash(String(++invocations)).result();\n}\nfunction writeFile(filename, data, options, callback) {\n  if (options instanceof Function) {\n    callback = options;\n    options = null;\n  }\n  if (!options) options = {};\n  fs.realpath(filename, function (_, realname) {\n    _writeFile(realname || filename, data, options, callback);\n  });\n}\nfunction _writeFile(filename, data, options, callback) {\n  var tmpfile = getTmpname(filename);\n  if (options.mode && options.chown) {\n    return thenWriteFile();\n  } else {\n    // Either mode or chown is not explicitly set\n    // Default behavior is to copy it from original file\n    return fs.stat(filename, function (err, stats) {\n      if (err || !stats) return thenWriteFile();\n      options = extend({}, options);\n      if (!options.mode) {\n        options.mode = stats.mode;\n      }\n      if (!options.chown && process.getuid) {\n        options.chown = {\n          uid: stats.uid,\n          gid: stats.gid\n        };\n      }\n      return thenWriteFile();\n    });\n  }\n  function thenWriteFile() {\n    chain([[writeFileAsync, tmpfile, data, options.mode, options.encoding || 'utf8'], options.chown && [fs, fs.chown, tmpfile, options.chown.uid, options.chown.gid], options.mode && [fs, fs.chmod, tmpfile, options.mode], [fs, fs.rename, tmpfile, filename]], function (err) {\n      err ? fs.unlink(tmpfile, function () {\n        callback(err);\n      }) : callback();\n    });\n  }\n\n  // doing this instead of `fs.writeFile` in order to get the ability to\n  // call `fsync`.\n  function writeFileAsync(file, data, mode, encoding, cb) {\n    fs.open(file, 'w', options.mode, function (err, fd) {\n      if (err) return cb(err);\n      if (Buffer.isBuffer(data)) {\n        return fs.write(fd, data, 0, data.length, 0, syncAndClose);\n      } else if (data != null) {\n        return fs.write(fd, String(data), 0, String(encoding), syncAndClose);\n      } else {\n        return syncAndClose();\n      }\n      function syncAndClose(err) {\n        if (err) return cb(err);\n        fs.fsync(fd, function (err) {\n          if (err) return cb(err);\n          fs.close(fd, cb);\n        });\n      }\n    });\n  }\n}\nfunction writeFileSync(filename, data, options) {\n  if (!options) options = {};\n  try {\n    filename = fs.realpathSync(filename);\n  } catch (ex) {\n    // it's ok, it'll happen on a not yet existing file\n  }\n  var tmpfile = getTmpname(filename);\n  try {\n    if (!options.mode || !options.chown) {\n      // Either mode or chown is not explicitly set\n      // Default behavior is to copy it from original file\n      try {\n        var stats = fs.statSync(filename);\n        options = extend({}, options);\n        if (!options.mode) {\n          options.mode = stats.mode;\n        }\n        if (!options.chown && process.getuid) {\n          options.chown = {\n            uid: stats.uid,\n            gid: stats.gid\n          };\n        }\n      } catch (ex) {\n        // ignore stat errors\n      }\n    }\n    var fd = fs.openSync(tmpfile, 'w', options.mode);\n    if (Buffer.isBuffer(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0);\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'));\n    }\n    fs.fsyncSync(fd);\n    fs.closeSync(fd);\n    if (options.chown) fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);\n    if (options.mode) fs.chmodSync(tmpfile, options.mode);\n    fs.renameSync(tmpfile, filename);\n  } catch (err) {\n    try {\n      fs.unlinkSync(tmpfile);\n    } catch (e) {}\n    throw err;\n  }\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}