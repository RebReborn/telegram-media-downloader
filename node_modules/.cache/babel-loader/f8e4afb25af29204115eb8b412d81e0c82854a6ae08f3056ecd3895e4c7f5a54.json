{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TelegramBaseClient = void 0;\nconst __1 = require(\"../\");\nconst Helpers_1 = require(\"../Helpers\");\nconst connection_1 = require(\"../network/connection\");\nconst sessions_1 = require(\"../sessions\");\nconst extensions_1 = require(\"../extensions\");\nconst tl_1 = require(\"../tl\");\nconst os_1 = __importDefault(require(\"./os\"));\nconst entityCache_1 = require(\"../entityCache\");\nconst markdown_1 = require(\"../extensions/markdown\");\nconst network_1 = require(\"../network\");\nconst AllTLObjects_1 = require(\"../tl/AllTLObjects\");\nconst TCPMTProxy_1 = require(\"../network/connection/TCPMTProxy\");\nconst async_mutex_1 = require(\"async-mutex\");\nconst Logger_1 = require(\"../extensions/Logger\");\nconst platform_1 = require(\"../platform\");\nconst Deferred_1 = __importDefault(require(\"../extensions/Deferred\"));\nconst EXPORTED_SENDER_RECONNECT_TIMEOUT = 1000; // 1 sec\nconst EXPORTED_SENDER_RELEASE_TIMEOUT = 30000; // 30 sec\nconst DEFAULT_DC_ID = 4;\nconst DEFAULT_IPV4_IP = platform_1.isNode ? \"149.154.167.91\" : \"vesta.web.telegram.org\";\nconst DEFAULT_IPV6_IP = \"2001:067c:04e8:f004:0000:0000:0000:000a\";\nconst clientParamsDefault = {\n  connection: platform_1.isNode ? connection_1.ConnectionTCPFull : connection_1.ConnectionTCPObfuscated,\n  networkSocket: platform_1.isNode ? extensions_1.PromisedNetSockets : extensions_1.PromisedWebSockets,\n  useIPV6: false,\n  timeout: 10,\n  requestRetries: 5,\n  connectionRetries: Infinity,\n  retryDelay: 1000,\n  downloadRetries: 5,\n  autoReconnect: true,\n  sequentialUpdates: false,\n  floodSleepThreshold: 60,\n  deviceModel: \"\",\n  systemVersion: \"\",\n  appVersion: \"\",\n  langCode: \"en\",\n  systemLangCode: \"en\",\n  _securityChecks: true,\n  useWSS: platform_1.isBrowser ? window.location.protocol == \"https:\" : false,\n  testServers: false\n};\nclass TelegramBaseClient {\n  constructor(session, apiId, apiHash, clientParams) {\n    /** The current gramJS version. */\n    this.__version__ = __1.version;\n    /** @hidden */\n    this._ALBUMS = new Map();\n    /** @hidden */\n    this._exportedSenderPromises = new Map();\n    /** @hidden */\n    this._exportedSenderReleaseTimeouts = new Map();\n    clientParams = Object.assign(Object.assign({}, clientParamsDefault), clientParams);\n    if (!apiId || !apiHash) {\n      throw new Error(\"Your API ID or Hash cannot be empty or undefined\");\n    }\n    if (clientParams.baseLogger) {\n      this._log = clientParams.baseLogger;\n    } else {\n      this._log = new extensions_1.Logger();\n    }\n    this._log.info(\"Running gramJS version \" + __1.version);\n    if (session && typeof session == \"string\") {\n      session = new sessions_1.StoreSession(session);\n    }\n    if (!(session instanceof sessions_1.Session)) {\n      throw new Error(\"Only StringSession and StoreSessions are supported currently :( \");\n    }\n    this._floodSleepThreshold = clientParams.floodSleepThreshold;\n    this.session = session;\n    this.apiId = apiId;\n    this.apiHash = apiHash;\n    this._useIPV6 = clientParams.useIPV6;\n    this._requestRetries = clientParams.requestRetries;\n    this._downloadRetries = clientParams.downloadRetries;\n    this._connectionRetries = clientParams.connectionRetries;\n    this._reconnectRetries = clientParams.reconnectRetries;\n    this._retryDelay = clientParams.retryDelay || 0;\n    this._timeout = clientParams.timeout;\n    this._autoReconnect = clientParams.autoReconnect;\n    this._proxy = clientParams.proxy;\n    this._semaphore = new async_mutex_1.Semaphore(clientParams.maxConcurrentDownloads || 1);\n    this.testServers = clientParams.testServers || false;\n    this.networkSocket = clientParams.networkSocket || extensions_1.PromisedNetSockets;\n    if (!(clientParams.connection instanceof Function)) {\n      throw new Error(\"Connection should be a class not an instance\");\n    }\n    this._connection = clientParams.connection;\n    let initProxy;\n    if (this._proxy && \"MTProxy\" in this._proxy) {\n      this._connection = TCPMTProxy_1.ConnectionTCPMTProxyAbridged;\n      initProxy = new tl_1.Api.InputClientProxy({\n        address: this._proxy.ip,\n        port: this._proxy.port\n      });\n    }\n    this._initRequest = new tl_1.Api.InitConnection({\n      apiId: this.apiId,\n      deviceModel: clientParams.deviceModel || os_1.default.type().toString() || \"Unknown\",\n      systemVersion: clientParams.systemVersion || os_1.default.release().toString() || \"1.0\",\n      appVersion: clientParams.appVersion || \"1.0\",\n      langCode: clientParams.langCode,\n      langPack: \"\",\n      // this should be left empty.\n      systemLangCode: clientParams.systemLangCode,\n      proxy: initProxy\n    });\n    this._eventBuilders = [];\n    this._floodWaitedRequests = {};\n    this._borrowedSenderPromises = {};\n    this._bot = undefined;\n    this._selfInputPeer = undefined;\n    this.useWSS = clientParams.useWSS;\n    this._securityChecks = !!clientParams.securityChecks;\n    if (this.useWSS && this._proxy) {\n      throw new Error(\"Cannot use SSL with proxies. You need to disable the useWSS client param in TelegramClient\");\n    }\n    this._entityCache = new entityCache_1.EntityCache();\n    // These will be set later\n    this._config = undefined;\n    this._loopStarted = false;\n    this._reconnecting = false;\n    this._destroyed = false;\n    this._isSwitchingDc = false;\n    this._connectedDeferred = new Deferred_1.default();\n    // parse mode\n    this._parseMode = markdown_1.MarkdownParser;\n  }\n  get floodSleepThreshold() {\n    return this._floodSleepThreshold;\n  }\n  set floodSleepThreshold(value) {\n    this._floodSleepThreshold = Math.min(value || 0, 24 * 60 * 60);\n  }\n  set maxConcurrentDownloads(value) {\n    // @ts-ignore\n    this._semaphore._value = value;\n  }\n  // region connecting\n  async _initSession() {\n    await this.session.load();\n    if (!this.session.serverAddress) {\n      this.session.setDC(DEFAULT_DC_ID, this._useIPV6 ? DEFAULT_IPV6_IP : DEFAULT_IPV4_IP, this.useWSS ? 443 : 80);\n    } else {\n      this._useIPV6 = this.session.serverAddress.includes(\":\");\n    }\n  }\n  get connected() {\n    return this._sender && this._sender.isConnected();\n  }\n  async disconnect() {\n    await this._disconnect();\n    await Promise.all(Object.values(this._exportedSenderPromises).map(promises => {\n      return Object.values(promises).map(promise => {\n        return promise && promise.then(sender => {\n          if (sender) {\n            return sender.disconnect();\n          }\n          return undefined;\n        });\n      });\n    }).flat());\n    Object.values(this._exportedSenderReleaseTimeouts).forEach(timeouts => {\n      Object.values(timeouts).forEach(releaseTimeout => {\n        clearTimeout(releaseTimeout);\n      });\n    });\n    this._exportedSenderPromises.clear();\n  }\n  get disconnected() {\n    return !this._sender || this._sender._disconnected;\n  }\n  async _disconnect() {\n    var _a;\n    await ((_a = this._sender) === null || _a === void 0 ? void 0 : _a.disconnect());\n  }\n  /**\n   * Disconnects all senders and removes all handlers\n   * Disconnect is safer as it will not remove your event handlers\n   */\n  async destroy() {\n    this._destroyed = true;\n    await Promise.all([this.disconnect(), ...Object.values(this._borrowedSenderPromises).map(promise => {\n      return promise.then(sender => sender.disconnect());\n    })]);\n    this._eventBuilders = [];\n  }\n  /** @hidden */\n  async _authKeyCallback(authKey, dcId) {\n    this.session.setAuthKey(authKey, dcId);\n    await this.session.save();\n  }\n  /** @hidden */\n  async _cleanupExportedSender(dcId) {\n    if (this.session.dcId !== dcId) {\n      this.session.setAuthKey(undefined, dcId);\n    }\n    let sender = await this._exportedSenderPromises.get(dcId);\n    this._exportedSenderPromises.delete(dcId);\n    await (sender === null || sender === void 0 ? void 0 : sender.disconnect());\n  }\n  /** @hidden */\n  async _connectSender(sender, dcId) {\n    // if we don't already have an auth key we want to use normal DCs not -1\n    const dc = await this.getDC(dcId, !!sender.authKey.getKey());\n    while (true) {\n      try {\n        await sender.connect(new this._connection({\n          ip: dc.ipAddress,\n          port: dc.port,\n          dcId: dcId,\n          loggers: this._log,\n          proxy: this._proxy,\n          testServers: this.testServers,\n          socket: this.networkSocket\n        }), false);\n        if (this.session.dcId !== dcId && !sender._authenticated) {\n          this._log.info(`Exporting authorization for data center ${dc.ipAddress} with layer ${AllTLObjects_1.LAYER}`);\n          const auth = await this.invoke(new tl_1.Api.auth.ExportAuthorization({\n            dcId: dcId\n          }));\n          this._initRequest.query = new tl_1.Api.auth.ImportAuthorization({\n            id: auth.id,\n            bytes: auth.bytes\n          });\n          const req = new tl_1.Api.InvokeWithLayer({\n            layer: AllTLObjects_1.LAYER,\n            query: this._initRequest\n          });\n          await sender.send(req);\n          sender._authenticated = true;\n        }\n        sender.dcId = dcId;\n        sender.userDisconnected = false;\n        return sender;\n      } catch (err) {\n        if (err.errorMessage === \"DC_ID_INVALID\") {\n          sender._authenticated = true;\n          sender.userDisconnected = false;\n          return sender;\n        }\n        if (this._errorHandler) {\n          await this._errorHandler(err);\n        } else if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\n          console.error(err);\n        }\n        await (0, Helpers_1.sleep)(1000);\n        await sender.disconnect();\n      }\n    }\n  }\n  /** @hidden */\n  async _borrowExportedSender(dcId, shouldReconnect, existingSender) {\n    if (!this._exportedSenderPromises.get(dcId) || shouldReconnect) {\n      this._exportedSenderPromises.set(dcId, this._connectSender(existingSender || this._createExportedSender(dcId), dcId));\n    }\n    let sender;\n    try {\n      sender = await this._exportedSenderPromises.get(dcId);\n      if (!sender.isConnected()) {\n        if (sender.isConnecting) {\n          await (0, Helpers_1.sleep)(EXPORTED_SENDER_RECONNECT_TIMEOUT);\n          return this._borrowExportedSender(dcId, false, sender);\n        } else {\n          return this._borrowExportedSender(dcId, true, sender);\n        }\n      }\n    } catch (err) {\n      if (this._errorHandler) {\n        await this._errorHandler(err);\n      }\n      if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\n        console.error(err);\n      }\n      return this._borrowExportedSender(dcId, true);\n    }\n    if (this._exportedSenderReleaseTimeouts.get(dcId)) {\n      clearTimeout(this._exportedSenderReleaseTimeouts.get(dcId));\n      this._exportedSenderReleaseTimeouts.delete(dcId);\n    }\n    this._exportedSenderReleaseTimeouts.set(dcId, setTimeout(() => {\n      this._exportedSenderReleaseTimeouts.delete(dcId);\n      if (sender._pendingState.values().length) {\n        console.log(\"sender already has some hanging states. reconnecting\");\n        sender._reconnect();\n        this._borrowExportedSender(dcId, false, sender);\n      } else {\n        sender.disconnect();\n      }\n    }, EXPORTED_SENDER_RELEASE_TIMEOUT));\n    return sender;\n  }\n  /** @hidden */\n  _createExportedSender(dcId) {\n    return new network_1.MTProtoSender(this.session.getAuthKey(dcId), {\n      logger: this._log,\n      dcId,\n      retries: this._connectionRetries,\n      delay: this._retryDelay,\n      autoReconnect: this._autoReconnect,\n      connectTimeout: this._timeout,\n      authKeyCallback: this._authKeyCallback.bind(this),\n      isMainSender: dcId === this.session.dcId,\n      onConnectionBreak: this._cleanupExportedSender.bind(this),\n      client: this,\n      securityChecks: this._securityChecks,\n      _exportedSenderPromises: this._exportedSenderPromises,\n      reconnectRetries: this._reconnectRetries\n    });\n  }\n  /** @hidden */\n  getSender(dcId) {\n    return dcId ? this._borrowExportedSender(dcId) : Promise.resolve(this._sender);\n  }\n  // endregion\n  async getDC(dcId, download) {\n    throw new Error(\"Cannot be called from here!\");\n  }\n  invoke(request) {\n    throw new Error(\"Cannot be called from here!\");\n  }\n  setLogLevel(level) {\n    this._log.setLevel(level);\n  }\n  get logger() {\n    return this._log;\n  }\n  /**\n   * Custom error handler for the client\n   * @example\n   * ```ts\n   * client.onError = async (error)=>{\n   *         console.log(\"error is\",error)\n   *     }\n   * ```\n   */\n  set onError(handler) {\n    this._errorHandler = async error => {\n      try {\n        await handler(error);\n      } catch (e) {\n        if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\n          e.message = `Error ${e.message} thrown while handling top-level error: ${error.message}`;\n          console.error(e);\n        }\n      }\n    };\n  }\n}\nexports.TelegramBaseClient = TelegramBaseClient;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","TelegramBaseClient","__1","require","Helpers_1","connection_1","sessions_1","extensions_1","tl_1","os_1","entityCache_1","markdown_1","network_1","AllTLObjects_1","TCPMTProxy_1","async_mutex_1","Logger_1","platform_1","Deferred_1","EXPORTED_SENDER_RECONNECT_TIMEOUT","EXPORTED_SENDER_RELEASE_TIMEOUT","DEFAULT_DC_ID","DEFAULT_IPV4_IP","isNode","DEFAULT_IPV6_IP","clientParamsDefault","connection","ConnectionTCPFull","ConnectionTCPObfuscated","networkSocket","PromisedNetSockets","PromisedWebSockets","useIPV6","timeout","requestRetries","connectionRetries","Infinity","retryDelay","downloadRetries","autoReconnect","sequentialUpdates","floodSleepThreshold","deviceModel","systemVersion","appVersion","langCode","systemLangCode","_securityChecks","useWSS","isBrowser","window","location","protocol","testServers","constructor","session","apiId","apiHash","clientParams","__version__","version","_ALBUMS","Map","_exportedSenderPromises","_exportedSenderReleaseTimeouts","assign","Error","baseLogger","_log","Logger","info","StoreSession","Session","_floodSleepThreshold","_useIPV6","_requestRetries","_downloadRetries","_connectionRetries","_reconnectRetries","reconnectRetries","_retryDelay","_timeout","_autoReconnect","_proxy","proxy","_semaphore","Semaphore","maxConcurrentDownloads","Function","_connection","initProxy","ConnectionTCPMTProxyAbridged","Api","InputClientProxy","address","ip","port","_initRequest","InitConnection","default","type","toString","release","langPack","_eventBuilders","_floodWaitedRequests","_borrowedSenderPromises","_bot","undefined","_selfInputPeer","securityChecks","_entityCache","EntityCache","_config","_loopStarted","_reconnecting","_destroyed","_isSwitchingDc","_connectedDeferred","_parseMode","MarkdownParser","Math","min","_value","_initSession","load","serverAddress","setDC","includes","connected","_sender","isConnected","disconnect","_disconnect","Promise","all","values","map","promises","promise","then","sender","flat","forEach","timeouts","releaseTimeout","clearTimeout","clear","disconnected","_disconnected","_a","destroy","_authKeyCallback","authKey","dcId","setAuthKey","save","_cleanupExportedSender","get","delete","_connectSender","dc","getDC","getKey","connect","ipAddress","loggers","socket","_authenticated","LAYER","auth","invoke","ExportAuthorization","query","ImportAuthorization","id","bytes","req","InvokeWithLayer","layer","send","userDisconnected","err","errorMessage","_errorHandler","canSend","LogLevel","ERROR","console","error","sleep","_borrowExportedSender","shouldReconnect","existingSender","set","_createExportedSender","isConnecting","setTimeout","_pendingState","length","log","_reconnect","MTProtoSender","getAuthKey","logger","retries","delay","connectTimeout","authKeyCallback","bind","isMainSender","onConnectionBreak","client","getSender","resolve","download","request","setLogLevel","level","setLevel","onError","handler","e","message"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/client/telegramBaseClient.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TelegramBaseClient = void 0;\nconst __1 = require(\"../\");\nconst Helpers_1 = require(\"../Helpers\");\nconst connection_1 = require(\"../network/connection\");\nconst sessions_1 = require(\"../sessions\");\nconst extensions_1 = require(\"../extensions\");\nconst tl_1 = require(\"../tl\");\nconst os_1 = __importDefault(require(\"./os\"));\nconst entityCache_1 = require(\"../entityCache\");\nconst markdown_1 = require(\"../extensions/markdown\");\nconst network_1 = require(\"../network\");\nconst AllTLObjects_1 = require(\"../tl/AllTLObjects\");\nconst TCPMTProxy_1 = require(\"../network/connection/TCPMTProxy\");\nconst async_mutex_1 = require(\"async-mutex\");\nconst Logger_1 = require(\"../extensions/Logger\");\nconst platform_1 = require(\"../platform\");\nconst Deferred_1 = __importDefault(require(\"../extensions/Deferred\"));\nconst EXPORTED_SENDER_RECONNECT_TIMEOUT = 1000; // 1 sec\nconst EXPORTED_SENDER_RELEASE_TIMEOUT = 30000; // 30 sec\nconst DEFAULT_DC_ID = 4;\nconst DEFAULT_IPV4_IP = platform_1.isNode ? \"149.154.167.91\" : \"vesta.web.telegram.org\";\nconst DEFAULT_IPV6_IP = \"2001:067c:04e8:f004:0000:0000:0000:000a\";\nconst clientParamsDefault = {\n    connection: platform_1.isNode ? connection_1.ConnectionTCPFull : connection_1.ConnectionTCPObfuscated,\n    networkSocket: platform_1.isNode ? extensions_1.PromisedNetSockets : extensions_1.PromisedWebSockets,\n    useIPV6: false,\n    timeout: 10,\n    requestRetries: 5,\n    connectionRetries: Infinity,\n    retryDelay: 1000,\n    downloadRetries: 5,\n    autoReconnect: true,\n    sequentialUpdates: false,\n    floodSleepThreshold: 60,\n    deviceModel: \"\",\n    systemVersion: \"\",\n    appVersion: \"\",\n    langCode: \"en\",\n    systemLangCode: \"en\",\n    _securityChecks: true,\n    useWSS: platform_1.isBrowser ? window.location.protocol == \"https:\" : false,\n    testServers: false,\n};\nclass TelegramBaseClient {\n    constructor(session, apiId, apiHash, clientParams) {\n        /** The current gramJS version. */\n        this.__version__ = __1.version;\n        /** @hidden */\n        this._ALBUMS = new Map();\n        /** @hidden */\n        this._exportedSenderPromises = new Map();\n        /** @hidden */\n        this._exportedSenderReleaseTimeouts = new Map();\n        clientParams = Object.assign(Object.assign({}, clientParamsDefault), clientParams);\n        if (!apiId || !apiHash) {\n            throw new Error(\"Your API ID or Hash cannot be empty or undefined\");\n        }\n        if (clientParams.baseLogger) {\n            this._log = clientParams.baseLogger;\n        }\n        else {\n            this._log = new extensions_1.Logger();\n        }\n        this._log.info(\"Running gramJS version \" + __1.version);\n        if (session && typeof session == \"string\") {\n            session = new sessions_1.StoreSession(session);\n        }\n        if (!(session instanceof sessions_1.Session)) {\n            throw new Error(\"Only StringSession and StoreSessions are supported currently :( \");\n        }\n        this._floodSleepThreshold = clientParams.floodSleepThreshold;\n        this.session = session;\n        this.apiId = apiId;\n        this.apiHash = apiHash;\n        this._useIPV6 = clientParams.useIPV6;\n        this._requestRetries = clientParams.requestRetries;\n        this._downloadRetries = clientParams.downloadRetries;\n        this._connectionRetries = clientParams.connectionRetries;\n        this._reconnectRetries = clientParams.reconnectRetries;\n        this._retryDelay = clientParams.retryDelay || 0;\n        this._timeout = clientParams.timeout;\n        this._autoReconnect = clientParams.autoReconnect;\n        this._proxy = clientParams.proxy;\n        this._semaphore = new async_mutex_1.Semaphore(clientParams.maxConcurrentDownloads || 1);\n        this.testServers = clientParams.testServers || false;\n        this.networkSocket = clientParams.networkSocket || extensions_1.PromisedNetSockets;\n        if (!(clientParams.connection instanceof Function)) {\n            throw new Error(\"Connection should be a class not an instance\");\n        }\n        this._connection = clientParams.connection;\n        let initProxy;\n        if (this._proxy && \"MTProxy\" in this._proxy) {\n            this._connection = TCPMTProxy_1.ConnectionTCPMTProxyAbridged;\n            initProxy = new tl_1.Api.InputClientProxy({\n                address: this._proxy.ip,\n                port: this._proxy.port,\n            });\n        }\n        this._initRequest = new tl_1.Api.InitConnection({\n            apiId: this.apiId,\n            deviceModel: clientParams.deviceModel || os_1.default.type().toString() || \"Unknown\",\n            systemVersion: clientParams.systemVersion || os_1.default.release().toString() || \"1.0\",\n            appVersion: clientParams.appVersion || \"1.0\",\n            langCode: clientParams.langCode,\n            langPack: \"\", // this should be left empty.\n            systemLangCode: clientParams.systemLangCode,\n            proxy: initProxy,\n        });\n        this._eventBuilders = [];\n        this._floodWaitedRequests = {};\n        this._borrowedSenderPromises = {};\n        this._bot = undefined;\n        this._selfInputPeer = undefined;\n        this.useWSS = clientParams.useWSS;\n        this._securityChecks = !!clientParams.securityChecks;\n        if (this.useWSS && this._proxy) {\n            throw new Error(\"Cannot use SSL with proxies. You need to disable the useWSS client param in TelegramClient\");\n        }\n        this._entityCache = new entityCache_1.EntityCache();\n        // These will be set later\n        this._config = undefined;\n        this._loopStarted = false;\n        this._reconnecting = false;\n        this._destroyed = false;\n        this._isSwitchingDc = false;\n        this._connectedDeferred = new Deferred_1.default();\n        // parse mode\n        this._parseMode = markdown_1.MarkdownParser;\n    }\n    get floodSleepThreshold() {\n        return this._floodSleepThreshold;\n    }\n    set floodSleepThreshold(value) {\n        this._floodSleepThreshold = Math.min(value || 0, 24 * 60 * 60);\n    }\n    set maxConcurrentDownloads(value) {\n        // @ts-ignore\n        this._semaphore._value = value;\n    }\n    // region connecting\n    async _initSession() {\n        await this.session.load();\n        if (!this.session.serverAddress) {\n            this.session.setDC(DEFAULT_DC_ID, this._useIPV6 ? DEFAULT_IPV6_IP : DEFAULT_IPV4_IP, this.useWSS ? 443 : 80);\n        }\n        else {\n            this._useIPV6 = this.session.serverAddress.includes(\":\");\n        }\n    }\n    get connected() {\n        return this._sender && this._sender.isConnected();\n    }\n    async disconnect() {\n        await this._disconnect();\n        await Promise.all(Object.values(this._exportedSenderPromises)\n            .map((promises) => {\n            return Object.values(promises).map((promise) => {\n                return (promise &&\n                    promise.then((sender) => {\n                        if (sender) {\n                            return sender.disconnect();\n                        }\n                        return undefined;\n                    }));\n            });\n        })\n            .flat());\n        Object.values(this._exportedSenderReleaseTimeouts).forEach((timeouts) => {\n            Object.values(timeouts).forEach((releaseTimeout) => {\n                clearTimeout(releaseTimeout);\n            });\n        });\n        this._exportedSenderPromises.clear();\n    }\n    get disconnected() {\n        return !this._sender || this._sender._disconnected;\n    }\n    async _disconnect() {\n        var _a;\n        await ((_a = this._sender) === null || _a === void 0 ? void 0 : _a.disconnect());\n    }\n    /**\n     * Disconnects all senders and removes all handlers\n     * Disconnect is safer as it will not remove your event handlers\n     */\n    async destroy() {\n        this._destroyed = true;\n        await Promise.all([\n            this.disconnect(),\n            ...Object.values(this._borrowedSenderPromises).map((promise) => {\n                return promise.then((sender) => sender.disconnect());\n            }),\n        ]);\n        this._eventBuilders = [];\n    }\n    /** @hidden */\n    async _authKeyCallback(authKey, dcId) {\n        this.session.setAuthKey(authKey, dcId);\n        await this.session.save();\n    }\n    /** @hidden */\n    async _cleanupExportedSender(dcId) {\n        if (this.session.dcId !== dcId) {\n            this.session.setAuthKey(undefined, dcId);\n        }\n        let sender = await this._exportedSenderPromises.get(dcId);\n        this._exportedSenderPromises.delete(dcId);\n        await (sender === null || sender === void 0 ? void 0 : sender.disconnect());\n    }\n    /** @hidden */\n    async _connectSender(sender, dcId) {\n        // if we don't already have an auth key we want to use normal DCs not -1\n        const dc = await this.getDC(dcId, !!sender.authKey.getKey());\n        while (true) {\n            try {\n                await sender.connect(new this._connection({\n                    ip: dc.ipAddress,\n                    port: dc.port,\n                    dcId: dcId,\n                    loggers: this._log,\n                    proxy: this._proxy,\n                    testServers: this.testServers,\n                    socket: this.networkSocket,\n                }), false);\n                if (this.session.dcId !== dcId && !sender._authenticated) {\n                    this._log.info(`Exporting authorization for data center ${dc.ipAddress} with layer ${AllTLObjects_1.LAYER}`);\n                    const auth = await this.invoke(new tl_1.Api.auth.ExportAuthorization({ dcId: dcId }));\n                    this._initRequest.query = new tl_1.Api.auth.ImportAuthorization({\n                        id: auth.id,\n                        bytes: auth.bytes,\n                    });\n                    const req = new tl_1.Api.InvokeWithLayer({\n                        layer: AllTLObjects_1.LAYER,\n                        query: this._initRequest,\n                    });\n                    await sender.send(req);\n                    sender._authenticated = true;\n                }\n                sender.dcId = dcId;\n                sender.userDisconnected = false;\n                return sender;\n            }\n            catch (err) {\n                if (err.errorMessage === \"DC_ID_INVALID\") {\n                    sender._authenticated = true;\n                    sender.userDisconnected = false;\n                    return sender;\n                }\n                if (this._errorHandler) {\n                    await this._errorHandler(err);\n                }\n                else if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\n                    console.error(err);\n                }\n                await (0, Helpers_1.sleep)(1000);\n                await sender.disconnect();\n            }\n        }\n    }\n    /** @hidden */\n    async _borrowExportedSender(dcId, shouldReconnect, existingSender) {\n        if (!this._exportedSenderPromises.get(dcId) || shouldReconnect) {\n            this._exportedSenderPromises.set(dcId, this._connectSender(existingSender || this._createExportedSender(dcId), dcId));\n        }\n        let sender;\n        try {\n            sender = await this._exportedSenderPromises.get(dcId);\n            if (!sender.isConnected()) {\n                if (sender.isConnecting) {\n                    await (0, Helpers_1.sleep)(EXPORTED_SENDER_RECONNECT_TIMEOUT);\n                    return this._borrowExportedSender(dcId, false, sender);\n                }\n                else {\n                    return this._borrowExportedSender(dcId, true, sender);\n                }\n            }\n        }\n        catch (err) {\n            if (this._errorHandler) {\n                await this._errorHandler(err);\n            }\n            if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\n                console.error(err);\n            }\n            return this._borrowExportedSender(dcId, true);\n        }\n        if (this._exportedSenderReleaseTimeouts.get(dcId)) {\n            clearTimeout(this._exportedSenderReleaseTimeouts.get(dcId));\n            this._exportedSenderReleaseTimeouts.delete(dcId);\n        }\n        this._exportedSenderReleaseTimeouts.set(dcId, setTimeout(() => {\n            this._exportedSenderReleaseTimeouts.delete(dcId);\n            if (sender._pendingState.values().length) {\n                console.log(\"sender already has some hanging states. reconnecting\");\n                sender._reconnect();\n                this._borrowExportedSender(dcId, false, sender);\n            }\n            else {\n                sender.disconnect();\n            }\n        }, EXPORTED_SENDER_RELEASE_TIMEOUT));\n        return sender;\n    }\n    /** @hidden */\n    _createExportedSender(dcId) {\n        return new network_1.MTProtoSender(this.session.getAuthKey(dcId), {\n            logger: this._log,\n            dcId,\n            retries: this._connectionRetries,\n            delay: this._retryDelay,\n            autoReconnect: this._autoReconnect,\n            connectTimeout: this._timeout,\n            authKeyCallback: this._authKeyCallback.bind(this),\n            isMainSender: dcId === this.session.dcId,\n            onConnectionBreak: this._cleanupExportedSender.bind(this),\n            client: this,\n            securityChecks: this._securityChecks,\n            _exportedSenderPromises: this._exportedSenderPromises,\n            reconnectRetries: this._reconnectRetries,\n        });\n    }\n    /** @hidden */\n    getSender(dcId) {\n        return dcId\n            ? this._borrowExportedSender(dcId)\n            : Promise.resolve(this._sender);\n    }\n    // endregion\n    async getDC(dcId, download) {\n        throw new Error(\"Cannot be called from here!\");\n    }\n    invoke(request) {\n        throw new Error(\"Cannot be called from here!\");\n    }\n    setLogLevel(level) {\n        this._log.setLevel(level);\n    }\n    get logger() {\n        return this._log;\n    }\n    /**\n     * Custom error handler for the client\n     * @example\n     * ```ts\n     * client.onError = async (error)=>{\n     *         console.log(\"error is\",error)\n     *     }\n     * ```\n     */\n    set onError(handler) {\n        this._errorHandler = async (error) => {\n            try {\n                await handler(error);\n            }\n            catch (e) {\n                if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\n                    e.message = `Error ${e.message} thrown while handling top-level error: ${error.message}`;\n                    console.error(e);\n                }\n            }\n        };\n    }\n}\nexports.TelegramBaseClient = TelegramBaseClient;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}