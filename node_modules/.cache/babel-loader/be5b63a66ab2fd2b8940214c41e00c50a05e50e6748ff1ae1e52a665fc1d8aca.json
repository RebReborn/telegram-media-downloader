{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.variableSnakeToCamelCase = exports.snakeToCamelCase = exports.CORE_TYPES = exports.fromLine = exports.parseTl = exports.findAll = void 0;\nexports.serializeBytes = serializeBytes;\nexports.serializeDate = serializeDate;\nexports.buildArgConfig = buildArgConfig;\nconst Helpers_1 = require(\"../Helpers\");\nconst snakeToCamelCase = name => {\n  const result = name.replace(/(?:^|_)([a-z])/g, (_, g) => g.toUpperCase());\n  return result.replace(/_/g, \"\");\n};\nexports.snakeToCamelCase = snakeToCamelCase;\nconst variableSnakeToCamelCase = str => str.replace(/([-_][a-z])/g, group => group.toUpperCase().replace(\"-\", \"\").replace(\"_\", \"\"));\nexports.variableSnakeToCamelCase = variableSnakeToCamelCase;\nconst CORE_TYPES = new Set([0xbc799737,\n// boolFalse#bc799737 = Bool;\n0x997275b5,\n// boolTrue#997275b5 = Bool;\n0x3fedd339,\n// true#3fedd339 = True;\n0xc4b9f9bb,\n// error#c4b9f9bb code:int text:string = Error;\n0x56730bcc // null#56730bcc = Null;\n]);\nexports.CORE_TYPES = CORE_TYPES;\nconst AUTH_KEY_TYPES = new Set([0x05162463,\n// resPQ,\n0x83c95aec,\n// p_q_inner_data\n0xa9f55f95,\n// p_q_inner_data_dc\n0x3c6a84d4,\n// p_q_inner_data_temp\n0x56fddf88,\n// p_q_inner_data_temp_dc\n0xd0e8075c,\n// server_DH_params_ok\n0xb5890dba,\n// server_DH_inner_data\n0x6643b654,\n// client_DH_inner_data\n0xd712e4be,\n// req_DH_params\n0xf5045f1f,\n// set_client_DH_params\n0x3072cfa1 // gzip_packed\n]);\nconst fromLine = (line, isFunction) => {\n  const match = line.match(/([\\w.]+)(?:#([0-9a-fA-F]+))?(?:\\s{?\\w+:[\\w\\d<>#.?!]+}?)*\\s=\\s([\\w\\d<>#.?]+);$/);\n  if (!match) {\n    // Probably \"vector#1cb5c415 {t:Type} # [ t ] = Vector t;\"\n    throw new Error(`Cannot parse TLObject ${line}`);\n  }\n  const argsMatch = findAll(/({)?(\\w+):([\\w\\d<>#.?!]+)}?/, line);\n  const currentConfig = {\n    name: match[1],\n    constructorId: parseInt(match[2], 16),\n    argsConfig: {},\n    subclassOfId: (0, Helpers_1.crc32)(match[3]),\n    result: match[3],\n    isFunction: isFunction,\n    namespace: undefined\n  };\n  if (!currentConfig.constructorId) {\n    const hexId = \"\";\n    let args;\n    if (Object.values(currentConfig.argsConfig).length) {\n      args = ` ${Object.keys(currentConfig.argsConfig).map(arg => arg.toString()).join(\" \")}`;\n    } else {\n      args = \"\";\n    }\n    const representation = `${currentConfig.name}${hexId}${args} = ${currentConfig.result}`.replace(/(:|\\?)bytes /g, \"$1string \").replace(/</g, \" \").replace(/>|{|}/g, \"\").replace(/ \\w+:flags(\\d+)?\\.\\d+\\?true/g, \"\");\n    if (currentConfig.name === \"inputMediaInvoice\") {\n      // eslint-disable-next-line no-empty\n      if (currentConfig.name === \"inputMediaInvoice\") {}\n    }\n    currentConfig.constructorId = (0, Helpers_1.crc32)(Buffer.from(representation, \"utf8\"));\n  }\n  for (const [brace, name, argType] of argsMatch) {\n    if (brace === undefined) {\n      // @ts-ignore\n      currentConfig.argsConfig[variableSnakeToCamelCase(name)] = buildArgConfig(name, argType);\n    }\n  }\n  if (currentConfig.name.includes(\".\")) {\n    [currentConfig.namespace, currentConfig.name] = currentConfig.name.split(/\\.(.+)/);\n  }\n  currentConfig.name = snakeToCamelCase(currentConfig.name);\n  /*\n  for (const arg in currentConfig.argsConfig){\n    if (currentConfig.argsConfig.hasOwnProperty(arg)){\n      if (currentConfig.argsConfig[arg].flagIndicator){\n        delete  currentConfig.argsConfig[arg]\n      }\n    }\n  }*/\n  return currentConfig;\n};\nexports.fromLine = fromLine;\nfunction buildArgConfig(name, argType) {\n  name = name === \"self\" ? \"is_self\" : name;\n  // Default values\n  const currentConfig = {\n    isVector: false,\n    isFlag: false,\n    skipConstructorId: false,\n    flagName: null,\n    flagIndex: -1,\n    flagIndicator: true,\n    type: null,\n    useVectorId: null\n  };\n  // Special case: some types can be inferred, which makes it\n  // less annoying to type. Currently the only type that can\n  // be inferred is if the name is 'random_id', to which a\n  // random ID will be assigned if left as None (the default)\n  const canBeInferred = name === \"random_id\";\n  // The type can be an indicator that other arguments will be flags\n  if (argType !== \"#\") {\n    currentConfig.flagIndicator = false;\n    // Strip the exclamation mark always to have only the name\n    currentConfig.type = argType.replace(/^!+/, \"\");\n    // The type may be a flag (flags.IDX?REAL_TYPE)\n    // Note that 'flags' is NOT the flags name; this\n    // is determined by a previous argument\n    // However, we assume that the argument will always be starts with 'flags'\n    // @ts-ignore\n    const flagMatch = currentConfig.type.match(/(flags(?:\\d+)?).(\\d+)\\?([\\w<>.]+)/);\n    if (flagMatch) {\n      currentConfig.isFlag = true;\n      // As of layer 140, flagName can be \"flags\" or \"flags2\"\n      currentConfig.flagName = flagMatch[1];\n      currentConfig.flagIndex = Number(flagMatch[2]);\n      // Update the type to match the exact type, not the \"flagged\" one\n      currentConfig.type = flagMatch[3];\n    }\n    // Then check if the type is a Vector<REAL_TYPE>\n    // @ts-ignore\n    const vectorMatch = currentConfig.type.match(/[Vv]ector<([\\w\\d.]+)>/);\n    if (vectorMatch) {\n      currentConfig.isVector = true;\n      // If the type's first letter is not uppercase, then\n      // it is a constructor and we use (read/write) its ID.\n      // @ts-ignore\n      currentConfig.useVectorId = currentConfig.type.charAt(0) === \"V\";\n      // Update the type to match the one inside the vector\n      [, currentConfig.type] = vectorMatch;\n    }\n    // See use_vector_id. An example of such case is ipPort in\n    // help.configSpecial\n    // @ts-ignore\n    if (/^[a-z]$/.test(currentConfig.type.split(\".\").pop().charAt(0))) {\n      currentConfig.skipConstructorId = true;\n    }\n    // The name may contain \"date\" in it, if this is the case and\n    // the type is \"int\", we can safely assume that this should be\n    // treated as a \"date\" object. Note that this is not a valid\n    // Telegram object, but it's easier to work with\n    // if (\n    //     this.type === 'int' &&\n    //     (/(\\b|_)([dr]ate|until|since)(\\b|_)/.test(name) ||\n    //         ['expires', 'expires_at', 'was_online'].includes(name))\n    // ) {\n    //     this.type = 'date';\n    // }\n  }\n  // workaround\n  if (currentConfig.type == \"future_salt\") {\n    currentConfig.type = \"FutureSalt\";\n  }\n  return currentConfig;\n}\nconst parseTl = function* (content, layer, methods = [], ignoreIds = CORE_TYPES) {\n  const methodInfo = (methods || []).reduce((o, m) => Object.assign(Object.assign({}, o), {\n    [m.name]: m\n  }), {});\n  const objAll = [];\n  const objByName = {};\n  const objByType = {};\n  const file = content;\n  let isFunction = false;\n  for (let line of file.split(\"\\n\")) {\n    const commentIndex = line.indexOf(\"//\");\n    if (commentIndex !== -1) {\n      line = line.slice(0, commentIndex);\n    }\n    line = line.trim();\n    if (!line) {\n      continue;\n    }\n    const match = line.match(/---(\\w+)---/);\n    if (match) {\n      const [, followingTypes] = match;\n      isFunction = followingTypes === \"functions\";\n      continue;\n    }\n    try {\n      const result = fromLine(line, isFunction);\n      if (ignoreIds.has(result.constructorId)) {\n        continue;\n      }\n      objAll.push(result);\n      if (!result.isFunction) {\n        if (!objByType[result.result]) {\n          objByType[result.result] = [];\n        }\n        objByName[result.name] = result;\n        objByType[result.result].push(result);\n      }\n    } catch (e) {\n      if (!e.toString().includes(\"vector#1cb5c415\")) {\n        throw e;\n      }\n    }\n  }\n  // Once all objects have been parsed, replace the\n  // string type from the arguments with references\n  for (const obj of objAll) {\n    if (AUTH_KEY_TYPES.has(obj.constructorId)) {\n      for (const arg in obj.argsConfig) {\n        if (obj.argsConfig[arg].type === \"string\") {\n          obj.argsConfig[arg].type = \"bytes\";\n        }\n      }\n    }\n  }\n  for (const obj of objAll) {\n    yield obj;\n  }\n};\nexports.parseTl = parseTl;\nconst findAll = (regex, str, matches = []) => {\n  if (!regex.flags.includes(\"g\")) {\n    regex = new RegExp(regex.source, \"g\");\n  }\n  const res = regex.exec(str);\n  if (res) {\n    matches.push(res.slice(1));\n    findAll(regex, str, matches);\n  }\n  return matches;\n};\nexports.findAll = findAll;\nfunction serializeBytes(data) {\n  if (!(data instanceof Buffer)) {\n    if (typeof data == \"string\") {\n      data = Buffer.from(data);\n    } else {\n      throw Error(`Bytes or str expected, not ${data.constructor.name}`);\n    }\n  }\n  const r = [];\n  let padding;\n  if (data.length < 254) {\n    padding = (data.length + 1) % 4;\n    if (padding !== 0) {\n      padding = 4 - padding;\n    }\n    r.push(Buffer.from([data.length]));\n    r.push(data);\n  } else {\n    padding = data.length % 4;\n    if (padding !== 0) {\n      padding = 4 - padding;\n    }\n    r.push(Buffer.from([254, data.length % 256, (data.length >> 8) % 256, (data.length >> 16) % 256]));\n    r.push(data);\n  }\n  r.push(Buffer.alloc(padding).fill(0));\n  return Buffer.concat(r);\n}\nfunction serializeDate(dt) {\n  if (!dt) {\n    return Buffer.alloc(4).fill(0);\n  }\n  if (dt instanceof Date) {\n    dt = Math.floor((Date.now() - dt.getTime()) / 1000);\n  }\n  if (typeof dt == \"number\") {\n    const t = Buffer.alloc(4);\n    t.writeInt32LE(dt, 0);\n    return t;\n  }\n  throw Error(`Cannot interpret \"${dt}\" as a date`);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","variableSnakeToCamelCase","snakeToCamelCase","CORE_TYPES","fromLine","parseTl","findAll","serializeBytes","serializeDate","buildArgConfig","Helpers_1","require","name","result","replace","_","g","toUpperCase","str","group","Set","AUTH_KEY_TYPES","line","isFunction","match","Error","argsMatch","currentConfig","constructorId","parseInt","argsConfig","subclassOfId","crc32","namespace","undefined","hexId","args","values","length","keys","map","arg","toString","join","representation","Buffer","from","brace","argType","includes","split","isVector","isFlag","skipConstructorId","flagName","flagIndex","flagIndicator","type","useVectorId","canBeInferred","flagMatch","Number","vectorMatch","charAt","test","pop","content","layer","methods","ignoreIds","methodInfo","reduce","o","m","assign","objAll","objByName","objByType","file","commentIndex","indexOf","slice","trim","followingTypes","has","push","e","obj","regex","matches","flags","RegExp","source","res","exec","data","constructor","r","padding","alloc","fill","concat","dt","Date","Math","floor","now","getTime","t","writeInt32LE"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/tl/generationHelpers.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.variableSnakeToCamelCase = exports.snakeToCamelCase = exports.CORE_TYPES = exports.fromLine = exports.parseTl = exports.findAll = void 0;\nexports.serializeBytes = serializeBytes;\nexports.serializeDate = serializeDate;\nexports.buildArgConfig = buildArgConfig;\nconst Helpers_1 = require(\"../Helpers\");\nconst snakeToCamelCase = (name) => {\n    const result = name.replace(/(?:^|_)([a-z])/g, (_, g) => g.toUpperCase());\n    return result.replace(/_/g, \"\");\n};\nexports.snakeToCamelCase = snakeToCamelCase;\nconst variableSnakeToCamelCase = (str) => str.replace(/([-_][a-z])/g, (group) => group.toUpperCase().replace(\"-\", \"\").replace(\"_\", \"\"));\nexports.variableSnakeToCamelCase = variableSnakeToCamelCase;\nconst CORE_TYPES = new Set([\n    0xbc799737, // boolFalse#bc799737 = Bool;\n    0x997275b5, // boolTrue#997275b5 = Bool;\n    0x3fedd339, // true#3fedd339 = True;\n    0xc4b9f9bb, // error#c4b9f9bb code:int text:string = Error;\n    0x56730bcc, // null#56730bcc = Null;\n]);\nexports.CORE_TYPES = CORE_TYPES;\nconst AUTH_KEY_TYPES = new Set([\n    0x05162463, // resPQ,\n    0x83c95aec, // p_q_inner_data\n    0xa9f55f95, // p_q_inner_data_dc\n    0x3c6a84d4, // p_q_inner_data_temp\n    0x56fddf88, // p_q_inner_data_temp_dc\n    0xd0e8075c, // server_DH_params_ok\n    0xb5890dba, // server_DH_inner_data\n    0x6643b654, // client_DH_inner_data\n    0xd712e4be, // req_DH_params\n    0xf5045f1f, // set_client_DH_params\n    0x3072cfa1, // gzip_packed\n]);\nconst fromLine = (line, isFunction) => {\n    const match = line.match(/([\\w.]+)(?:#([0-9a-fA-F]+))?(?:\\s{?\\w+:[\\w\\d<>#.?!]+}?)*\\s=\\s([\\w\\d<>#.?]+);$/);\n    if (!match) {\n        // Probably \"vector#1cb5c415 {t:Type} # [ t ] = Vector t;\"\n        throw new Error(`Cannot parse TLObject ${line}`);\n    }\n    const argsMatch = findAll(/({)?(\\w+):([\\w\\d<>#.?!]+)}?/, line);\n    const currentConfig = {\n        name: match[1],\n        constructorId: parseInt(match[2], 16),\n        argsConfig: {},\n        subclassOfId: (0, Helpers_1.crc32)(match[3]),\n        result: match[3],\n        isFunction: isFunction,\n        namespace: undefined,\n    };\n    if (!currentConfig.constructorId) {\n        const hexId = \"\";\n        let args;\n        if (Object.values(currentConfig.argsConfig).length) {\n            args = ` ${Object.keys(currentConfig.argsConfig)\n                .map((arg) => arg.toString())\n                .join(\" \")}`;\n        }\n        else {\n            args = \"\";\n        }\n        const representation = `${currentConfig.name}${hexId}${args} = ${currentConfig.result}`\n            .replace(/(:|\\?)bytes /g, \"$1string \")\n            .replace(/</g, \" \")\n            .replace(/>|{|}/g, \"\")\n            .replace(/ \\w+:flags(\\d+)?\\.\\d+\\?true/g, \"\");\n        if (currentConfig.name === \"inputMediaInvoice\") {\n            // eslint-disable-next-line no-empty\n            if (currentConfig.name === \"inputMediaInvoice\") {\n            }\n        }\n        currentConfig.constructorId = (0, Helpers_1.crc32)(Buffer.from(representation, \"utf8\"));\n    }\n    for (const [brace, name, argType] of argsMatch) {\n        if (brace === undefined) {\n            // @ts-ignore\n            currentConfig.argsConfig[variableSnakeToCamelCase(name)] =\n                buildArgConfig(name, argType);\n        }\n    }\n    if (currentConfig.name.includes(\".\")) {\n        [currentConfig.namespace, currentConfig.name] =\n            currentConfig.name.split(/\\.(.+)/);\n    }\n    currentConfig.name = snakeToCamelCase(currentConfig.name);\n    /*\n    for (const arg in currentConfig.argsConfig){\n      if (currentConfig.argsConfig.hasOwnProperty(arg)){\n        if (currentConfig.argsConfig[arg].flagIndicator){\n          delete  currentConfig.argsConfig[arg]\n        }\n      }\n    }*/\n    return currentConfig;\n};\nexports.fromLine = fromLine;\nfunction buildArgConfig(name, argType) {\n    name = name === \"self\" ? \"is_self\" : name;\n    // Default values\n    const currentConfig = {\n        isVector: false,\n        isFlag: false,\n        skipConstructorId: false,\n        flagName: null,\n        flagIndex: -1,\n        flagIndicator: true,\n        type: null,\n        useVectorId: null,\n    };\n    // Special case: some types can be inferred, which makes it\n    // less annoying to type. Currently the only type that can\n    // be inferred is if the name is 'random_id', to which a\n    // random ID will be assigned if left as None (the default)\n    const canBeInferred = name === \"random_id\";\n    // The type can be an indicator that other arguments will be flags\n    if (argType !== \"#\") {\n        currentConfig.flagIndicator = false;\n        // Strip the exclamation mark always to have only the name\n        currentConfig.type = argType.replace(/^!+/, \"\");\n        // The type may be a flag (flags.IDX?REAL_TYPE)\n        // Note that 'flags' is NOT the flags name; this\n        // is determined by a previous argument\n        // However, we assume that the argument will always be starts with 'flags'\n        // @ts-ignore\n        const flagMatch = currentConfig.type.match(/(flags(?:\\d+)?).(\\d+)\\?([\\w<>.]+)/);\n        if (flagMatch) {\n            currentConfig.isFlag = true;\n            // As of layer 140, flagName can be \"flags\" or \"flags2\"\n            currentConfig.flagName = flagMatch[1];\n            currentConfig.flagIndex = Number(flagMatch[2]);\n            // Update the type to match the exact type, not the \"flagged\" one\n            currentConfig.type = flagMatch[3];\n        }\n        // Then check if the type is a Vector<REAL_TYPE>\n        // @ts-ignore\n        const vectorMatch = currentConfig.type.match(/[Vv]ector<([\\w\\d.]+)>/);\n        if (vectorMatch) {\n            currentConfig.isVector = true;\n            // If the type's first letter is not uppercase, then\n            // it is a constructor and we use (read/write) its ID.\n            // @ts-ignore\n            currentConfig.useVectorId = currentConfig.type.charAt(0) === \"V\";\n            // Update the type to match the one inside the vector\n            [, currentConfig.type] = vectorMatch;\n        }\n        // See use_vector_id. An example of such case is ipPort in\n        // help.configSpecial\n        // @ts-ignore\n        if (/^[a-z]$/.test(currentConfig.type.split(\".\").pop().charAt(0))) {\n            currentConfig.skipConstructorId = true;\n        }\n        // The name may contain \"date\" in it, if this is the case and\n        // the type is \"int\", we can safely assume that this should be\n        // treated as a \"date\" object. Note that this is not a valid\n        // Telegram object, but it's easier to work with\n        // if (\n        //     this.type === 'int' &&\n        //     (/(\\b|_)([dr]ate|until|since)(\\b|_)/.test(name) ||\n        //         ['expires', 'expires_at', 'was_online'].includes(name))\n        // ) {\n        //     this.type = 'date';\n        // }\n    }\n    // workaround\n    if (currentConfig.type == \"future_salt\") {\n        currentConfig.type = \"FutureSalt\";\n    }\n    return currentConfig;\n}\nconst parseTl = function* (content, layer, methods = [], ignoreIds = CORE_TYPES) {\n    const methodInfo = (methods || []).reduce((o, m) => (Object.assign(Object.assign({}, o), { [m.name]: m })), {});\n    const objAll = [];\n    const objByName = {};\n    const objByType = {};\n    const file = content;\n    let isFunction = false;\n    for (let line of file.split(\"\\n\")) {\n        const commentIndex = line.indexOf(\"//\");\n        if (commentIndex !== -1) {\n            line = line.slice(0, commentIndex);\n        }\n        line = line.trim();\n        if (!line) {\n            continue;\n        }\n        const match = line.match(/---(\\w+)---/);\n        if (match) {\n            const [, followingTypes] = match;\n            isFunction = followingTypes === \"functions\";\n            continue;\n        }\n        try {\n            const result = fromLine(line, isFunction);\n            if (ignoreIds.has(result.constructorId)) {\n                continue;\n            }\n            objAll.push(result);\n            if (!result.isFunction) {\n                if (!objByType[result.result]) {\n                    objByType[result.result] = [];\n                }\n                objByName[result.name] = result;\n                objByType[result.result].push(result);\n            }\n        }\n        catch (e) {\n            if (!e.toString().includes(\"vector#1cb5c415\")) {\n                throw e;\n            }\n        }\n    }\n    // Once all objects have been parsed, replace the\n    // string type from the arguments with references\n    for (const obj of objAll) {\n        if (AUTH_KEY_TYPES.has(obj.constructorId)) {\n            for (const arg in obj.argsConfig) {\n                if (obj.argsConfig[arg].type === \"string\") {\n                    obj.argsConfig[arg].type = \"bytes\";\n                }\n            }\n        }\n    }\n    for (const obj of objAll) {\n        yield obj;\n    }\n};\nexports.parseTl = parseTl;\nconst findAll = (regex, str, matches = []) => {\n    if (!regex.flags.includes(\"g\")) {\n        regex = new RegExp(regex.source, \"g\");\n    }\n    const res = regex.exec(str);\n    if (res) {\n        matches.push(res.slice(1));\n        findAll(regex, str, matches);\n    }\n    return matches;\n};\nexports.findAll = findAll;\nfunction serializeBytes(data) {\n    if (!(data instanceof Buffer)) {\n        if (typeof data == \"string\") {\n            data = Buffer.from(data);\n        }\n        else {\n            throw Error(`Bytes or str expected, not ${data.constructor.name}`);\n        }\n    }\n    const r = [];\n    let padding;\n    if (data.length < 254) {\n        padding = (data.length + 1) % 4;\n        if (padding !== 0) {\n            padding = 4 - padding;\n        }\n        r.push(Buffer.from([data.length]));\n        r.push(data);\n    }\n    else {\n        padding = data.length % 4;\n        if (padding !== 0) {\n            padding = 4 - padding;\n        }\n        r.push(Buffer.from([\n            254,\n            data.length % 256,\n            (data.length >> 8) % 256,\n            (data.length >> 16) % 256,\n        ]));\n        r.push(data);\n    }\n    r.push(Buffer.alloc(padding).fill(0));\n    return Buffer.concat(r);\n}\nfunction serializeDate(dt) {\n    if (!dt) {\n        return Buffer.alloc(4).fill(0);\n    }\n    if (dt instanceof Date) {\n        dt = Math.floor((Date.now() - dt.getTime()) / 1000);\n    }\n    if (typeof dt == \"number\") {\n        const t = Buffer.alloc(4);\n        t.writeInt32LE(dt, 0);\n        return t;\n    }\n    throw Error(`Cannot interpret \"${dt}\" as a date`);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}