{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.possibleElisions = exports.simpleRegularExpression = exports.ADDRESS_BOUNDARY = exports.padGroup = exports.groupPossibilities = void 0;\nconst v6 = __importStar(require(\"./constants\"));\nconst sprintf_js_1 = require(\"sprintf-js\");\nfunction groupPossibilities(possibilities) {\n  return (0, sprintf_js_1.sprintf)('(%s)', possibilities.join('|'));\n}\nexports.groupPossibilities = groupPossibilities;\nfunction padGroup(group) {\n  if (group.length < 4) {\n    return (0, sprintf_js_1.sprintf)('0{0,%d}%s', 4 - group.length, group);\n  }\n  return group;\n}\nexports.padGroup = padGroup;\nexports.ADDRESS_BOUNDARY = '[^A-Fa-f0-9:]';\nfunction simpleRegularExpression(groups) {\n  const zeroIndexes = [];\n  groups.forEach((group, i) => {\n    const groupInteger = parseInt(group, 16);\n    if (groupInteger === 0) {\n      zeroIndexes.push(i);\n    }\n  });\n  // You can technically elide a single 0, this creates the regular expressions\n  // to match that eventuality\n  const possibilities = zeroIndexes.map(zeroIndex => groups.map((group, i) => {\n    if (i === zeroIndex) {\n      const elision = i === 0 || i === v6.GROUPS - 1 ? ':' : '';\n      return groupPossibilities([padGroup(group), elision]);\n    }\n    return padGroup(group);\n  }).join(':'));\n  // The simplest case\n  possibilities.push(groups.map(padGroup).join(':'));\n  return groupPossibilities(possibilities);\n}\nexports.simpleRegularExpression = simpleRegularExpression;\nfunction possibleElisions(elidedGroups, moreLeft, moreRight) {\n  const left = moreLeft ? '' : ':';\n  const right = moreRight ? '' : ':';\n  const possibilities = [];\n  // 1. elision of everything (::)\n  if (!moreLeft && !moreRight) {\n    possibilities.push('::');\n  }\n  // 2. complete elision of the middle\n  if (moreLeft && moreRight) {\n    possibilities.push('');\n  }\n  if (moreRight && !moreLeft || !moreRight && moreLeft) {\n    // 3. complete elision of one side\n    possibilities.push(':');\n  }\n  // 4. elision from the left side\n  possibilities.push((0, sprintf_js_1.sprintf)('%s(:0{1,4}){1,%d}', left, elidedGroups - 1));\n  // 5. elision from the right side\n  possibilities.push((0, sprintf_js_1.sprintf)('(0{1,4}:){1,%d}%s', elidedGroups - 1, right));\n  // 6. no elision\n  possibilities.push((0, sprintf_js_1.sprintf)('(0{1,4}:){%d}0{1,4}', elidedGroups - 1));\n  // 7. elision (including sloppy elision) from the middle\n  for (let groups = 1; groups < elidedGroups - 1; groups++) {\n    for (let position = 1; position < elidedGroups - groups; position++) {\n      possibilities.push((0, sprintf_js_1.sprintf)('(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}', position, elidedGroups - position - groups - 1));\n    }\n  }\n  return groupPossibilities(possibilities);\n}\nexports.possibleElisions = possibleElisions;\n//# sourceMappingURL=regular-expressions.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}