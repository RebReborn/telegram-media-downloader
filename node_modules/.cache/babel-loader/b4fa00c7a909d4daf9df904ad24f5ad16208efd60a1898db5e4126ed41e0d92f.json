{"ast":null,"code":"\"use strict\";\n\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChatGetter = void 0;\nconst __1 = require(\"../../\");\nconst api_1 = require(\"../api\");\nconst Helpers_1 = require(\"../../Helpers\");\nconst inspect_1 = require(\"../../inspect\");\nclass ChatGetter {\n  [inspect_1.inspect.custom]() {\n    return (0, Helpers_1.betterConsoleLog)(this);\n  }\n  static initChatClass(c, {\n    chatPeer,\n    inputChat,\n    chat,\n    broadcast\n  }) {\n    c._chatPeer = chatPeer;\n    c._inputChat = inputChat;\n    c._chat = chat;\n    c._broadcast = broadcast;\n    c._client = undefined;\n  }\n  get chat() {\n    return this._chat;\n  }\n  async getChat() {\n    var _a;\n    if (!this._chat || \"min\" in this._chat && (await this.getInputChat())) {\n      try {\n        if (this._inputChat) {\n          this._chat = await ((_a = this._client) === null || _a === void 0 ? void 0 : _a.getEntity(this._inputChat));\n        }\n      } catch (e) {\n        await this._refetchChat();\n      }\n    }\n    return this._chat;\n  }\n  get inputChat() {\n    if (!this._inputChat && this._chatPeer && this._client) {\n      try {\n        this._inputChat = this._client._entityCache.get(__1.utils.getPeerId(this._chatPeer));\n      } catch (e) {}\n    }\n    return this._inputChat;\n  }\n  async getInputChat() {\n    var _a, e_1, _b, _c;\n    if (!this.inputChat && this.chatId && this._client) {\n      try {\n        const target = this.chatId;\n        try {\n          for (var _d = true, _e = __asyncValues(this._client.iterDialogs({\n              limit: 100\n            })), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {\n            _c = _f.value;\n            _d = false;\n            const dialog = _c;\n            if (dialog.id.eq(target)) {\n              this._chat = dialog.entity;\n              this._inputChat = dialog.inputEntity;\n              break;\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      } catch (e) {\n        // do nothing\n      }\n      return this._inputChat;\n    }\n    return this._inputChat;\n  }\n  get chatId() {\n    return this._chatPeer ? (0, Helpers_1.returnBigInt)(__1.utils.getPeerId(this._chatPeer)) : undefined;\n  }\n  get isPrivate() {\n    return this._chatPeer ? this._chatPeer instanceof api_1.Api.PeerUser : undefined;\n  }\n  get isGroup() {\n    if (!this._broadcast && this.chat && \"broadcast\" in this.chat) {\n      this._broadcast = Boolean(this.chat.broadcast);\n    }\n    if (this._chatPeer instanceof api_1.Api.PeerChannel) {\n      if (this._broadcast === undefined) {\n        return undefined;\n      } else {\n        return !this._broadcast;\n      }\n    }\n    return this._chatPeer instanceof api_1.Api.PeerChat;\n  }\n  get isChannel() {\n    return this._chatPeer instanceof api_1.Api.PeerChannel;\n  }\n  async _refetchChat() {}\n}\nexports.ChatGetter = ChatGetter;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}