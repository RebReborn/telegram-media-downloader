{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DEFAULT_DELIMITERS = void 0;\nexports._replaceWithMention = _replaceWithMention;\nexports._parseMessageText = _parseMessageText;\nexports._getResponseMessage = _getResponseMessage;\nconst Utils_1 = require(\"../Utils\");\nconst api_1 = require(\"../tl/api\");\nconst index_1 = require(\"../index\");\nconst Helpers_1 = require(\"../Helpers\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nexports.DEFAULT_DELIMITERS = {\n  \"**\": api_1.Api.MessageEntityBold,\n  __: api_1.Api.MessageEntityItalic,\n  \"~~\": api_1.Api.MessageEntityStrike,\n  \"`\": api_1.Api.MessageEntityCode,\n  \"```\": api_1.Api.MessageEntityPre\n};\n/** @hidden */\nasync function _replaceWithMention(client, entities, i, user) {\n  try {\n    entities[i] = new api_1.Api.InputMessageEntityMentionName({\n      offset: entities[i].offset,\n      length: entities[i].length,\n      userId: await client.getInputEntity(user)\n    });\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/** @hidden */\nasync function _parseMessageText(client, message, parseMode) {\n  if (parseMode == false) {\n    return [message, []];\n  }\n  if (parseMode == undefined) {\n    if (client.parseMode == undefined) {\n      return [message, []];\n    }\n    parseMode = client.parseMode;\n  } else if (typeof parseMode === \"string\") {\n    parseMode = (0, Utils_1.sanitizeParseMode)(parseMode);\n  }\n  const [rawMessage, msgEntities] = parseMode.parse(message);\n  for (let i = msgEntities.length - 1; i >= 0; i--) {\n    const e = msgEntities[i];\n    if (e instanceof api_1.Api.MessageEntityTextUrl) {\n      const m = /^@|\\+|tg:\\/\\/user\\?id=(\\d+)/.exec(e.url);\n      if (m) {\n        const userIdOrUsername = m[1] ? Number(m[1]) : e.url;\n        const isMention = await _replaceWithMention(client, msgEntities, i, userIdOrUsername);\n        if (!isMention) {\n          msgEntities.splice(i, 1);\n        }\n      }\n    }\n  }\n  return [rawMessage, msgEntities];\n}\n/** @hidden */\nfunction _getResponseMessage(client, request, result, inputChat) {\n  let updates = [];\n  let entities = new Map();\n  if (result instanceof api_1.Api.UpdateShort) {\n    updates = [result.update];\n  } else if (result instanceof api_1.Api.Updates || result instanceof api_1.Api.UpdatesCombined) {\n    updates = result.updates;\n    for (const x of [...result.users, ...result.chats]) {\n      entities.set(index_1.utils.getPeerId(x), x);\n    }\n  } else {\n    return;\n  }\n  const randomToId = new Map();\n  const idToMessage = new Map();\n  let schedMessage;\n  for (const update of updates) {\n    if (update instanceof api_1.Api.UpdateMessageID) {\n      randomToId.set(update.randomId.toString(), update.id);\n    } else if (update instanceof api_1.Api.UpdateNewChannelMessage || update instanceof api_1.Api.UpdateNewMessage) {\n      update.message._finishInit(client, entities, inputChat);\n      if (\"randomId\" in request || (0, Helpers_1.isArrayLike)(request)) {\n        idToMessage.set(update.message.id, update.message);\n      } else {\n        return update.message;\n      }\n    } else if (update instanceof api_1.Api.UpdateEditMessage && \"peer\" in request && (0, Helpers_1._entityType)(request.peer) != Helpers_1._EntityType.CHANNEL) {\n      update.message._finishInit(client, entities, inputChat);\n      if (\"randomId\" in request) {\n        idToMessage.set(update.message.id, update.message);\n      } else if (\"id\" in request && request.id === update.message.id) {\n        return update.message;\n      }\n    } else if (update instanceof api_1.Api.UpdateEditChannelMessage && \"peer\" in request && (0, Utils_1.getPeerId)(request.peer) == (0, Utils_1.getPeerId)(update.message.peerId)) {\n      if (request.id == update.message.id) {\n        update.message._finishInit(client, entities, inputChat);\n        return update.message;\n      }\n    } else if (update instanceof api_1.Api.UpdateNewScheduledMessage) {\n      update.message._finishInit(client, entities, inputChat);\n      schedMessage = update.message;\n      idToMessage.set(update.message.id, update.message);\n    } else if (update instanceof api_1.Api.UpdateMessagePoll) {\n      if (request.media.poll.id == update.pollId) {\n        const m = new api_1.Api.Message({\n          id: request.id,\n          peerId: index_1.utils.getPeerId(request.peer),\n          media: new api_1.Api.MessageMediaPoll({\n            poll: update.poll,\n            results: update.results\n          }),\n          message: \"\",\n          date: 0\n        });\n        m._finishInit(client, entities, inputChat);\n        return m;\n      }\n    }\n  }\n  if (request == undefined) {\n    return idToMessage;\n  }\n  let randomId;\n  if ((0, Helpers_1.isArrayLike)(request) || typeof request == \"number\" || big_integer_1.default.isInstance(request)) {\n    randomId = request;\n  } else {\n    randomId = request.randomId;\n  }\n  if (!randomId) {\n    if (schedMessage) {\n      return schedMessage;\n    }\n    client._log.warn(`No randomId in ${request} to map to. returning undefined for ${result} (Message was empty)`);\n    return undefined;\n  }\n  if (!(0, Helpers_1.isArrayLike)(randomId)) {\n    let msg = idToMessage.get(randomToId.get(randomId.toString()));\n    if (!msg) {\n      client._log.warn(`Request ${request.className} had missing message mapping ${result.className} (Message was empty)`);\n    }\n    return msg;\n  }\n  const final = [];\n  let warned = false;\n  for (const rnd of randomId) {\n    const tmp = randomToId.get(rnd.toString());\n    if (!tmp) {\n      warned = true;\n      break;\n    }\n    const tmp2 = idToMessage.get(tmp);\n    if (!tmp2) {\n      warned = true;\n      break;\n    }\n    final.push(tmp2);\n  }\n  if (warned) {\n    client._log.warn(`Request ${request.className} had missing message mapping ${result.className} (Message was empty)`);\n  }\n  const finalToReturn = [];\n  for (const rnd of randomId) {\n    finalToReturn.push(idToMessage.get(randomToId.get(rnd.toString())));\n  }\n  return finalToReturn;\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}