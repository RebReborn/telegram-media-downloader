{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.invoke = invoke;\nexports.getMe = getMe;\nexports.isBot = isBot;\nexports.isUserAuthorized = isUserAuthorized;\nexports.getEntity = getEntity;\nexports.getInputEntity = getInputEntity;\nexports._getEntityFromString = _getEntityFromString;\nexports.getPeerId = getPeerId;\nexports._getPeer = _getPeer;\nexports._getInputDialog = _getInputDialog;\nexports._getInputNotify = _getInputNotify;\nexports._selfId = _selfId;\nconst tl_1 = require(\"../tl\");\nconst Utils_1 = require(\"../Utils\");\nconst Helpers_1 = require(\"../Helpers\");\nconst __1 = require(\"../\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst Logger_1 = require(\"../extensions/Logger\");\nconst RequestState_1 = require(\"../network/RequestState\");\n// UserMethods {\n// region Invoking Telegram request\n/** @hidden */\nasync function invoke(client, request, dcId, otherSender) {\n  if (request.classType !== \"request\") {\n    throw new Error(\"You can only invoke MTProtoRequests\");\n  }\n  let sender = client._sender;\n  if (dcId) {\n    sender = await client.getSender(dcId);\n  }\n  if (otherSender != undefined) {\n    sender = otherSender;\n  }\n  if (sender == undefined) {\n    throw new Error(\"Cannot send requests while disconnected. You need to call .connect()\");\n  }\n  if (sender.userDisconnected) {\n    throw new Error(\"Cannot send requests while disconnected. Please reconnect.\");\n  }\n  await client._connectedDeferred.promise;\n  await request.resolve(client, __1.utils);\n  client._lastRequest = new Date().getTime();\n  const state = new RequestState_1.RequestState(request);\n  let attempt = 0;\n  for (attempt = 0; attempt < client._requestRetries; attempt++) {\n    sender.addStateToQueue(state);\n    try {\n      const result = await state.promise;\n      state.finished.resolve();\n      client.session.processEntities(result);\n      client._entityCache.add(result);\n      return result;\n    } catch (e) {\n      if (e instanceof __1.errors.ServerError || e.errorMessage === \"RPC_CALL_FAIL\" || e.errorMessage === \"RPC_MCGET_FAIL\") {\n        client._log.warn(`Telegram is having internal issues ${e.constructor.name}`);\n        await (0, Helpers_1.sleep)(2000);\n      } else if (e instanceof __1.errors.FloodWaitError || e instanceof __1.errors.FloodTestPhoneWaitError) {\n        if (e.seconds <= client.floodSleepThreshold) {\n          client._log.info(`Sleeping for ${e.seconds}s on flood wait (Caused by ${request.className})`);\n          await (0, Helpers_1.sleep)(e.seconds * 1000);\n        } else {\n          state.finished.resolve();\n          throw e;\n        }\n      } else if (e instanceof __1.errors.PhoneMigrateError || e instanceof __1.errors.NetworkMigrateError || e instanceof __1.errors.UserMigrateError) {\n        client._log.info(`Phone migrated to ${e.newDc}`);\n        const shouldRaise = e instanceof __1.errors.PhoneMigrateError || e instanceof __1.errors.NetworkMigrateError;\n        if (shouldRaise && (await client.isUserAuthorized())) {\n          state.finished.resolve();\n          throw e;\n        }\n        await client._switchDC(e.newDc);\n        sender = dcId === undefined ? client._sender : await client.getSender(dcId);\n      } else if (e instanceof __1.errors.MsgWaitError) {\n        // We need to resend this after the old one was confirmed.\n        await state.isReady();\n        state.after = undefined;\n      } else if (e.message === \"CONNECTION_NOT_INITED\") {\n        await client.disconnect();\n        await (0, Helpers_1.sleep)(2000);\n        await client.connect();\n      } else {\n        state.finished.resolve();\n        throw e;\n      }\n    }\n    state.resetPromise();\n  }\n  throw new Error(`Request was unsuccessful ${attempt} time(s)`);\n}\n/** @hidden */\nasync function getMe(client, inputPeer) {\n  if (inputPeer && client._selfInputPeer) {\n    return client._selfInputPeer;\n  }\n  const me = (await client.invoke(new tl_1.Api.users.GetUsers({\n    id: [new tl_1.Api.InputUserSelf()]\n  })))[0];\n  client._bot = me.bot;\n  if (!client._selfInputPeer) {\n    client._selfInputPeer = __1.utils.getInputPeer(me, false);\n  }\n  return inputPeer ? client._selfInputPeer : me;\n}\n/** @hidden */\nasync function isBot(client) {\n  if (client._bot === undefined) {\n    const me = await client.getMe();\n    if (me) {\n      return !(me instanceof tl_1.Api.InputPeerUser) ? me.bot : undefined;\n    }\n  }\n  return client._bot;\n}\n/** @hidden */\nasync function isUserAuthorized(client) {\n  try {\n    await client.invoke(new tl_1.Api.updates.GetState());\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/** @hidden */\nasync function getEntity(client, entity) {\n  const single = !(0, Helpers_1.isArrayLike)(entity);\n  let entityArray = [];\n  if ((0, Helpers_1.isArrayLike)(entity)) {\n    entityArray = entity;\n  } else {\n    entityArray.push(entity);\n  }\n  const inputs = [];\n  for (const x of entityArray) {\n    if (typeof x === \"string\") {\n      const valid = (0, Utils_1.parseID)(x);\n      if (valid) {\n        inputs.push(await client.getInputEntity(valid));\n      } else {\n        inputs.push(x);\n      }\n    } else {\n      inputs.push(await client.getInputEntity(x));\n    }\n  }\n  const lists = new Map([[Helpers_1._EntityType.USER, []], [Helpers_1._EntityType.CHAT, []], [Helpers_1._EntityType.CHANNEL, []]]);\n  for (const x of inputs) {\n    try {\n      lists.get((0, Helpers_1._entityType)(x)).push(x);\n    } catch (e) {}\n  }\n  let users = lists.get(Helpers_1._EntityType.USER);\n  let chats = lists.get(Helpers_1._EntityType.CHAT);\n  let channels = lists.get(Helpers_1._EntityType.CHANNEL);\n  if (users.length) {\n    users = await client.invoke(new tl_1.Api.users.GetUsers({\n      id: users\n    }));\n  }\n  if (chats.length) {\n    const chatIds = chats.map(x => x.chatId);\n    chats = (await client.invoke(new tl_1.Api.messages.GetChats({\n      id: chatIds\n    }))).chats;\n  }\n  if (channels.length) {\n    channels = (await client.invoke(new tl_1.Api.channels.GetChannels({\n      id: channels\n    }))).chats;\n  }\n  const idEntity = new Map();\n  for (const user of users) {\n    idEntity.set((0, Utils_1.getPeerId)(user), user);\n  }\n  for (const channel of channels) {\n    idEntity.set((0, Utils_1.getPeerId)(channel), channel);\n  }\n  for (const chat of chats) {\n    idEntity.set((0, Utils_1.getPeerId)(chat), chat);\n  }\n  const result = [];\n  for (const x of inputs) {\n    if (typeof x === \"string\") {\n      result.push(await _getEntityFromString(client, x));\n    } else if (!(x instanceof tl_1.Api.InputPeerSelf)) {\n      result.push(idEntity.get((0, Utils_1.getPeerId)(x)));\n    } else {\n      for (const [key, u] of idEntity.entries()) {\n        if (u instanceof tl_1.Api.User && u.self) {\n          result.push(u);\n          break;\n        }\n      }\n    }\n  }\n  return single ? result[0] : result;\n}\n/** @hidden */\nasync function getInputEntity(client, peer) {\n  // Short-circuit if the input parameter directly maps to an InputPeer\n  try {\n    return __1.utils.getInputPeer(peer);\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  // Next in priority is having a peer (or its ID) cached in-memory\n  try {\n    if (typeof peer == \"string\") {\n      const valid = (0, Utils_1.parseID)(peer);\n      if (valid) {\n        const res = client._entityCache.get(peer);\n        if (res) {\n          return res;\n        }\n      }\n    }\n    if (typeof peer === \"number\" || typeof peer === \"bigint\" || big_integer_1.default.isInstance(peer)) {\n      const res = client._entityCache.get(peer.toString());\n      if (res) {\n        return res;\n      }\n    }\n    // 0x2d45687 == crc32(b'Peer')\n    if (typeof peer == \"object\" && !big_integer_1.default.isInstance(peer) && peer.SUBCLASS_OF_ID === 0x2d45687) {\n      const res = client._entityCache.get(__1.utils.getPeerId(peer));\n      if (res) {\n        return res;\n      }\n    }\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  // Then come known strings that take precedence\n  if (typeof peer == \"string\") {\n    if ([\"me\", \"this\", \"self\"].includes(peer)) {\n      return new tl_1.Api.InputPeerSelf();\n    }\n  }\n  // No InputPeer, cached peer, or known string. Fetch from disk cache\n  try {\n    if (peer != undefined) {\n      return client.session.getInputEntity(peer);\n    }\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  // Only network left to try\n  if (typeof peer === \"string\") {\n    return __1.utils.getInputPeer(await _getEntityFromString(client, peer));\n  }\n  // If we're a bot and the user has messaged us privately users.getUsers\n  // will work with accessHash = 0. Similar for channels.getChannels.\n  // If we're not a bot but the user is in our contacts, it seems to work\n  // regardless. These are the only two special-cased requests.\n  if (typeof peer === \"number\") {\n    peer = (0, Helpers_1.returnBigInt)(peer);\n  }\n  peer = __1.utils.getPeer(peer);\n  if (peer instanceof tl_1.Api.PeerUser) {\n    const users = await client.invoke(new tl_1.Api.users.GetUsers({\n      id: [new tl_1.Api.InputUser({\n        userId: peer.userId,\n        accessHash: big_integer_1.default.zero\n      })]\n    }));\n    if (users.length && !(users[0] instanceof tl_1.Api.UserEmpty)) {\n      // If the user passed a valid ID they expect to work for\n      // channels but would be valid for users, we get UserEmpty.\n      // Avoid returning the invalid empty input peer for that.\n      //\n      // We *could* try to guess if it's a channel first, and if\n      // it's not, work as a chat and try to validate it through\n      // another request, but that becomes too much work.\n      return __1.utils.getInputPeer(users[0]);\n    }\n  } else if (peer instanceof tl_1.Api.PeerChat) {\n    return new tl_1.Api.InputPeerChat({\n      chatId: peer.chatId\n    });\n  } else if (peer instanceof tl_1.Api.PeerChannel) {\n    try {\n      const channels = await client.invoke(new tl_1.Api.channels.GetChannels({\n        id: [new tl_1.Api.InputChannel({\n          channelId: peer.channelId,\n          accessHash: big_integer_1.default.zero\n        })]\n      }));\n      return __1.utils.getInputPeer(channels.chats[0]);\n    } catch (e) {\n      if (client._errorHandler) {\n        await client._errorHandler(e);\n      }\n      if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\n        console.error(e);\n      }\n    }\n  }\n  throw new Error(`Could not find the input entity for ${JSON.stringify(peer)}.\n         Please read https://` + \"docs.telethon.dev/en/stable/concepts/entities.html to\" + \" find out more details.\");\n}\n/** @hidden */\nasync function _getEntityFromString(client, string) {\n  const phone = __1.utils.parsePhone(string);\n  if (phone) {\n    try {\n      const result = await client.invoke(new tl_1.Api.contacts.GetContacts({\n        hash: big_integer_1.default.zero\n      }));\n      if (!(result instanceof tl_1.Api.contacts.ContactsNotModified)) {\n        for (const user of result.users) {\n          if (user instanceof tl_1.Api.User && user.phone === phone) {\n            return user;\n          }\n        }\n      }\n    } catch (e) {\n      if (e.errorMessage === \"BOT_METHOD_INVALID\") {\n        throw new Error(\"Cannot get entity by phone number as a \" + \"bot (try using integer IDs, not strings)\");\n      }\n      throw e;\n    }\n  }\n  const id = __1.utils.parseID(string);\n  if (id != undefined) {\n    return getInputEntity(client, id);\n  } else if ([\"me\", \"this\"].includes(string.toLowerCase())) {\n    return client.getMe();\n  } else {\n    const {\n      username,\n      isInvite\n    } = __1.utils.parseUsername(string);\n    if (isInvite) {\n      const invite = await client.invoke(new tl_1.Api.messages.CheckChatInvite({\n        hash: username\n      }));\n      if (invite instanceof tl_1.Api.ChatInvite) {\n        throw new Error(\"Cannot get entity from a channel (or group) \" + \"that you are not part of. Join the group and retry\");\n      } else if (invite instanceof tl_1.Api.ChatInviteAlready) {\n        return invite.chat;\n      }\n    } else if (username) {\n      try {\n        const result = await client.invoke(new tl_1.Api.contacts.ResolveUsername({\n          username: username\n        }));\n        const pid = __1.utils.getPeerId(result.peer, false);\n        if (result.peer instanceof tl_1.Api.PeerUser) {\n          for (const x of result.users) {\n            if ((0, Helpers_1.returnBigInt)(x.id).equals((0, Helpers_1.returnBigInt)(pid))) {\n              return x;\n            }\n          }\n        } else {\n          for (const x of result.chats) {\n            if ((0, Helpers_1.returnBigInt)(x.id).equals((0, Helpers_1.returnBigInt)(pid))) {\n              return x;\n            }\n          }\n        }\n      } catch (e) {\n        if (e.errorMessage === \"USERNAME_NOT_OCCUPIED\") {\n          throw new Error(`No user has \"${username}\" as username`);\n        }\n        throw e;\n      }\n    }\n  }\n  throw new Error(`Cannot find any entity corresponding to \"${string}\"`);\n}\n/** @hidden */\nasync function getPeerId(client, peer) {\n  let addMark = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (typeof peer == \"string\") {\n    const valid = (0, Utils_1.parseID)(peer);\n    if (valid) {\n      return __1.utils.getPeerId(peer, addMark);\n    } else {\n      peer = await client.getInputEntity(peer);\n    }\n  }\n  if (typeof peer == \"number\" || typeof peer == \"bigint\" || big_integer_1.default.isInstance(peer)) {\n    return __1.utils.getPeerId(peer, addMark);\n  }\n  if (peer.SUBCLASS_OF_ID == 0x2d45687 || peer.SUBCLASS_OF_ID == 0xc91c90b6) {\n    peer = await client.getInputEntity(peer);\n  }\n  if (peer instanceof tl_1.Api.InputPeerSelf) {\n    peer = await client.getMe(true);\n  }\n  return __1.utils.getPeerId(peer, addMark);\n}\n/** @hidden */\nasync function _getPeer(client, peer) {\n  if (!peer) {\n    return undefined;\n  }\n  const [i, cls] = __1.utils.resolveId((0, Helpers_1.returnBigInt)(await client.getPeerId(peer)));\n  return new cls({\n    userId: i,\n    channelId: i,\n    chatId: i\n  });\n}\n/** @hidden */\nasync function _getInputDialog(client, dialog) {\n  try {\n    if (dialog.SUBCLASS_OF_ID == 0xa21c9795) {\n      // crc32(b'InputDialogPeer')\n      dialog.peer = await client.getInputEntity(dialog.peer);\n      return dialog;\n    } else if (dialog.SUBCLASS_OF_ID == 0xc91c90b6) {\n      //crc32(b'InputPeer')\n      return new tl_1.Api.InputDialogPeer({\n        peer: dialog\n      });\n    }\n  } catch (e) {}\n  return new tl_1.Api.InputDialogPeer({\n    peer: dialog\n  });\n}\n/** @hidden */\nasync function _getInputNotify(client, notify) {\n  try {\n    if (notify.SUBCLASS_OF_ID == 0x58981615) {\n      if (notify instanceof tl_1.Api.InputNotifyPeer) {\n        notify.peer = await client.getInputEntity(notify.peer);\n      }\n      return notify;\n    }\n  } catch (e) {}\n  return new tl_1.Api.InputNotifyPeer({\n    peer: await client.getInputEntity(notify)\n  });\n}\n/** @hidden */\nfunction _selfId(client) {\n  return client._selfInputPeer ? client._selfInputPeer.userId : undefined;\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}