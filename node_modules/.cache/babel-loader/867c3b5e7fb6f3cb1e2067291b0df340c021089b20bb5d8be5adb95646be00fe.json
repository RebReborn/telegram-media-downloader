{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFileInfo = getFileInfo;\nexports.chunks = chunks;\nexports.getInputPeer = getInputPeer;\nexports._photoSizeByteCount = _photoSizeByteCount;\nexports._getEntityPair = _getEntityPair;\nexports.getInnerText = getInnerText;\nexports.getInputChannel = getInputChannel;\nexports.getInputUser = getInputUser;\nexports.getInputMessage = getInputMessage;\nexports.getInputChatPhoto = getInputChatPhoto;\nexports.strippedPhotoToJpg = strippedPhotoToJpg;\nexports.getInputPhoto = getInputPhoto;\nexports.getInputDocument = getInputDocument;\nexports.isAudio = isAudio;\nexports.isImage = isImage;\nexports.getExtension = getExtension;\nexports.getAttributes = getAttributes;\nexports.getInputGeo = getInputGeo;\nexports.getInputMedia = getInputMedia;\nexports.getAppropriatedPartSize = getAppropriatedPartSize;\nexports.getPeer = getPeer;\nexports.sanitizeParseMode = sanitizeParseMode;\nexports.getPeerId = getPeerId;\nexports.resolveId = resolveId;\nexports.getMessageId = getMessageId;\nexports.parsePhone = parsePhone;\nexports.parseID = parseID;\nexports.resolveInviteLink = resolveInviteLink;\nexports.parseUsername = parseUsername;\nexports.rtrim = rtrim;\nexports.getDisplayName = getDisplayName;\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst mime_1 = __importDefault(require(\"mime\"));\nconst html_1 = require(\"./extensions/html\");\nconst markdown_1 = require(\"./extensions/markdown\");\nconst markdownv2_1 = require(\"./extensions/markdownv2\");\nconst Helpers_1 = require(\"./Helpers\");\nconst tl_1 = require(\"./tl\");\nfunction getFileInfo(fileLocation) {\n  if (!fileLocation || !fileLocation.SUBCLASS_OF_ID) {\n    _raiseCastFail(fileLocation, \"InputFileLocation\");\n  }\n  if (fileLocation.SUBCLASS_OF_ID == 354669666) {\n    return {\n      dcId: undefined,\n      location: fileLocation,\n      size: undefined\n    };\n  }\n  let location;\n  if (fileLocation instanceof tl_1.Api.Message) {\n    location = fileLocation.media;\n  }\n  if (fileLocation instanceof tl_1.Api.MessageMediaDocument) {\n    location = fileLocation.document;\n  } else if (fileLocation instanceof tl_1.Api.MessageMediaPhoto) {\n    location = fileLocation.photo;\n  }\n  if (location instanceof tl_1.Api.Document) {\n    return {\n      dcId: location.dcId,\n      location: new tl_1.Api.InputDocumentFileLocation({\n        id: location.id,\n        accessHash: location.accessHash,\n        fileReference: location.fileReference,\n        thumbSize: \"\"\n      }),\n      size: location.size\n    };\n  } else if (location instanceof tl_1.Api.Photo) {\n    return {\n      dcId: location.dcId,\n      location: new tl_1.Api.InputPhotoFileLocation({\n        id: location.id,\n        accessHash: location.accessHash,\n        fileReference: location.fileReference,\n        thumbSize: location.sizes[location.sizes.length - 1].type\n      }),\n      size: (0, big_integer_1.default)(_photoSizeByteCount(location.sizes[location.sizes.length - 1]) || 0)\n    };\n  }\n  _raiseCastFail(fileLocation, \"InputFileLocation\");\n}\n/**\n * Turns the given iterable into chunks of the specified size,\n * which is 100 by default since that's what Telegram uses the most.\n */\nfunction* chunks(arr, size = 100) {\n  for (let i = 0; i < arr.length; i += size) {\n    yield arr.slice(i, i + size);\n  }\n}\nconst USERNAME_RE = new RegExp(\"@|(?:https?:\\\\/\\\\/)?(?:www\\\\.)?\" + \"(?:telegram\\\\.(?:me|dog)|t\\\\.me)\\\\/(@|joinchat\\\\/)?\", \"i\");\nconst JPEG_HEADER = Buffer.from(\"ffd8ffe000104a46494600010100000100010000ffdb004300281c1e231e19282321232d2b28303c64413c37373c7b585d4964918099968f808c8aa0b4e6c3a0aadaad8a8cc8ffcbdaeef5ffffff9bc1fffffffaffe6fdfff8ffdb0043012b2d2d3c353c76414176f8a58ca5f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8ffc00011080000000003012200021101031101ffc4001f0000010501010101010100000000000000000102030405060708090a0bffc400b5100002010303020403050504040000017d01020300041105122131410613516107227114328191a1082342b1c11552d1f02433627282090a161718191a25262728292a3435363738393a434445464748494a535455565758595a636465666768696a737475767778797a838485868788898a92939495969798999aa2a3a4a5a6a7a8a9aab2b3b4b5b6b7b8b9bac2c3c4c5c6c7c8c9cad2d3d4d5d6d7d8d9dae1e2e3e4e5e6e7e8e9eaf1f2f3f4f5f6f7f8f9faffc4001f0100030101010101010101010000000000000102030405060708090a0bffc400b51100020102040403040705040400010277000102031104052131061241510761711322328108144291a1b1c109233352f0156272d10a162434e125f11718191a262728292a35363738393a434445464748494a535455565758595a636465666768696a737475767778797a82838485868788898a92939495969798999aa2a3a4a5a6a7a8a9aab2b3b4b5b6b7b8b9bac2c3c4c5c6c7c8c9cad2d3d4d5d6d7d8d9dae2e3e4e5e6e7e8e9eaf2f3f4f5f6f7f8f9faffda000c03010002110311003f00\", \"hex\");\nconst JPEG_FOOTER = Buffer.from(\"ffd9\", \"hex\");\nconst TG_JOIN_RE = new RegExp(\"tg:\\\\/\\\\/(join)\\\\?invite=\", \"i\");\nconst VALID_USERNAME_RE = new RegExp(\"^([a-z]((?!__)[\\\\w\\\\d]){3,30}[a-z\\\\d]|gif|vid|\" + \"pic|bing|wiki|imdb|bold|vote|like|coub)$\", \"i\");\nfunction _raiseCastFail(entity, target) {\n  let toWrite = entity;\n  if (typeof entity === \"object\" && \"className\" in entity) {\n    toWrite = entity.className;\n  }\n  throw new Error(`Cannot cast ${toWrite} to any kind of ${target}`);\n}\n/**\n Gets the input peer for the given \"entity\" (user, chat or channel).\n\n A ``TypeError`` is raised if the given entity isn't a supported type\n or if ``check_hash is True`` but the entity's ``accessHash is None``\n *or* the entity contains ``min`` information. In this case, the hash\n cannot be used for general purposes, and thus is not returned to avoid\n any issues which can derive from invalid access hashes.\n\n Note that ``checkHash`` **is ignored** if an input peer is already\n passed since in that case we assume the user knows what they're doing.\n This is key to getting entities by explicitly passing ``hash = 0``.\n\n * @param entity\n * @param allowSelf\n * @param checkHash\n */\nfunction getInputPeer(entity, allowSelf = true, checkHash = true) {\n  if (entity.SUBCLASS_OF_ID === undefined) {\n    // e.g. custom.Dialog (can't cyclic import).\n    if (allowSelf && \"inputEntity\" in entity) {\n      return entity.inputEntity;\n    } else if (\"entity\" in entity) {\n      return getInputPeer(entity.entity);\n    } else {\n      _raiseCastFail(entity, \"InputPeer\");\n    }\n  }\n  if (entity.SUBCLASS_OF_ID === 0xc91c90b6) {\n    // crc32(b'InputPeer')\n    return entity;\n  }\n  if (entity instanceof tl_1.Api.User) {\n    if (entity.self && allowSelf) {\n      return new tl_1.Api.InputPeerSelf();\n    } else if (entity.accessHash !== undefined && !entity.min || !checkHash) {\n      return new tl_1.Api.InputPeerUser({\n        userId: entity.id,\n        accessHash: entity.accessHash || (0, big_integer_1.default)(0)\n      });\n    } else {\n      throw new Error(\"User without accessHash or min cannot be input\");\n    }\n  }\n  if (entity instanceof tl_1.Api.Chat || entity instanceof tl_1.Api.ChatEmpty || entity instanceof tl_1.Api.ChatForbidden) {\n    return new tl_1.Api.InputPeerChat({\n      chatId: entity.id\n    });\n  }\n  if (entity instanceof tl_1.Api.Channel) {\n    if (entity.accessHash !== undefined && !entity.min || !checkHash) {\n      return new tl_1.Api.InputPeerChannel({\n        channelId: entity.id,\n        accessHash: entity.accessHash || (0, big_integer_1.default)(0)\n      });\n    } else {\n      throw new TypeError(\"Channel without accessHash or min info cannot be input\");\n    }\n  }\n  if (entity instanceof tl_1.Api.ChannelForbidden) {\n    // \"channelForbidden are never min\", and since their hash is\n    // also not optional, we assume that this truly is the case.\n    return new tl_1.Api.InputPeerChannel({\n      channelId: entity.id,\n      accessHash: entity.accessHash\n    });\n  }\n  if (entity instanceof tl_1.Api.InputUser) {\n    return new tl_1.Api.InputPeerUser({\n      userId: entity.userId,\n      accessHash: entity.accessHash\n    });\n  }\n  if (entity instanceof tl_1.Api.InputChannel) {\n    return new tl_1.Api.InputPeerChannel({\n      channelId: entity.channelId,\n      accessHash: entity.accessHash\n    });\n  }\n  if (entity instanceof tl_1.Api.UserEmpty) {\n    return new tl_1.Api.InputPeerEmpty();\n  }\n  if (entity instanceof tl_1.Api.UserFull) {\n    return getInputPeer(entity.id);\n  }\n  if (entity instanceof tl_1.Api.ChatFull) {\n    return new tl_1.Api.InputPeerChat({\n      chatId: entity.id\n    });\n  }\n  if (entity instanceof tl_1.Api.PeerChat) {\n    return new tl_1.Api.InputPeerChat({\n      chatId: entity.chatId\n    });\n  }\n  _raiseCastFail(entity, \"InputPeer\");\n}\nfunction _photoSizeByteCount(size) {\n  if (size instanceof tl_1.Api.PhotoSize) {\n    return size.size;\n  } else if (size instanceof tl_1.Api.PhotoStrippedSize) {\n    if (size.bytes.length < 3 || size.bytes[0] != 1) {\n      return size.bytes.length;\n    }\n    return size.bytes.length + 622;\n  } else if (size instanceof tl_1.Api.PhotoCachedSize) {\n    return size.bytes.length;\n  } else if (size instanceof tl_1.Api.PhotoSizeEmpty) {\n    return 0;\n  } else if (size instanceof tl_1.Api.PhotoSizeProgressive) {\n    return size.sizes[size.sizes.length - 1];\n  } else {\n    return undefined;\n  }\n}\nfunction _getEntityPair(entityId, entities, cache, getInputPeerFunction = getInputPeer) {\n  const entity = entities.get(entityId);\n  let inputEntity;\n  try {\n    inputEntity = cache.get(entityId);\n  } catch (e) {\n    try {\n      inputEntity = getInputPeerFunction(inputEntity);\n    } catch (e) {}\n  }\n  return [entity, inputEntity];\n}\nfunction getInnerText(text, entities) {\n  const result = [];\n  entities.forEach(function (value, key) {\n    const start = value.offset;\n    const end = value.offset + value.length;\n    result.push(text.slice(start, end));\n  });\n  return result;\n}\n/**\n Similar to :meth:`get_input_peer`, but for :tl:`InputChannel`'s alone.\n\n .. important::\n\n This method does not validate for invalid general-purpose access\n hashes, unlike `get_input_peer`. Consider using instead:\n ``get_input_channel(get_input_peer(channel))``.\n\n * @param entity\n * @returns {InputChannel|*}\n */\nfunction getInputChannel(entity) {\n  if (typeof entity === \"string\" || typeof entity == \"number\" || typeof entity == \"bigint\" || big_integer_1.default.isInstance(entity)) {\n    _raiseCastFail(entity, \"InputChannel\");\n  }\n  if (entity.SUBCLASS_OF_ID === undefined) {\n    _raiseCastFail(entity, \"InputChannel\");\n  }\n  if (entity.SUBCLASS_OF_ID === 0x40f202fd) {\n    // crc32(b'InputChannel')\n    return entity;\n  }\n  if (entity instanceof tl_1.Api.Channel || entity instanceof tl_1.Api.ChannelForbidden) {\n    return new tl_1.Api.InputChannel({\n      channelId: entity.id,\n      accessHash: entity.accessHash || big_integer_1.default.zero\n    });\n  }\n  if (entity instanceof tl_1.Api.InputPeerChannel) {\n    return new tl_1.Api.InputChannel({\n      channelId: entity.channelId,\n      accessHash: entity.accessHash\n    });\n  }\n  _raiseCastFail(entity, \"InputChannel\");\n}\n/**\n Similar to :meth:`getInputPeer`, but for :tl:`InputUser`'s alone.\n\n .. important::\n\n This method does not validate for invalid general-purpose access\n hashes, unlike `get_input_peer`. Consider using instead:\n ``get_input_channel(get_input_peer(channel))``.\n\n * @param entity\n */\nfunction getInputUser(entity) {\n  if (typeof entity === \"string\" || typeof entity == \"number\" || typeof entity == \"bigint\" || big_integer_1.default.isInstance(entity)) {\n    _raiseCastFail(entity, \"InputUser\");\n  }\n  if (entity.SUBCLASS_OF_ID === undefined) {\n    _raiseCastFail(entity, \"InputUser\");\n  }\n  if (entity.SUBCLASS_OF_ID === 0xe669bf46) {\n    // crc32(b'InputUser')\n    return entity;\n  }\n  if (entity instanceof tl_1.Api.User) {\n    if (entity.self) {\n      return new tl_1.Api.InputUserSelf();\n    } else {\n      return new tl_1.Api.InputUser({\n        userId: entity.id,\n        accessHash: entity.accessHash || big_integer_1.default.zero\n      });\n    }\n  }\n  if (entity instanceof tl_1.Api.InputPeerSelf) {\n    return new tl_1.Api.InputUserSelf();\n  }\n  if (entity instanceof tl_1.Api.UserEmpty || entity instanceof tl_1.Api.InputPeerEmpty) {\n    return new tl_1.Api.InputUserEmpty();\n  }\n  if (entity instanceof tl_1.Api.UserFull) {\n    return getInputUser(entity);\n  }\n  if (entity instanceof tl_1.Api.InputPeerUser) {\n    return new tl_1.Api.InputUser({\n      userId: entity.userId,\n      accessHash: entity.accessHash\n    });\n  }\n  if (entity instanceof tl_1.Api.InputPeerUserFromMessage) {\n    return new tl_1.Api.InputUserFromMessage({\n      userId: entity.userId,\n      peer: entity.peer,\n      msgId: entity.msgId\n    });\n  }\n  _raiseCastFail(entity, \"InputUser\");\n}\n/**\n Similar to :meth:`get_input_peer`, but for dialogs\n * @param dialog\n */\n/*CONTEST\nfunction getInputDialog(dialog) {\n    try {\n        if (dialog.SUBCLASS_OF_ID === 0xa21c9795) { // crc32(b'InputDialogPeer')\n            return dialog\n        }\n        if (dialog.SUBCLASS_OF_ID === 0xc91c90b6) { // crc32(b'InputPeer')\n            return new Api.InputDialogPeer({ peer: dialog })\n        }\n    } catch (e) {\n        _raiseCastFail(dialog, 'InputDialogPeer')\n    }\n\n    try {\n        return new Api.InputDialogPeer(getInputPeer(dialog))\n        // eslint-disable-next-line no-empty\n    } catch (e) {\n\n    }\n    _raiseCastFail(dialog, 'InputDialogPeer')\n}\n*/\n/**\n *  Similar to :meth:`get_input_peer`, but for input messages.\n */\nfunction getInputMessage(message) {\n  if (typeof message === \"number\") {\n    return new tl_1.Api.InputMessageID({\n      id: message\n    });\n  }\n  if (message === undefined || message.SUBCLASS_OF_ID === undefined) {\n    _raiseCastFail(message, \"InputMessage\");\n  }\n  if (message.SUBCLASS_OF_ID === 0x54b6bcc5) {\n    // crc32(b'InputMessage')\n    return message;\n  } else if (message.SUBCLASS_OF_ID === 0x790009e3) {\n    // crc32(b'Message'):\n    return new tl_1.Api.InputMessageID({\n      id: message.id\n    });\n  }\n  _raiseCastFail(message, \"InputMessage\");\n}\n/**\n *  Similar to :meth:`get_input_peer`, but for input messages.\n */\nfunction getInputChatPhoto(photo) {\n  if (photo === undefined || photo.SUBCLASS_OF_ID === undefined) {\n    _raiseCastFail(photo, \"InputChatPhoto\");\n  }\n  if (photo.SUBCLASS_OF_ID === 0xd4eb2d74) {\n    //crc32(b'InputChatPhoto')\n    return photo;\n  } else if (photo.SUBCLASS_OF_ID === 0xe7655f1f) {\n    // crc32(b'InputFile'):\n    return new tl_1.Api.InputChatUploadedPhoto({\n      file: photo\n    });\n  }\n  photo = getInputPhoto(photo);\n  if (photo instanceof tl_1.Api.InputPhoto) {\n    return new tl_1.Api.InputChatPhoto({\n      id: photo\n    });\n  } else if (photo instanceof tl_1.Api.InputPhotoEmpty) {\n    return new tl_1.Api.InputChatPhotoEmpty();\n  }\n  _raiseCastFail(photo, \"InputChatPhoto\");\n}\n/**\n * Adds the JPG header and footer to a stripped image.\n * Ported from https://github.com/telegramdesktop/tdesktop/blob/bec39d89e19670eb436dc794a8f20b657cb87c71/Telegram/SourceFiles/ui/image/image.cpp#L225\n\n * @param stripped{Buffer}\n * @returns {Buffer}\n */\nfunction strippedPhotoToJpg(stripped) {\n  // Note: Changes here should update _stripped_real_length\n  if (stripped.length < 3 || stripped[0] !== 1) {\n    return stripped;\n  }\n  const header = Buffer.from(JPEG_HEADER);\n  header[164] = stripped[1];\n  header[166] = stripped[2];\n  return Buffer.concat([header, stripped.slice(3), JPEG_FOOTER]);\n}\n/*CONTEST\nfunction getInputLocation(location) {\n    try {\n        if (!location.SUBCLASS_OF_ID) {\n            throw new Error()\n        }\n        if (location.SUBCLASS_OF_ID === 0x1523d462) {\n            return {\n                dcId: null,\n                inputLocation: location\n            }\n        }\n    } catch (e) {\n        _raiseCastFail(location, 'InputFileLocation')\n    }\n    if (location instanceof Api.Message) {\n        location = location.media\n    }\n\n    if (location instanceof Api.MessageMediaDocument) {\n        location = location.document\n    } else if (location instanceof Api.MessageMediaPhoto) {\n        location = location.photo\n    }\n\n    if (location instanceof Api.Document) {\n        return {\n            dcId: location.dcId,\n            inputLocation: new Api.InputDocumentFileLocation({\n                id: location.id,\n                accessHash: location.accessHash,\n                fileReference: location.fileReference,\n                thumbSize: '', // Presumably to download one of its thumbnails\n            }),\n        }\n    } else if (location instanceof Api.Photo) {\n        return {\n            dcId: location.dcId,\n            inputLocation: new Api.InputPhotoFileLocation({\n                id: location.id,\n                accessHash: location.accessHash,\n                fileReference: location.fileReference,\n                thumbSize: location.sizes[location.sizes.length - 1].type,\n            }),\n        }\n    }\n\n    if (location instanceof Api.FileLocationToBeDeprecated) {\n        throw new Error('Unavailable location cannot be used as input')\n    }\n    _raiseCastFail(location, 'InputFileLocation')\n}\n*/\n/**\n *  Similar to :meth:`get_input_peer`, but for photos\n */\nfunction getInputPhoto(photo) {\n  if (photo.SUBCLASS_OF_ID === undefined) {\n    _raiseCastFail(photo, \"InputPhoto\");\n  }\n  if (photo.SUBCLASS_OF_ID === 2221106144) {\n    return photo;\n  }\n  if (photo instanceof tl_1.Api.Message) {\n    photo = photo.media;\n  }\n  if (photo instanceof tl_1.Api.photos.Photo || photo instanceof tl_1.Api.MessageMediaPhoto) {\n    photo = photo.photo;\n  }\n  if (photo instanceof tl_1.Api.Photo) {\n    return new tl_1.Api.InputPhoto({\n      id: photo.id,\n      accessHash: photo.accessHash,\n      fileReference: photo.fileReference\n    });\n  }\n  if (photo instanceof tl_1.Api.PhotoEmpty) {\n    return new tl_1.Api.InputPhotoEmpty();\n  }\n  if (photo instanceof tl_1.Api.messages.ChatFull) {\n    photo = photo.fullChat;\n  }\n  if (photo instanceof tl_1.Api.ChannelFull) {\n    return getInputPhoto(photo.chatPhoto);\n  } else {\n    if (photo instanceof tl_1.Api.UserFull) {\n      return getInputPhoto(photo.profilePhoto);\n    } else {\n      if (photo instanceof tl_1.Api.Channel || photo instanceof tl_1.Api.Chat || photo instanceof tl_1.Api.User) {\n        return getInputPhoto(photo.photo);\n      }\n    }\n  }\n  if (photo instanceof tl_1.Api.UserEmpty || photo instanceof tl_1.Api.ChatEmpty || photo instanceof tl_1.Api.ChatForbidden || photo instanceof tl_1.Api.ChannelForbidden) {\n    return new tl_1.Api.InputPhotoEmpty();\n  }\n  _raiseCastFail(photo, \"InputPhoto\");\n}\n/**\n *  Similar to :meth:`get_input_peer`, but for documents\n */\nfunction getInputDocument(document) {\n  if (document.SUBCLASS_OF_ID === undefined) {\n    _raiseCastFail(document, \"InputDocument\");\n  }\n  if (document.SUBCLASS_OF_ID === 0xf33fdb68) {\n    return document;\n  }\n  if (document instanceof tl_1.Api.Document) {\n    return new tl_1.Api.InputDocument({\n      id: document.id,\n      accessHash: document.accessHash,\n      fileReference: document.fileReference\n    });\n  }\n  if (document instanceof tl_1.Api.DocumentEmpty) {\n    return new tl_1.Api.InputDocumentEmpty();\n  }\n  if (document instanceof tl_1.Api.MessageMediaDocument) {\n    return getInputDocument(document.document);\n  }\n  if (document instanceof tl_1.Api.Message) {\n    return getInputDocument(document.media);\n  }\n  _raiseCastFail(document, \"InputDocument\");\n}\n/**\n *  Returns `True` if the file has an audio mime type.\n */\nfunction isAudio(file) {\n  const ext = _getExtension(file);\n  if (!ext) {\n    const metadata = _getMetadata(file);\n    return (metadata.get(\"mimeType\") || \"\").startsWith(\"audio/\");\n  } else {\n    file = \"a\" + ext;\n    return (mime_1.default.getType(file) || \"\").startsWith(\"audio/\");\n  }\n}\n/**\n *  Returns `True` if the file has an image mime type.\n */\nfunction isImage(file) {\n  const ext = _getExtension(file).toLowerCase();\n  return ext.endsWith(\".png\") || ext.endsWith(\".jpg\") || ext.endsWith(\".jpeg\");\n}\nfunction getExtension(media) {\n  // Photos are always compressed as .jpg by Telegram\n  try {\n    getInputPhoto(media);\n    return \".jpg\";\n  } catch (e) {}\n  if (media instanceof tl_1.Api.UserProfilePhoto || media instanceof tl_1.Api.ChatPhoto) {\n    return \".jpg\";\n  }\n  if (media instanceof tl_1.Api.MessageMediaDocument) {\n    media = media.document;\n  }\n  if (media instanceof tl_1.Api.Document || media instanceof tl_1.Api.WebDocument || media instanceof tl_1.Api.WebDocumentNoProxy) {\n    if (media.mimeType === \"application/octet-stream\") {\n      // Octet stream are just bytes, which have no default extension\n      return \"\";\n    } else {\n      return mime_1.default.getExtension(media.mimeType) || \"\";\n    }\n  }\n  return \"\";\n}\n/**\n * Gets the extension for the given file, which can be either a\n * str or an ``open()``'ed file (which has a ``.name`` attribute).\n */\nfunction _getExtension(file) {\n  if (typeof file === \"string\") {\n    return \".\" + file.split(\".\").pop();\n  } else if (\"name\" in file) {\n    return _getExtension(file.name);\n  } else {\n    return getExtension(file);\n  }\n}\nfunction _getMetadata(file) {\n  //TODO Return nothing for now until we find a better way\n  return new Map();\n}\nfunction isVideo(file) {\n  var _a;\n  const ext = _getExtension(file);\n  if (!ext) {\n    const metadata = _getMetadata(file);\n    if (metadata.has(\"mimeType\")) {\n      return ((_a = metadata.get(\"mimeType\")) === null || _a === void 0 ? void 0 : _a.startsWith(\"video/\")) || false;\n    } else {\n      return false;\n    }\n  } else {\n    file = \"a\" + ext;\n    return (mime_1.default.getType(file) || \"\").startsWith(\"video/\");\n  }\n}\n/**\n Get a list of attributes for the given file and\n the mime type as a tuple ([attribute], mime_type).\n */\nfunction getAttributes(file, {\n  attributes = null,\n  mimeType = undefined,\n  forceDocument = false,\n  voiceNote = false,\n  videoNote = false,\n  supportsStreaming = false,\n  thumb = null\n}) {\n  var _a, _b, _c, _d;\n  const name = typeof file == \"string\" ? file : \"name\" in file ? file.name || \"unnamed\" : \"unnamed\";\n  if (mimeType === undefined) {\n    mimeType = mime_1.default.getType(name) || \"application/octet-stream\";\n  }\n  const attrObj = new Map();\n  attrObj.set(tl_1.Api.DocumentAttributeFilename, new tl_1.Api.DocumentAttributeFilename({\n    fileName: name.split(/[\\\\/]/).pop() || \"\"\n  }));\n  if (isAudio(file)) {\n    const m = _getMetadata(file);\n    attrObj.set(tl_1.Api.DocumentAttributeAudio, new tl_1.Api.DocumentAttributeAudio({\n      voice: voiceNote,\n      title: m.has(\"title\") ? m.get(\"title\") : undefined,\n      performer: m.has(\"author\") ? m.get(\"author\") : undefined,\n      duration: Number.parseInt((_a = m.get(\"duration\")) !== null && _a !== void 0 ? _a : \"0\")\n    }));\n  }\n  if (!forceDocument && isVideo(file)) {\n    let doc;\n    if (thumb) {\n      const t_m = _getMetadata(thumb);\n      const width = Number.parseInt((t_m === null || t_m === void 0 ? void 0 : t_m.get(\"width\")) || \"1\");\n      const height = Number.parseInt((t_m === null || t_m === void 0 ? void 0 : t_m.get(\"height\")) || \"1\");\n      doc = new tl_1.Api.DocumentAttributeVideo({\n        duration: 0,\n        h: height,\n        w: width,\n        roundMessage: videoNote,\n        supportsStreaming: supportsStreaming\n      });\n    } else {\n      const m = _getMetadata(file);\n      doc = new tl_1.Api.DocumentAttributeVideo({\n        roundMessage: videoNote,\n        w: Number.parseInt((_b = m.get(\"width\")) !== null && _b !== void 0 ? _b : \"1\"),\n        h: Number.parseInt((_c = m.get(\"height\")) !== null && _c !== void 0 ? _c : \"1\"),\n        duration: Number.parseInt((_d = m.get(\"duration\")) !== null && _d !== void 0 ? _d : \"0\"),\n        supportsStreaming: supportsStreaming\n      });\n    }\n    attrObj.set(tl_1.Api.DocumentAttributeVideo, doc);\n  }\n  if (videoNote) {\n    if (attrObj.has(tl_1.Api.DocumentAttributeAudio)) {\n      attrObj.get(tl_1.Api.DocumentAttributeAudio).voice = true;\n    } else {\n      attrObj.set(tl_1.Api.DocumentAttributeAudio, new tl_1.Api.DocumentAttributeAudio({\n        duration: 0,\n        voice: true\n      }));\n    }\n  }\n  /* Now override the attributes if any. As we have a dict of\n  {cls: instance}, we can override any class with the list\n   of attributes provided by the user easily.\n  */\n  if (attributes) {\n    for (const a of attributes) {\n      attrObj.set(a.constructor, a);\n    }\n  }\n  return {\n    attrs: Array.from(attrObj.values()),\n    mimeType: mimeType\n  };\n}\n/**\n *  Similar to :meth:`get_input_peer`, but for geo points\n */\nfunction getInputGeo(geo) {\n  if (geo === undefined || geo.SUBCLASS_OF_ID === undefined) {\n    _raiseCastFail(geo, \"InputGeoPoint\");\n  }\n  if (geo.SUBCLASS_OF_ID === 0x430d225) {\n    // crc32(b'InputGeoPoint'):\n    return geo;\n  }\n  if (geo instanceof tl_1.Api.GeoPoint) {\n    return new tl_1.Api.InputGeoPoint({\n      lat: geo.lat,\n      long: geo.long\n    });\n  }\n  if (geo instanceof tl_1.Api.GeoPointEmpty) {\n    return new tl_1.Api.InputGeoPointEmpty();\n  }\n  if (geo instanceof tl_1.Api.MessageMediaGeo) {\n    return getInputGeo(geo.geo);\n  }\n  if (geo instanceof tl_1.Api.Message) {\n    return getInputGeo(geo.media);\n  }\n  _raiseCastFail(geo, \"InputGeoPoint\");\n}\n/**\n *\n Similar to :meth:`get_input_peer`, but for media.\n\n If the media is :tl:`InputFile` and ``is_photo`` is known to be `True`,\n it will be treated as an :tl:`InputMediaUploadedPhoto`. Else, the rest\n of parameters will indicate how to treat it.\n * @param media\n * @param isPhoto - whether it's a photo or not\n * @param attributes\n * @param forceDocument\n * @param voiceNote\n * @param videoNote\n * @param supportsStreaming\n */\nfunction getInputMedia(media, {\n  isPhoto = false,\n  attributes = undefined,\n  forceDocument = false,\n  voiceNote = false,\n  videoNote = false,\n  supportsStreaming = false\n} = {}) {\n  if (media.SUBCLASS_OF_ID === undefined) {\n    _raiseCastFail(media, \"InputMedia\");\n  }\n  if (media.SUBCLASS_OF_ID === 0xfaf846f4) {\n    // crc32(b'InputMedia')\n    return media;\n  } else {\n    if (media.SUBCLASS_OF_ID === 2221106144) {\n      // crc32(b'InputPhoto')\n      return new tl_1.Api.InputMediaPhoto({\n        id: media\n      });\n    } else {\n      if (media.SUBCLASS_OF_ID === 4081048424) {\n        // crc32(b'InputDocument')\n        return new tl_1.Api.InputMediaDocument({\n          id: media\n        });\n      }\n    }\n  }\n  if (media instanceof tl_1.Api.MessageMediaPhoto) {\n    return new tl_1.Api.InputMediaPhoto({\n      id: getInputPhoto(media.photo),\n      ttlSeconds: media.ttlSeconds\n    });\n  }\n  if (media instanceof tl_1.Api.Photo || media instanceof tl_1.Api.photos.Photo || media instanceof tl_1.Api.PhotoEmpty) {\n    return new tl_1.Api.InputMediaPhoto({\n      id: getInputPhoto(media)\n    });\n  }\n  if (media instanceof tl_1.Api.MessageMediaDocument) {\n    return new tl_1.Api.InputMediaDocument({\n      id: getInputDocument(media.document),\n      ttlSeconds: media.ttlSeconds\n    });\n  }\n  if (media instanceof tl_1.Api.Document || media instanceof tl_1.Api.DocumentEmpty) {\n    return new tl_1.Api.InputMediaDocument({\n      id: getInputDocument(media)\n    });\n  }\n  if (media instanceof tl_1.Api.InputFile || media instanceof tl_1.Api.InputFileBig) {\n    if (isPhoto) {\n      return new tl_1.Api.InputMediaUploadedPhoto({\n        file: media\n      });\n    } else {\n      const {\n        attrs,\n        mimeType\n      } = getAttributes(media, {\n        attributes: attributes,\n        forceDocument: forceDocument,\n        voiceNote: voiceNote,\n        videoNote: videoNote,\n        supportsStreaming: supportsStreaming\n      });\n      return new tl_1.Api.InputMediaUploadedDocument({\n        file: media,\n        mimeType: mimeType,\n        attributes: attrs,\n        forceFile: forceDocument\n      });\n    }\n  }\n  if (media instanceof tl_1.Api.MessageMediaGame) {\n    return new tl_1.Api.InputMediaGame({\n      id: new tl_1.Api.InputGameID({\n        id: media.game.id,\n        accessHash: media.game.accessHash\n      })\n    });\n  }\n  if (media instanceof tl_1.Api.MessageMediaContact) {\n    return new tl_1.Api.InputMediaContact({\n      phoneNumber: media.phoneNumber,\n      firstName: media.firstName,\n      lastName: media.lastName,\n      vcard: \"\"\n    });\n  }\n  if (media instanceof tl_1.Api.MessageMediaGeo) {\n    return new tl_1.Api.InputMediaGeoPoint({\n      geoPoint: getInputGeo(media.geo)\n    });\n  }\n  if (media instanceof tl_1.Api.MessageMediaVenue) {\n    return new tl_1.Api.InputMediaVenue({\n      geoPoint: getInputGeo(media.geo),\n      title: media.title,\n      address: media.address,\n      provider: media.provider,\n      venueId: media.venueId,\n      venueType: \"\"\n    });\n  }\n  if (media instanceof tl_1.Api.MessageMediaDice) {\n    return new tl_1.Api.InputMediaDice({\n      emoticon: media.emoticon\n    });\n  }\n  if (media instanceof tl_1.Api.MessageMediaEmpty || media instanceof tl_1.Api.MessageMediaUnsupported || media instanceof tl_1.Api.ChatPhotoEmpty || media instanceof tl_1.Api.UserProfilePhotoEmpty || media instanceof tl_1.Api.ChatPhoto || media instanceof tl_1.Api.UserProfilePhoto) {\n    return new tl_1.Api.InputMediaEmpty();\n  }\n  if (media instanceof tl_1.Api.Message) {\n    return getInputMedia(media.media, {\n      isPhoto: isPhoto\n    });\n  }\n  if (media instanceof tl_1.Api.MessageMediaPoll) {\n    let correctAnswers;\n    if (media.poll.quiz) {\n      if (!media.results.results) {\n        throw new Error(\"Cannot cast unanswered quiz to any kind of InputMedia.\");\n      }\n      correctAnswers = [];\n      for (const r of media.results.results) {\n        if (r.correct) {\n          correctAnswers.push(r.option);\n        }\n      }\n    } else {\n      correctAnswers = undefined;\n    }\n    return new tl_1.Api.InputMediaPoll({\n      poll: media.poll,\n      correctAnswers: correctAnswers,\n      solution: media.results.solution,\n      solutionEntities: media.results.solutionEntities\n    });\n  }\n  if (media instanceof tl_1.Api.Poll) {\n    return new tl_1.Api.InputMediaPoll({\n      poll: media\n    });\n  }\n  _raiseCastFail(media, \"InputMedia\");\n}\n/**\n * Gets the appropriated part size when uploading or downloading files,\n * given an initial file size.\n * @param fileSize\n * @returns {Number}\n */\nfunction getAppropriatedPartSize(fileSize) {\n  if (fileSize.lesser(104857600)) {\n    // 100MB\n    return 128;\n  }\n  if (fileSize.lesser(786432000)) {\n    // 750MB\n    return 256;\n  }\n  return 512;\n}\nfunction getPeer(peer) {\n  if (!peer) {\n    _raiseCastFail(peer, \"undefined\");\n  }\n  if (typeof peer === \"string\") {\n    _raiseCastFail(peer, \"peer\");\n  }\n  if (typeof peer == \"number\" || typeof peer == \"bigint\") {\n    peer = (0, Helpers_1.returnBigInt)(peer);\n  }\n  try {\n    if (big_integer_1.default.isInstance(peer)) {\n      const res = resolveId(peer);\n      if (res[1] === tl_1.Api.PeerChannel) {\n        return new tl_1.Api.PeerChannel({\n          channelId: res[0]\n        });\n      } else if (res[1] === tl_1.Api.PeerChat) {\n        return new tl_1.Api.PeerChat({\n          chatId: res[0]\n        });\n      } else {\n        return new tl_1.Api.PeerUser({\n          userId: res[0]\n        });\n      }\n    }\n    if (peer.SUBCLASS_OF_ID === undefined) {\n      throw new Error();\n    }\n    if (peer.SUBCLASS_OF_ID === 0x2d45687) {\n      // crc32('Peer')\n      return peer;\n    } else if (peer instanceof tl_1.Api.contacts.ResolvedPeer || peer instanceof tl_1.Api.InputNotifyPeer || peer instanceof tl_1.Api.TopPeer || peer instanceof tl_1.Api.Dialog || peer instanceof tl_1.Api.DialogPeer) {\n      return peer.peer;\n    } else if (peer instanceof tl_1.Api.ChannelFull) {\n      return new tl_1.Api.PeerChannel({\n        channelId: peer.id\n      });\n    }\n    if (peer.SUBCLASS_OF_ID === 0x7d7c6f86 || peer.SUBCLASS_OF_ID === 0xd9c7fc18) {\n      // ChatParticipant, ChannelParticipant\n      if (\"userId\" in peer) {\n        return new tl_1.Api.PeerUser({\n          userId: peer.userId\n        });\n      }\n    }\n    peer = getInputPeer(peer, false, false);\n    if (peer instanceof tl_1.Api.InputPeerUser) {\n      return new tl_1.Api.PeerUser({\n        userId: peer.userId\n      });\n    } else if (peer instanceof tl_1.Api.InputPeerChat) {\n      return new tl_1.Api.PeerChat({\n        chatId: peer.chatId\n      });\n    } else if (peer instanceof tl_1.Api.InputPeerChannel) {\n      return new tl_1.Api.PeerChannel({\n        channelId: peer.channelId\n      });\n    }\n  } catch (e) {}\n  _raiseCastFail(peer, \"peer\");\n}\nfunction sanitizeParseMode(mode) {\n  if (mode === \"md\" || mode === \"markdown\") {\n    return markdown_1.MarkdownParser;\n  }\n  if (mode === \"md2\" || mode === \"markdownv2\") {\n    return markdownv2_1.MarkdownV2Parser;\n  }\n  if (mode == \"html\") {\n    return html_1.HTMLParser;\n  }\n  if (typeof mode == \"object\") {\n    if (\"parse\" in mode && \"unparse\" in mode) {\n      return mode;\n    }\n  }\n  throw new Error(`Invalid parse mode type ${mode}`);\n}\n/**\n Convert the given peer into its marked ID by default.\n\n This \"mark\" comes from the \"bot api\" format, and with it the peer type\n can be identified back. User ID is left unmodified, chat ID is negated,\n and channel ID is prefixed with -100:\n\n * ``userId``\n * ``-chatId``\n * ``-100channel_id``\n\n The original ID and the peer type class can be returned with\n a call to :meth:`resolve_id(marked_id)`.\n * @param peer\n * @param addMark\n */\nfunction getPeerId(peer, addMark = true) {\n  if (typeof peer == \"string\" && parseID(peer)) {\n    peer = (0, Helpers_1.returnBigInt)(peer);\n  }\n  // First we assert it's a Peer TLObject, or early return for integers\n  if (big_integer_1.default.isInstance(peer)) {\n    return addMark ? peer.toString() : resolveId(peer)[0].toString();\n  }\n  // Tell the user to use their client to resolve InputPeerSelf if we got one\n  if (peer instanceof tl_1.Api.InputPeerSelf) {\n    _raiseCastFail(peer, \"int (you might want to use client.get_peer_id)\");\n  }\n  try {\n    peer = getPeer(peer);\n  } catch (e) {\n    _raiseCastFail(peer, \"int\");\n  }\n  if (peer instanceof tl_1.Api.PeerUser) {\n    return peer.userId.toString();\n  } else if (peer instanceof tl_1.Api.PeerChat) {\n    // Check in case the user mixed things up to avoid blowing up\n    peer.chatId = resolveId((0, Helpers_1.returnBigInt)(peer.chatId))[0];\n    return addMark ? peer.chatId.negate().toString() : peer.chatId.toString();\n  } else if (typeof peer == \"object\" && \"channelId\" in peer) {\n    // if (peer instanceof Api.PeerChannel)\n    // Check in case the user mixed things up to avoid blowing up\n    peer.channelId = resolveId((0, Helpers_1.returnBigInt)(peer.channelId))[0];\n    if (!addMark) {\n      return peer.channelId.toString();\n    }\n    // Concat -100 through math tricks, .to_supergroup() on\n    // Madeline IDs will be strictly positive -> log works.\n    return \"-100\" + peer.channelId.toString();\n  }\n  _raiseCastFail(peer, \"int\");\n}\n/**\n * Given a marked ID, returns the original ID and its :tl:`Peer` type.\n * @param markedId\n */\nfunction resolveId(markedId) {\n  if (markedId.greaterOrEquals(big_integer_1.default.zero)) {\n    return [markedId, tl_1.Api.PeerUser];\n  }\n  // There have been report of chat IDs being 10000xyz, which means their\n  // marked version is -10000xyz, which in turn looks like a channel but\n  // it becomes 00xyz (= xyz). Hence, we must assert that there are only\n  // two zeroes.\n  const m = markedId.toString().match(/-100([^0]\\d*)/);\n  if (m) {\n    return [(0, big_integer_1.default)(m[1]), tl_1.Api.PeerChannel];\n  }\n  return [markedId.negate(), tl_1.Api.PeerChat];\n}\n/**\n * returns an entity pair\n * @param entityId\n * @param entities\n * @param cache\n * @param getInputPeer\n * @returns {{inputEntity: *, entity: *}}\n * @private\n */\n/*CONTEST\n\nexport function  _getEntityPair(entityId, entities, cache, getInputPeer = getInputPeer) {\n    const entity = entities.get(entityId)\n    let inputEntity = cache[entityId]\n    if (inputEntity === undefined) {\n        try {\n            inputEntity = getInputPeer(inputEntity)\n        } catch (e) {\n            inputEntity = null\n        }\n    }\n    return {\n        entity,\n        inputEntity\n    }\n}\n*/\nfunction getMessageId(message) {\n  if (!message) {\n    return undefined;\n  } else if (typeof message === \"number\") {\n    return message;\n  } else if (message.SUBCLASS_OF_ID === 0x790009e3 || \"id\" in message) {\n    // crc32(b'Message')\n    return message.id;\n  } else {\n    throw new Error(`Invalid message type: ${message.constructor.name}`);\n  }\n}\n/**\n * Parses the given phone, or returns `undefined` if it's invalid.\n * @param phone\n */\nfunction parsePhone(phone) {\n  phone = phone.toString().replace(/[()\\s-]/gm, \"\");\n  if (phone.startsWith(\"+\") && phone.split(\"+\").length - 1 == 1) {\n    return !isNaN(Number(phone)) ? phone.replace(\"+\", \"\") : undefined;\n  }\n}\n/**\n * Parses a string ID into a big int\n * @param id\n */\nfunction parseID(id) {\n  const isValid = /^(-?[0-9][0-9]*)$/.test(id);\n  return isValid ? (0, big_integer_1.default)(id) : undefined;\n}\nfunction resolveInviteLink(link) {\n  throw new Error(\"not implemented\");\n}\n/**\n Parses the given username or channel access hash, given\n a string, username or URL. Returns a tuple consisting of\n both the stripped, lowercase username and whether it is\n a joinchat/ hash (in which case is not lowercase'd).\n\n Returns ``(undefined, false)`` if the ``username`` or link is not valid.\n\n * @param username {string}\n */\nfunction parseUsername(username) {\n  username = username.trim();\n  const m = username.match(USERNAME_RE) || username.match(TG_JOIN_RE);\n  if (m) {\n    username = username.replace(m[0], \"\");\n    if (m[1]) {\n      return {\n        username: username,\n        isInvite: true\n      };\n    } else {\n      username = rtrim(username, \"/\");\n    }\n  }\n  if (username.match(VALID_USERNAME_RE)) {\n    return {\n      username: username.toLowerCase(),\n      isInvite: false\n    };\n  } else {\n    return {\n      username: undefined,\n      isInvite: false\n    };\n  }\n}\nfunction rtrim(s, mask) {\n  while (~mask.indexOf(s[s.length - 1])) {\n    s = s.slice(0, -1);\n  }\n  return s;\n}\n/**\n * Gets the display name for the given :tl:`User`,\n :tl:`Chat` or :tl:`Channel`. Returns an empty string otherwise\n * @param entity\n */\nfunction getDisplayName(entity) {\n  if (entity instanceof tl_1.Api.User) {\n    if (entity.lastName && entity.firstName) {\n      return `${entity.firstName} ${entity.lastName}`;\n    } else if (entity.firstName) {\n      return entity.firstName;\n    } else if (entity.lastName) {\n      return entity.lastName;\n    } else {\n      return \"\";\n    }\n  } else if (entity instanceof tl_1.Api.Chat || entity instanceof tl_1.Api.Channel) {\n    return entity.title;\n  }\n  return \"\";\n}\n/**\n * check if a given item is an array like or not\n * @param item\n * @returns {boolean}\n */\n/*CONTEST\nDuplicate ?\nexport function  isListLike(item) {\n    return (\n        Array.isArray(item) ||\n        (!!item &&\n            typeof item === 'object' &&\n            typeof (item.length) === 'number' &&\n            (item.length === 0 ||\n                (item.length > 0 &&\n                    (item.length - 1) in item)\n            )\n        )\n    )\n}\n*/","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}