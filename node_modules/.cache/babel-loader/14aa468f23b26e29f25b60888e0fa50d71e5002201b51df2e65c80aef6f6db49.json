{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MarkdownParser = void 0;\nconst messageParse_1 = require(\"../client/messageParse\");\nclass MarkdownParser {\n  // TODO maybe there is a better way :shrug:\n  static parse(message) {\n    let i = 0;\n    const keys = {};\n    for (const k in messageParse_1.DEFAULT_DELIMITERS) {\n      keys[k] = false;\n    }\n    const entities = [];\n    const tempEntities = {};\n    while (i < message.length) {\n      let foundIndex = -1;\n      let foundDelim = undefined;\n      for (const key of Object.keys(messageParse_1.DEFAULT_DELIMITERS)) {\n        const index = message.indexOf(key, i);\n        if (index > -1 && (foundIndex === -1 || index < foundIndex)) {\n          foundIndex = index;\n          foundDelim = key;\n        }\n      }\n      if (foundIndex === -1 || foundDelim == undefined) {\n        break;\n      }\n      if (!keys[foundDelim]) {\n        tempEntities[foundDelim] = new messageParse_1.DEFAULT_DELIMITERS[foundDelim]({\n          offset: foundIndex,\n          length: -1,\n          language: \"\"\n        });\n        keys[foundDelim] = true;\n      } else {\n        keys[foundDelim] = false;\n        tempEntities[foundDelim].length = foundIndex - tempEntities[foundDelim].offset;\n        entities.push(tempEntities[foundDelim]);\n      }\n      message = message.toString().replace(foundDelim, \"\");\n      i = foundIndex;\n    }\n    return [message, entities];\n  }\n  static unparse(text, entities) {\n    const delimiters = messageParse_1.DEFAULT_DELIMITERS;\n    if (!text || !entities) {\n      return text;\n    }\n    let insertAt = [];\n    const tempDelimiters = new Map();\n    Object.keys(delimiters).forEach(key => {\n      tempDelimiters.set(delimiters[key].className, key);\n    });\n    for (const entity of entities) {\n      const s = entity.offset;\n      const e = entity.offset + entity.length;\n      const delimiter = tempDelimiters.get(entity.className);\n      if (delimiter) {\n        insertAt.push([s, delimiter]);\n        insertAt.push([e, delimiter]);\n      }\n    }\n    insertAt = insertAt.sort((a, b) => {\n      return a[0] - b[0];\n    });\n    while (insertAt.length) {\n      const [at, what] = insertAt.pop();\n      text = text.slice(0, at) + what + text.slice(at);\n    }\n    return text;\n  }\n}\nexports.MarkdownParser = MarkdownParser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}