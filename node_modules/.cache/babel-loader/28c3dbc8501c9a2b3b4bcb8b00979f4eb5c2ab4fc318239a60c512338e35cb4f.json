{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MarkdownParser = void 0;\nconst messageParse_1 = require(\"../client/messageParse\");\nclass MarkdownParser {\n  // TODO maybe there is a better way :shrug:\n  static parse(message) {\n    let i = 0;\n    const keys = {};\n    for (const k in messageParse_1.DEFAULT_DELIMITERS) {\n      keys[k] = false;\n    }\n    const entities = [];\n    const tempEntities = {};\n    while (i < message.length) {\n      let foundIndex = -1;\n      let foundDelim = undefined;\n      for (const key of Object.keys(messageParse_1.DEFAULT_DELIMITERS)) {\n        const index = message.indexOf(key, i);\n        if (index > -1 && (foundIndex === -1 || index < foundIndex)) {\n          foundIndex = index;\n          foundDelim = key;\n        }\n      }\n      if (foundIndex === -1 || foundDelim == undefined) {\n        break;\n      }\n      if (!keys[foundDelim]) {\n        tempEntities[foundDelim] = new messageParse_1.DEFAULT_DELIMITERS[foundDelim]({\n          offset: foundIndex,\n          length: -1,\n          language: \"\"\n        });\n        keys[foundDelim] = true;\n      } else {\n        keys[foundDelim] = false;\n        tempEntities[foundDelim].length = foundIndex - tempEntities[foundDelim].offset;\n        entities.push(tempEntities[foundDelim]);\n      }\n      message = message.toString().replace(foundDelim, \"\");\n      i = foundIndex;\n    }\n    return [message, entities];\n  }\n  static unparse(text, entities) {\n    const delimiters = messageParse_1.DEFAULT_DELIMITERS;\n    if (!text || !entities) {\n      return text;\n    }\n    let insertAt = [];\n    const tempDelimiters = new Map();\n    Object.keys(delimiters).forEach(key => {\n      tempDelimiters.set(delimiters[key].className, key);\n    });\n    for (const entity of entities) {\n      const s = entity.offset;\n      const e = entity.offset + entity.length;\n      const delimiter = tempDelimiters.get(entity.className);\n      if (delimiter) {\n        insertAt.push([s, delimiter]);\n        insertAt.push([e, delimiter]);\n      }\n    }\n    insertAt = insertAt.sort((a, b) => {\n      return a[0] - b[0];\n    });\n    while (insertAt.length) {\n      const [at, what] = insertAt.pop();\n      text = text.slice(0, at) + what + text.slice(at);\n    }\n    return text;\n  }\n}\nexports.MarkdownParser = MarkdownParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","MarkdownParser","messageParse_1","require","parse","message","i","keys","k","DEFAULT_DELIMITERS","entities","tempEntities","length","foundIndex","foundDelim","undefined","key","index","indexOf","offset","language","push","toString","replace","unparse","text","delimiters","insertAt","tempDelimiters","Map","forEach","set","className","entity","s","e","delimiter","get","sort","a","b","at","what","pop","slice"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/extensions/markdown.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MarkdownParser = void 0;\nconst messageParse_1 = require(\"../client/messageParse\");\nclass MarkdownParser {\n    // TODO maybe there is a better way :shrug:\n    static parse(message) {\n        let i = 0;\n        const keys = {};\n        for (const k in messageParse_1.DEFAULT_DELIMITERS) {\n            keys[k] = false;\n        }\n        const entities = [];\n        const tempEntities = {};\n        while (i < message.length) {\n            let foundIndex = -1;\n            let foundDelim = undefined;\n            for (const key of Object.keys(messageParse_1.DEFAULT_DELIMITERS)) {\n                const index = message.indexOf(key, i);\n                if (index > -1 && (foundIndex === -1 || index < foundIndex)) {\n                    foundIndex = index;\n                    foundDelim = key;\n                }\n            }\n            if (foundIndex === -1 || foundDelim == undefined) {\n                break;\n            }\n            if (!keys[foundDelim]) {\n                tempEntities[foundDelim] = new messageParse_1.DEFAULT_DELIMITERS[foundDelim]({\n                    offset: foundIndex,\n                    length: -1,\n                    language: \"\",\n                });\n                keys[foundDelim] = true;\n            }\n            else {\n                keys[foundDelim] = false;\n                tempEntities[foundDelim].length =\n                    foundIndex - tempEntities[foundDelim].offset;\n                entities.push(tempEntities[foundDelim]);\n            }\n            message = message.toString().replace(foundDelim, \"\");\n            i = foundIndex;\n        }\n        return [message, entities];\n    }\n    static unparse(text, entities) {\n        const delimiters = messageParse_1.DEFAULT_DELIMITERS;\n        if (!text || !entities) {\n            return text;\n        }\n        let insertAt = [];\n        const tempDelimiters = new Map();\n        Object.keys(delimiters).forEach((key) => {\n            tempDelimiters.set(delimiters[key].className, key);\n        });\n        for (const entity of entities) {\n            const s = entity.offset;\n            const e = entity.offset + entity.length;\n            const delimiter = tempDelimiters.get(entity.className);\n            if (delimiter) {\n                insertAt.push([s, delimiter]);\n                insertAt.push([e, delimiter]);\n            }\n        }\n        insertAt = insertAt.sort((a, b) => {\n            return a[0] - b[0];\n        });\n        while (insertAt.length) {\n            const [at, what] = insertAt.pop();\n            text = text.slice(0, at) + what + text.slice(at);\n        }\n        return text;\n    }\n}\nexports.MarkdownParser = MarkdownParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}