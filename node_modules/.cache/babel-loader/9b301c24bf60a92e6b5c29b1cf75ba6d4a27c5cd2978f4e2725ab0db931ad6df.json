{"ast":null,"code":"\"use strict\";\n\nconst {\n  inspect\n} = require(\"../inspect\");\nconst bigInt = require(\"big-integer\");\nconst {\n  generateRandomBytes,\n  readBigIntFromBuffer,\n  isArrayLike,\n  betterConsoleLog\n} = require(\"../Helpers\");\nconst tlContent = require(\"./apiTl.js\");\nconst schemeContent = require(\"./schemaTl.js\");\nfunction generateRandomBigInt() {\n  return readBigIntFromBuffer(generateRandomBytes(8), false, true);\n}\nconst {\n  parseTl,\n  serializeBytes,\n  serializeDate\n} = require(\"./generationHelpers\");\nconst {\n  toSignedLittleBuffer\n} = require(\"../Helpers\");\nconst NAMED_AUTO_CASTS = new Set([\"chatId,int\"]);\nconst NAMED_BLACKLIST = new Set([\"discardEncryption\"]);\nconst AUTO_CASTS = new Set([\"InputPeer\", \"InputChannel\", \"InputUser\", \"InputDialogPeer\", \"InputNotifyPeer\", \"InputMedia\", \"InputPhoto\", \"InputMessage\", \"InputDocument\", \"InputChatPhoto\"]);\nclass CastError extends Error {\n  constructor(objectName, expected, actual) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    const message = \"Found wrong type for \" + objectName + \". expected \" + expected + \" but received \" + actual + \".If you think this is a mistake please report it.\";\n    for (var _len = arguments.length, params = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      params[_key - 3] = arguments[_key];\n    }\n    super(message, ...params);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CastError);\n    }\n    this.name = \"CastError\";\n    // Custom debugging information\n  }\n}\nconst CACHING_SUPPORTED = typeof self !== \"undefined\" && self.localStorage !== undefined;\nconst CACHE_KEY = \"GramJs:apiCache\";\nfunction buildApiFromTlSchema() {\n  let definitions;\n  const fromCache = CACHING_SUPPORTED && loadFromCache();\n  if (fromCache) {\n    definitions = fromCache;\n  } else {\n    definitions = loadFromTlSchemas();\n    if (CACHING_SUPPORTED) {\n      localStorage.setItem(CACHE_KEY, JSON.stringify(definitions));\n    }\n  }\n  return createClasses(\"all\", definitions);\n}\nfunction loadFromCache() {\n  const jsonCache = localStorage.getItem(CACHE_KEY);\n  return jsonCache && JSON.parse(jsonCache);\n}\nfunction loadFromTlSchemas() {\n  const [constructorParamsApi, functionParamsApi] = extractParams(tlContent);\n  const [constructorParamsSchema, functionParamsSchema] = extractParams(schemeContent);\n  const constructors = [].concat(constructorParamsApi, constructorParamsSchema);\n  const requests = [].concat(functionParamsApi, functionParamsSchema);\n  return [].concat(constructors, requests);\n}\nfunction extractParams(fileContent) {\n  const f = parseTl(fileContent, 109);\n  const constructors = [];\n  const functions = [];\n  for (const d of f) {\n    d.isFunction ? functions.push(d) : constructors.push(d);\n  }\n  return [constructors, functions];\n}\nfunction argToBytes(x, type, argName, requestName) {\n  switch (type) {\n    case \"int\":\n      const i = Buffer.alloc(4);\n      i.writeInt32LE(x, 0);\n      return i;\n    case \"long\":\n      return toSignedLittleBuffer(x, 8);\n    case \"int128\":\n      return toSignedLittleBuffer(x, 16);\n    case \"int256\":\n      return toSignedLittleBuffer(x, 32);\n    case \"double\":\n      const d = Buffer.alloc(8);\n      d.writeDoubleLE(x, 0);\n      return d;\n    case \"string\":\n      return serializeBytes(x);\n    case \"Bool\":\n      return x ? Buffer.from(\"b5757299\", \"hex\") : Buffer.from(\"379779bc\", \"hex\");\n    case \"true\":\n      return Buffer.alloc(0);\n    case \"bytes\":\n      return serializeBytes(x);\n    case \"date\":\n      return serializeDate(x);\n    default:\n      if (x === undefined || typeof x.getBytes !== \"function\") {\n        throw new Error(`Required object ${argName} of ${requestName} is undefined`);\n      }\n      return x.getBytes();\n  }\n}\nasync function getInputFromResolve(utils, client, peer, peerType) {\n  switch (peerType) {\n    case \"InputPeer\":\n      return utils.getInputPeer(await client.getInputEntity(peer));\n    case \"InputChannel\":\n      return utils.getInputChannel(await client.getInputEntity(peer));\n    case \"InputUser\":\n      return utils.getInputUser(await client.getInputEntity(peer));\n    case \"InputDialogPeer\":\n      return await client._getInputDialog(peer);\n    case \"InputNotifyPeer\":\n      return await client._getInputNotify(peer);\n    case \"InputMedia\":\n      return utils.getInputMedia(peer);\n    case \"InputPhoto\":\n      return utils.getInputPhoto(peer);\n    case \"InputMessage\":\n      return utils.getInputMessage(peer);\n    case \"InputDocument\":\n      return utils.getInputDocument(peer);\n    case \"InputChatPhoto\":\n      return utils.getInputChatPhoto(peer);\n    case \"chatId,int\":\n      return await client.getPeerId(peer, false);\n    default:\n      throw new Error(\"unsupported peer type : \" + peerType);\n  }\n}\nfunction getArgFromReader(reader, arg) {\n  if (arg.isVector) {\n    if (arg.useVectorId) {\n      reader.readInt();\n    }\n    const temp = [];\n    const len = reader.readInt();\n    arg.isVector = false;\n    for (let i = 0; i < len; i++) {\n      temp.push(getArgFromReader(reader, arg));\n    }\n    arg.isVector = true;\n    return temp;\n  } else if (arg.flagIndicator) {\n    return reader.readInt();\n  } else {\n    switch (arg.type) {\n      case \"int\":\n        return reader.readInt();\n      case \"long\":\n        return reader.readLong();\n      case \"int128\":\n        return reader.readLargeInt(128);\n      case \"int256\":\n        return reader.readLargeInt(256);\n      case \"double\":\n        return reader.readDouble();\n      case \"string\":\n        return reader.tgReadString();\n      case \"Bool\":\n        return reader.tgReadBool();\n      case \"true\":\n        return true;\n      case \"bytes\":\n        return reader.tgReadBytes();\n      case \"date\":\n        return reader.tgReadDate();\n      default:\n        if (!arg.skipConstructorId) {\n          return reader.tgReadObject();\n        } else {\n          return api.constructors[arg.type].fromReader(reader);\n        }\n    }\n  }\n}\nfunction compareType(value, type) {\n  let correct = true;\n  switch (type) {\n    case \"number\":\n      correct = typeof value === \"number\" || value === undefined;\n      break;\n    case \"string\":\n    case \"boolean\":\n      correct = typeof value === type;\n      break;\n    case \"bigInt\":\n      correct = bigInt.isInstance(value) || typeof value === \"bigint\" || typeof value === \"number\" || typeof value === \"string\" || value === undefined;\n      break;\n    case \"true\":\n      // true value is always correct\n      break;\n    case \"buffer\":\n      correct = Buffer.isBuffer(value);\n      break;\n    case \"date\":\n      correct = value && Object.prototype.toString.call(value) === \"[object Date]\" && !isNaN(value) || typeof value === \"number\";\n      break;\n    default:\n      console.error(new Error(\"Unknown type.\" + type));\n  }\n  return correct;\n}\nfunction createClasses(classesType, params) {\n  const classes = {};\n  for (const classParams of params) {\n    const {\n      name,\n      constructorId,\n      subclassOfId,\n      argsConfig,\n      namespace,\n      isFunction,\n      result\n    } = classParams;\n    const fullName = [namespace, name].join(\".\").replace(/^\\./, \"\");\n    class VirtualClass {\n      constructor(args) {\n        this.CONSTRUCTOR_ID = constructorId;\n        this.SUBCLASS_OF_ID = subclassOfId;\n        this.className = fullName;\n        this.classType = isFunction ? \"request\" : \"constructor\";\n        args = args || {};\n        this.originalArgs = args;\n        this.init(args);\n        for (const argName in argsConfig) {\n          if (argName === \"randomId\" && !args[argName]) {\n            if (argsConfig[argName].isVector) {\n              const rands = [];\n              for (let i = 0; i < args[\"id\"].length; i++) {\n                rands.push(generateRandomBigInt());\n              }\n              this[argName] = rands;\n            } else {\n              this[argName] = generateRandomBigInt();\n            }\n          } else {\n            this[argName] = args[argName];\n          }\n        }\n      }\n      init(args) {}\n      static fromReader(reader) {\n        const args = {};\n        for (const argName in argsConfig) {\n          if (argsConfig.hasOwnProperty(argName)) {\n            const arg = argsConfig[argName];\n            if (arg.isFlag) {\n              if (arg.type === \"true\") {\n                args[argName] = Boolean(args[arg.flagName] & 1 << arg.flagIndex);\n                continue;\n              }\n              if (args[arg.flagName] & 1 << arg.flagIndex) {\n                args[argName] = getArgFromReader(reader, arg);\n              } else {\n                args[argName] = null;\n              }\n            } else {\n              if (arg.flagIndicator) {\n                arg.name = argName;\n              }\n              args[argName] = getArgFromReader(reader, arg);\n            }\n          }\n        }\n        return new this(args);\n      }\n      validate() {\n        for (const arg in argsConfig) {\n          if (argsConfig.hasOwnProperty(arg)) {\n            if (argsConfig[arg].flagIndicator || argsConfig[arg].isFlag) {\n              // we don't care about flags\n              continue;\n            }\n            const currentValue = this[arg];\n            this.assertType(arg, argsConfig[arg], currentValue);\n          }\n        }\n      }\n      assertType(objectName, object, value) {\n        let expected;\n        if (object[\"isVector\"]) {\n          if (!isArrayLike(value)) {\n            console.error(new CastError(objectName, \"array\", value));\n          }\n          if (value == undefined) {\n            value = [];\n          }\n          for (const o of value) {\n            this.assertType(objectName, Object.assign(Object.assign({}, object), {\n              isVector: false\n            }), o);\n          }\n        } else {\n          switch (object[\"type\"]) {\n            case \"int\":\n              expected = \"number\";\n              break;\n            case \"long\":\n            case \"int128\":\n            case \"int256\":\n              expected = \"bigInt\";\n              break;\n            case \"double\":\n              expected = \"number\";\n              break;\n            case \"string\":\n              expected = \"string\";\n              break;\n            case \"Bool\":\n              expected = \"boolean\";\n              break;\n            case \"true\":\n              expected = \"true\";\n              break;\n            case \"bytes\":\n              expected = \"buffer\";\n              break;\n            case \"date\":\n              expected = \"date\";\n              break;\n            default:\n              expected = \"object\";\n          }\n          if (expected === \"object\") {\n            // will be validated in get byte();\n          } else {\n            const isCorrectType = compareType(value, expected);\n            if (isCorrectType !== true) {\n              console.error(new CastError(objectName, expected, value));\n            }\n          }\n        }\n      }\n      getBytes() {\n        try {\n          this.validate();\n        } catch (e) {\n          // feature still in alpha so errors are expected.\n        }\n        const idForBytes = this.CONSTRUCTOR_ID;\n        const c = Buffer.alloc(4);\n        c.writeUInt32LE(idForBytes, 0);\n        const buffers = [c];\n        for (const arg in argsConfig) {\n          if (argsConfig.hasOwnProperty(arg)) {\n            if (argsConfig[arg].isFlag) {\n              if (this[arg] === false && argsConfig[arg].type !== \"Bool\" || this[arg] === null || this[arg] === undefined || argsConfig[arg].type === \"true\") {\n                continue;\n              }\n            }\n            if (argsConfig[arg].isVector) {\n              if (argsConfig[arg].useVectorId) {\n                buffers.push(Buffer.from(\"15c4b51c\", \"hex\"));\n              }\n              const l = Buffer.alloc(4);\n              l.writeInt32LE(this[arg].length, 0);\n              buffers.push(l, Buffer.concat(this[arg].map(x => argToBytes(x, argsConfig[arg].type, fullName))));\n            } else if (argsConfig[arg].flagIndicator) {\n              if (!Object.values(argsConfig).some(f => f.isFlag)) {\n                buffers.push(Buffer.alloc(4));\n              } else {\n                let flagCalculate = 0;\n                for (const f in argsConfig) {\n                  if (argsConfig[f].isFlag && arg === argsConfig[f].flagName) {\n                    if (this[f] === false && argsConfig[f].type !== \"Bool\" || this[f] === undefined || this[f] === null) {\n                      flagCalculate |= 0;\n                    } else {\n                      flagCalculate |= 1 << argsConfig[f].flagIndex;\n                    }\n                  }\n                }\n                const f = Buffer.alloc(4);\n                f.writeUInt32LE(flagCalculate, 0);\n                buffers.push(f);\n              }\n            } else {\n              buffers.push(argToBytes(this[arg], argsConfig[arg].type, arg, fullName));\n              if (this[arg] && typeof this[arg].getBytes === \"function\") {\n                let boxed = argsConfig[arg].type.charAt(argsConfig[arg].type.indexOf(\".\") + 1);\n                boxed = boxed === boxed.toUpperCase();\n                if (!boxed) {\n                  buffers.shift();\n                }\n              }\n            }\n          }\n        }\n        return Buffer.concat(buffers);\n      }\n      readResult(reader) {\n        if (!isFunction) {\n          throw new Error(\"`readResult()` called for non-request instance\");\n        }\n        const m = result.match(/Vector<(int|long)>/);\n        if (m) {\n          reader.readInt();\n          const temp = [];\n          const len = reader.readInt();\n          if (m[1] === \"int\") {\n            for (let i = 0; i < len; i++) {\n              temp.push(reader.readInt());\n            }\n          } else {\n            for (let i = 0; i < len; i++) {\n              temp.push(reader.readLong());\n            }\n          }\n          return temp;\n        } else {\n          return reader.tgReadObject();\n        }\n      }\n      async resolve(client, utils) {\n        if (!isFunction) {\n          throw new Error(\"`resolve()` called for non-request instance\");\n        }\n        for (const arg in argsConfig) {\n          if (argsConfig.hasOwnProperty(arg)) {\n            if (!AUTO_CASTS.has(argsConfig[arg].type)) {\n              if (!NAMED_AUTO_CASTS.has(`${argsConfig[arg].name},${argsConfig[arg].type}`)) {\n                continue;\n              }\n            }\n            if (argsConfig[arg].isFlag) {\n              if (!this[arg]) {\n                continue;\n              }\n            }\n            if (argsConfig[arg].isVector) {\n              const temp = [];\n              for (const x of this[arg]) {\n                temp.push(await getInputFromResolve(utils, client, x, argsConfig[arg].type));\n              }\n              this[arg] = temp;\n            } else {\n              this[arg] = await getInputFromResolve(utils, client, this[arg], argsConfig[arg].type);\n            }\n          }\n        }\n      }\n      [inspect.custom]() {\n        return betterConsoleLog(this);\n      }\n      toJSON() {\n        return Object.assign(Object.assign({}, this.originalArgs), {\n          className: fullName\n        });\n      }\n    }\n    VirtualClass.CONSTRUCTOR_ID = constructorId;\n    VirtualClass.SUBCLASS_OF_ID = subclassOfId;\n    VirtualClass.className = fullName;\n    VirtualClass.classType = isFunction ? \"request\" : \"constructor\";\n    if (namespace) {\n      if (!classes[namespace]) {\n        classes[namespace] = {};\n      }\n      classes[namespace][name] = VirtualClass;\n    } else {\n      classes[name] = VirtualClass;\n    }\n  }\n  return classes;\n}\nconst api = buildApiFromTlSchema();\nmodule.exports = {\n  Api: api\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}