{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.start = start;\nexports.checkAuthorization = checkAuthorization;\nexports.signInUser = signInUser;\nexports.signInUserWithQrCode = signInUserWithQrCode;\nexports.sendCode = sendCode;\nexports.signInWithPassword = signInWithPassword;\nexports.signInBot = signInBot;\nexports._authFlow = _authFlow;\nconst tl_1 = require(\"../tl\");\nconst utils = __importStar(require(\"../Utils\"));\nconst Helpers_1 = require(\"../Helpers\");\nconst Password_1 = require(\"../Password\");\nconst QR_CODE_TIMEOUT = 30000;\n// region public methods\n/** @hidden */\nasync function start(client, authParams) {\n  if (!client.connected) {\n    await client.connect();\n  }\n  if (await client.checkAuthorization()) {\n    return;\n  }\n  const apiCredentials = {\n    apiId: client.apiId,\n    apiHash: client.apiHash\n  };\n  await _authFlow(client, apiCredentials, authParams);\n}\n/** @hidden */\nasync function checkAuthorization(client) {\n  try {\n    await client.invoke(new tl_1.Api.updates.GetState());\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/** @hidden */\nasync function signInUser(client, apiCredentials, authParams) {\n  let phoneNumber;\n  let phoneCodeHash;\n  let isCodeViaApp = false;\n  while (1) {\n    try {\n      if (typeof authParams.phoneNumber === \"function\") {\n        try {\n          phoneNumber = await authParams.phoneNumber();\n        } catch (err) {\n          if (err.errorMessage === \"RESTART_AUTH_WITH_QR\") {\n            return client.signInUserWithQrCode(apiCredentials, authParams);\n          }\n          throw err;\n        }\n      } else {\n        phoneNumber = authParams.phoneNumber;\n      }\n      const sendCodeResult = await client.sendCode(apiCredentials, phoneNumber, authParams.forceSMS);\n      phoneCodeHash = sendCodeResult.phoneCodeHash;\n      isCodeViaApp = sendCodeResult.isCodeViaApp;\n      if (typeof phoneCodeHash !== \"string\") {\n        throw new Error(\"Failed to retrieve phone code hash\");\n      }\n      break;\n    } catch (err) {\n      if (typeof authParams.phoneNumber !== \"function\") {\n        throw err;\n      }\n      const shouldWeStop = await authParams.onError(err);\n      if (shouldWeStop) {\n        throw new Error(\"AUTH_USER_CANCEL\");\n      }\n    }\n  }\n  let phoneCode;\n  let isRegistrationRequired = false;\n  let termsOfService;\n  while (1) {\n    try {\n      try {\n        phoneCode = await authParams.phoneCode(isCodeViaApp);\n      } catch (err) {\n        // This is the support for changing phone number from the phone code screen.\n        if (err.errorMessage === \"RESTART_AUTH\") {\n          return client.signInUser(apiCredentials, authParams);\n        }\n      }\n      if (!phoneCode) {\n        throw new Error(\"Code is empty\");\n      }\n      // May raise PhoneCodeEmptyError, PhoneCodeExpiredError,\n      // PhoneCodeHashEmptyError or PhoneCodeInvalidError.\n      const result = await client.invoke(new tl_1.Api.auth.SignIn({\n        phoneNumber,\n        phoneCodeHash,\n        phoneCode\n      }));\n      if (result instanceof tl_1.Api.auth.AuthorizationSignUpRequired) {\n        isRegistrationRequired = true;\n        termsOfService = result.termsOfService;\n        break;\n      }\n      return result.user;\n    } catch (err) {\n      if (err.errorMessage === \"SESSION_PASSWORD_NEEDED\") {\n        return client.signInWithPassword(apiCredentials, authParams);\n      } else {\n        const shouldWeStop = await authParams.onError(err);\n        if (shouldWeStop) {\n          throw new Error(\"AUTH_USER_CANCEL\");\n        }\n      }\n    }\n  }\n  if (isRegistrationRequired) {\n    while (1) {\n      try {\n        let lastName;\n        let firstName = \"first name\";\n        if (authParams.firstAndLastNames) {\n          const result = await authParams.firstAndLastNames();\n          firstName = result[0];\n          lastName = result[1];\n        }\n        if (!firstName) {\n          throw new Error(\"First name is required\");\n        }\n        const {\n          user\n        } = await client.invoke(new tl_1.Api.auth.SignUp({\n          phoneNumber,\n          phoneCodeHash,\n          firstName,\n          lastName\n        }));\n        if (termsOfService) {\n          // This is a violation of Telegram rules: the user should be presented with and accept TOS.\n          await client.invoke(new tl_1.Api.help.AcceptTermsOfService({\n            id: termsOfService.id\n          }));\n        }\n        return user;\n      } catch (err) {\n        const shouldWeStop = await authParams.onError(err);\n        if (shouldWeStop) {\n          throw new Error(\"AUTH_USER_CANCEL\");\n        }\n      }\n    }\n  }\n  await authParams.onError(new Error(\"Auth failed\"));\n  return client.signInUser(apiCredentials, authParams);\n}\n/** @hidden */\nasync function signInUserWithQrCode(client, apiCredentials, authParams) {\n  let isScanningComplete = false;\n  if (authParams.qrCode == undefined) {\n    throw new Error(\"qrCode callback not defined\");\n  }\n  const inputPromise = (async () => {\n    while (1) {\n      if (isScanningComplete) {\n        break;\n      }\n      const result = await client.invoke(new tl_1.Api.auth.ExportLoginToken({\n        apiId: Number(apiCredentials.apiId),\n        apiHash: apiCredentials.apiHash,\n        exceptIds: []\n      }));\n      if (!(result instanceof tl_1.Api.auth.LoginToken)) {\n        throw new Error(\"Unexpected\");\n      }\n      const {\n        token,\n        expires\n      } = result;\n      await Promise.race([authParams.qrCode({\n        token,\n        expires\n      }), (0, Helpers_1.sleep)(QR_CODE_TIMEOUT)]);\n      await (0, Helpers_1.sleep)(QR_CODE_TIMEOUT);\n    }\n  })();\n  const updatePromise = new Promise(resolve => {\n    client.addEventHandler(update => {\n      if (update instanceof tl_1.Api.UpdateLoginToken) {\n        resolve(undefined);\n      }\n    });\n  });\n  try {\n    await Promise.race([updatePromise, inputPromise]);\n  } catch (err) {\n    throw err;\n  } finally {\n    isScanningComplete = true;\n  }\n  try {\n    const result2 = await client.invoke(new tl_1.Api.auth.ExportLoginToken({\n      apiId: Number(apiCredentials.apiId),\n      apiHash: apiCredentials.apiHash,\n      exceptIds: []\n    }));\n    if (result2 instanceof tl_1.Api.auth.LoginTokenSuccess && result2.authorization instanceof tl_1.Api.auth.Authorization) {\n      return result2.authorization.user;\n    } else if (result2 instanceof tl_1.Api.auth.LoginTokenMigrateTo) {\n      await client._switchDC(result2.dcId);\n      const migratedResult = await client.invoke(new tl_1.Api.auth.ImportLoginToken({\n        token: result2.token\n      }));\n      if (migratedResult instanceof tl_1.Api.auth.LoginTokenSuccess && migratedResult.authorization instanceof tl_1.Api.auth.Authorization) {\n        return migratedResult.authorization.user;\n      } else {\n        client._log.error(`Received unknown result while scanning QR ${result2.className}`);\n        throw new Error(`Received unknown result while scanning QR ${result2.className}`);\n      }\n    } else {\n      client._log.error(`Received unknown result while scanning QR ${result2.className}`);\n      throw new Error(`Received unknown result while scanning QR ${result2.className}`);\n    }\n  } catch (err) {\n    if (err.errorMessage === \"SESSION_PASSWORD_NEEDED\") {\n      return client.signInWithPassword(apiCredentials, authParams);\n    }\n    throw err;\n  }\n  await authParams.onError(new Error(\"QR auth failed\"));\n  throw new Error(\"QR auth failed\");\n}\n/** @hidden */\nasync function sendCode(client, apiCredentials, phoneNumber) {\n  let forceSMS = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  try {\n    const {\n      apiId,\n      apiHash\n    } = apiCredentials;\n    const sendResult = await client.invoke(new tl_1.Api.auth.SendCode({\n      phoneNumber,\n      apiId,\n      apiHash,\n      settings: new tl_1.Api.CodeSettings({})\n    }));\n    if (sendResult instanceof tl_1.Api.auth.SentCodeSuccess) throw new Error(\"logged in right after sending the code\");\n    // If we already sent a SMS, do not resend the phoneCode (hash may be empty)\n    if (!forceSMS || sendResult.type instanceof tl_1.Api.auth.SentCodeTypeSms) {\n      return {\n        phoneCodeHash: sendResult.phoneCodeHash,\n        isCodeViaApp: sendResult.type instanceof tl_1.Api.auth.SentCodeTypeApp\n      };\n    }\n    const resendResult = await client.invoke(new tl_1.Api.auth.ResendCode({\n      phoneNumber,\n      phoneCodeHash: sendResult.phoneCodeHash\n    }));\n    if (resendResult instanceof tl_1.Api.auth.SentCodeSuccess) throw new Error(\"logged in right after resending the code\");\n    return {\n      phoneCodeHash: resendResult.phoneCodeHash,\n      isCodeViaApp: resendResult.type instanceof tl_1.Api.auth.SentCodeTypeApp\n    };\n  } catch (err) {\n    if (err.errorMessage === \"AUTH_RESTART\") {\n      return client.sendCode(apiCredentials, phoneNumber, forceSMS);\n    } else {\n      throw err;\n    }\n  }\n}\n/** @hidden */\nasync function signInWithPassword(client, apiCredentials, authParams) {\n  let emptyPassword = false;\n  while (1) {\n    try {\n      const passwordSrpResult = await client.invoke(new tl_1.Api.account.GetPassword());\n      if (!authParams.password) {\n        emptyPassword = true;\n        break;\n      }\n      const password = await authParams.password(passwordSrpResult.hint);\n      if (!password) {\n        throw new Error(\"Password is empty\");\n      }\n      const passwordSrpCheck = await (0, Password_1.computeCheck)(passwordSrpResult, password);\n      const {\n        user\n      } = await client.invoke(new tl_1.Api.auth.CheckPassword({\n        password: passwordSrpCheck\n      }));\n      return user;\n    } catch (err) {\n      const shouldWeStop = await authParams.onError(err);\n      if (shouldWeStop) {\n        throw new Error(\"AUTH_USER_CANCEL\");\n      }\n    }\n  }\n  if (emptyPassword) {\n    throw new Error(\"Account has 2FA enabled.\");\n  }\n  return undefined; // Never reached (TypeScript fix)\n}\n/** @hidden */\nasync function signInBot(client, apiCredentials, authParams) {\n  const {\n    apiId,\n    apiHash\n  } = apiCredentials;\n  let {\n    botAuthToken\n  } = authParams;\n  if (!botAuthToken) {\n    throw new Error(\"a valid BotToken is required\");\n  }\n  if (typeof botAuthToken === \"function\") {\n    let token;\n    while (true) {\n      token = await botAuthToken();\n      if (token) {\n        botAuthToken = token;\n        break;\n      }\n    }\n  }\n  const {\n    user\n  } = await client.invoke(new tl_1.Api.auth.ImportBotAuthorization({\n    apiId,\n    apiHash,\n    botAuthToken\n  }));\n  return user;\n}\n/** @hidden */\nasync function _authFlow(client, apiCredentials, authParams) {\n  const me = \"phoneNumber\" in authParams ? await client.signInUser(apiCredentials, authParams) : await client.signInBot(apiCredentials, authParams);\n  client._log.info(\"Signed in successfully as \" + utils.getDisplayName(me));\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}