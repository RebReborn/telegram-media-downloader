{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.start = start;\nexports.checkAuthorization = checkAuthorization;\nexports.signInUser = signInUser;\nexports.signInUserWithQrCode = signInUserWithQrCode;\nexports.sendCode = sendCode;\nexports.signInWithPassword = signInWithPassword;\nexports.signInBot = signInBot;\nexports._authFlow = _authFlow;\nconst tl_1 = require(\"../tl\");\nconst utils = __importStar(require(\"../Utils\"));\nconst Helpers_1 = require(\"../Helpers\");\nconst Password_1 = require(\"../Password\");\nconst QR_CODE_TIMEOUT = 30000;\n// region public methods\n/** @hidden */\nasync function start(client, authParams) {\n  if (!client.connected) {\n    await client.connect();\n  }\n  if (await client.checkAuthorization()) {\n    return;\n  }\n  const apiCredentials = {\n    apiId: client.apiId,\n    apiHash: client.apiHash\n  };\n  await _authFlow(client, apiCredentials, authParams);\n}\n/** @hidden */\nasync function checkAuthorization(client) {\n  try {\n    await client.invoke(new tl_1.Api.updates.GetState());\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/** @hidden */\nasync function signInUser(client, apiCredentials, authParams) {\n  let phoneNumber;\n  let phoneCodeHash;\n  let isCodeViaApp = false;\n  while (1) {\n    try {\n      if (typeof authParams.phoneNumber === \"function\") {\n        try {\n          phoneNumber = await authParams.phoneNumber();\n        } catch (err) {\n          if (err.errorMessage === \"RESTART_AUTH_WITH_QR\") {\n            return client.signInUserWithQrCode(apiCredentials, authParams);\n          }\n          throw err;\n        }\n      } else {\n        phoneNumber = authParams.phoneNumber;\n      }\n      const sendCodeResult = await client.sendCode(apiCredentials, phoneNumber, authParams.forceSMS);\n      phoneCodeHash = sendCodeResult.phoneCodeHash;\n      isCodeViaApp = sendCodeResult.isCodeViaApp;\n      if (typeof phoneCodeHash !== \"string\") {\n        throw new Error(\"Failed to retrieve phone code hash\");\n      }\n      break;\n    } catch (err) {\n      if (typeof authParams.phoneNumber !== \"function\") {\n        throw err;\n      }\n      const shouldWeStop = await authParams.onError(err);\n      if (shouldWeStop) {\n        throw new Error(\"AUTH_USER_CANCEL\");\n      }\n    }\n  }\n  let phoneCode;\n  let isRegistrationRequired = false;\n  let termsOfService;\n  while (1) {\n    try {\n      try {\n        phoneCode = await authParams.phoneCode(isCodeViaApp);\n      } catch (err) {\n        // This is the support for changing phone number from the phone code screen.\n        if (err.errorMessage === \"RESTART_AUTH\") {\n          return client.signInUser(apiCredentials, authParams);\n        }\n      }\n      if (!phoneCode) {\n        throw new Error(\"Code is empty\");\n      }\n      // May raise PhoneCodeEmptyError, PhoneCodeExpiredError,\n      // PhoneCodeHashEmptyError or PhoneCodeInvalidError.\n      const result = await client.invoke(new tl_1.Api.auth.SignIn({\n        phoneNumber,\n        phoneCodeHash,\n        phoneCode\n      }));\n      if (result instanceof tl_1.Api.auth.AuthorizationSignUpRequired) {\n        isRegistrationRequired = true;\n        termsOfService = result.termsOfService;\n        break;\n      }\n      return result.user;\n    } catch (err) {\n      if (err.errorMessage === \"SESSION_PASSWORD_NEEDED\") {\n        return client.signInWithPassword(apiCredentials, authParams);\n      } else {\n        const shouldWeStop = await authParams.onError(err);\n        if (shouldWeStop) {\n          throw new Error(\"AUTH_USER_CANCEL\");\n        }\n      }\n    }\n  }\n  if (isRegistrationRequired) {\n    while (1) {\n      try {\n        let lastName;\n        let firstName = \"first name\";\n        if (authParams.firstAndLastNames) {\n          const result = await authParams.firstAndLastNames();\n          firstName = result[0];\n          lastName = result[1];\n        }\n        if (!firstName) {\n          throw new Error(\"First name is required\");\n        }\n        const {\n          user\n        } = await client.invoke(new tl_1.Api.auth.SignUp({\n          phoneNumber,\n          phoneCodeHash,\n          firstName,\n          lastName\n        }));\n        if (termsOfService) {\n          // This is a violation of Telegram rules: the user should be presented with and accept TOS.\n          await client.invoke(new tl_1.Api.help.AcceptTermsOfService({\n            id: termsOfService.id\n          }));\n        }\n        return user;\n      } catch (err) {\n        const shouldWeStop = await authParams.onError(err);\n        if (shouldWeStop) {\n          throw new Error(\"AUTH_USER_CANCEL\");\n        }\n      }\n    }\n  }\n  await authParams.onError(new Error(\"Auth failed\"));\n  return client.signInUser(apiCredentials, authParams);\n}\n/** @hidden */\nasync function signInUserWithQrCode(client, apiCredentials, authParams) {\n  let isScanningComplete = false;\n  if (authParams.qrCode == undefined) {\n    throw new Error(\"qrCode callback not defined\");\n  }\n  const inputPromise = (async () => {\n    while (1) {\n      if (isScanningComplete) {\n        break;\n      }\n      const result = await client.invoke(new tl_1.Api.auth.ExportLoginToken({\n        apiId: Number(apiCredentials.apiId),\n        apiHash: apiCredentials.apiHash,\n        exceptIds: []\n      }));\n      if (!(result instanceof tl_1.Api.auth.LoginToken)) {\n        throw new Error(\"Unexpected\");\n      }\n      const {\n        token,\n        expires\n      } = result;\n      await Promise.race([authParams.qrCode({\n        token,\n        expires\n      }), (0, Helpers_1.sleep)(QR_CODE_TIMEOUT)]);\n      await (0, Helpers_1.sleep)(QR_CODE_TIMEOUT);\n    }\n  })();\n  const updatePromise = new Promise(resolve => {\n    client.addEventHandler(update => {\n      if (update instanceof tl_1.Api.UpdateLoginToken) {\n        resolve(undefined);\n      }\n    });\n  });\n  try {\n    await Promise.race([updatePromise, inputPromise]);\n  } catch (err) {\n    throw err;\n  } finally {\n    isScanningComplete = true;\n  }\n  try {\n    const result2 = await client.invoke(new tl_1.Api.auth.ExportLoginToken({\n      apiId: Number(apiCredentials.apiId),\n      apiHash: apiCredentials.apiHash,\n      exceptIds: []\n    }));\n    if (result2 instanceof tl_1.Api.auth.LoginTokenSuccess && result2.authorization instanceof tl_1.Api.auth.Authorization) {\n      return result2.authorization.user;\n    } else if (result2 instanceof tl_1.Api.auth.LoginTokenMigrateTo) {\n      await client._switchDC(result2.dcId);\n      const migratedResult = await client.invoke(new tl_1.Api.auth.ImportLoginToken({\n        token: result2.token\n      }));\n      if (migratedResult instanceof tl_1.Api.auth.LoginTokenSuccess && migratedResult.authorization instanceof tl_1.Api.auth.Authorization) {\n        return migratedResult.authorization.user;\n      } else {\n        client._log.error(`Received unknown result while scanning QR ${result2.className}`);\n        throw new Error(`Received unknown result while scanning QR ${result2.className}`);\n      }\n    } else {\n      client._log.error(`Received unknown result while scanning QR ${result2.className}`);\n      throw new Error(`Received unknown result while scanning QR ${result2.className}`);\n    }\n  } catch (err) {\n    if (err.errorMessage === \"SESSION_PASSWORD_NEEDED\") {\n      return client.signInWithPassword(apiCredentials, authParams);\n    }\n    throw err;\n  }\n  await authParams.onError(new Error(\"QR auth failed\"));\n  throw new Error(\"QR auth failed\");\n}\n/** @hidden */\nasync function sendCode(client, apiCredentials, phoneNumber, forceSMS = false) {\n  try {\n    const {\n      apiId,\n      apiHash\n    } = apiCredentials;\n    const sendResult = await client.invoke(new tl_1.Api.auth.SendCode({\n      phoneNumber,\n      apiId,\n      apiHash,\n      settings: new tl_1.Api.CodeSettings({})\n    }));\n    if (sendResult instanceof tl_1.Api.auth.SentCodeSuccess) throw new Error(\"logged in right after sending the code\");\n    // If we already sent a SMS, do not resend the phoneCode (hash may be empty)\n    if (!forceSMS || sendResult.type instanceof tl_1.Api.auth.SentCodeTypeSms) {\n      return {\n        phoneCodeHash: sendResult.phoneCodeHash,\n        isCodeViaApp: sendResult.type instanceof tl_1.Api.auth.SentCodeTypeApp\n      };\n    }\n    const resendResult = await client.invoke(new tl_1.Api.auth.ResendCode({\n      phoneNumber,\n      phoneCodeHash: sendResult.phoneCodeHash\n    }));\n    if (resendResult instanceof tl_1.Api.auth.SentCodeSuccess) throw new Error(\"logged in right after resending the code\");\n    return {\n      phoneCodeHash: resendResult.phoneCodeHash,\n      isCodeViaApp: resendResult.type instanceof tl_1.Api.auth.SentCodeTypeApp\n    };\n  } catch (err) {\n    if (err.errorMessage === \"AUTH_RESTART\") {\n      return client.sendCode(apiCredentials, phoneNumber, forceSMS);\n    } else {\n      throw err;\n    }\n  }\n}\n/** @hidden */\nasync function signInWithPassword(client, apiCredentials, authParams) {\n  let emptyPassword = false;\n  while (1) {\n    try {\n      const passwordSrpResult = await client.invoke(new tl_1.Api.account.GetPassword());\n      if (!authParams.password) {\n        emptyPassword = true;\n        break;\n      }\n      const password = await authParams.password(passwordSrpResult.hint);\n      if (!password) {\n        throw new Error(\"Password is empty\");\n      }\n      const passwordSrpCheck = await (0, Password_1.computeCheck)(passwordSrpResult, password);\n      const {\n        user\n      } = await client.invoke(new tl_1.Api.auth.CheckPassword({\n        password: passwordSrpCheck\n      }));\n      return user;\n    } catch (err) {\n      const shouldWeStop = await authParams.onError(err);\n      if (shouldWeStop) {\n        throw new Error(\"AUTH_USER_CANCEL\");\n      }\n    }\n  }\n  if (emptyPassword) {\n    throw new Error(\"Account has 2FA enabled.\");\n  }\n  return undefined; // Never reached (TypeScript fix)\n}\n/** @hidden */\nasync function signInBot(client, apiCredentials, authParams) {\n  const {\n    apiId,\n    apiHash\n  } = apiCredentials;\n  let {\n    botAuthToken\n  } = authParams;\n  if (!botAuthToken) {\n    throw new Error(\"a valid BotToken is required\");\n  }\n  if (typeof botAuthToken === \"function\") {\n    let token;\n    while (true) {\n      token = await botAuthToken();\n      if (token) {\n        botAuthToken = token;\n        break;\n      }\n    }\n  }\n  const {\n    user\n  } = await client.invoke(new tl_1.Api.auth.ImportBotAuthorization({\n    apiId,\n    apiHash,\n    botAuthToken\n  }));\n  return user;\n}\n/** @hidden */\nasync function _authFlow(client, apiCredentials, authParams) {\n  const me = \"phoneNumber\" in authParams ? await client.signInUser(apiCredentials, authParams) : await client.signInBot(apiCredentials, authParams);\n  client._log.info(\"Signed in successfully as \" + utils.getDisplayName(me));\n}","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","start","checkAuthorization","signInUser","signInUserWithQrCode","sendCode","signInWithPassword","signInBot","_authFlow","tl_1","require","utils","Helpers_1","Password_1","QR_CODE_TIMEOUT","client","authParams","connected","connect","apiCredentials","apiId","apiHash","invoke","Api","updates","GetState","e","phoneNumber","phoneCodeHash","isCodeViaApp","err","errorMessage","sendCodeResult","forceSMS","Error","shouldWeStop","onError","phoneCode","isRegistrationRequired","termsOfService","auth","SignIn","AuthorizationSignUpRequired","user","lastName","firstName","firstAndLastNames","SignUp","help","AcceptTermsOfService","id","isScanningComplete","qrCode","inputPromise","ExportLoginToken","Number","exceptIds","LoginToken","token","expires","Promise","race","sleep","updatePromise","resolve","addEventHandler","update","UpdateLoginToken","result2","LoginTokenSuccess","authorization","Authorization","LoginTokenMigrateTo","_switchDC","dcId","migratedResult","ImportLoginToken","_log","error","className","sendResult","SendCode","settings","CodeSettings","SentCodeSuccess","type","SentCodeTypeSms","SentCodeTypeApp","resendResult","ResendCode","emptyPassword","passwordSrpResult","account","GetPassword","password","hint","passwordSrpCheck","computeCheck","CheckPassword","botAuthToken","ImportBotAuthorization","me","info","getDisplayName"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/client/auth.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.start = start;\nexports.checkAuthorization = checkAuthorization;\nexports.signInUser = signInUser;\nexports.signInUserWithQrCode = signInUserWithQrCode;\nexports.sendCode = sendCode;\nexports.signInWithPassword = signInWithPassword;\nexports.signInBot = signInBot;\nexports._authFlow = _authFlow;\nconst tl_1 = require(\"../tl\");\nconst utils = __importStar(require(\"../Utils\"));\nconst Helpers_1 = require(\"../Helpers\");\nconst Password_1 = require(\"../Password\");\nconst QR_CODE_TIMEOUT = 30000;\n// region public methods\n/** @hidden */\nasync function start(client, authParams) {\n    if (!client.connected) {\n        await client.connect();\n    }\n    if (await client.checkAuthorization()) {\n        return;\n    }\n    const apiCredentials = {\n        apiId: client.apiId,\n        apiHash: client.apiHash,\n    };\n    await _authFlow(client, apiCredentials, authParams);\n}\n/** @hidden */\nasync function checkAuthorization(client) {\n    try {\n        await client.invoke(new tl_1.Api.updates.GetState());\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n/** @hidden */\nasync function signInUser(client, apiCredentials, authParams) {\n    let phoneNumber;\n    let phoneCodeHash;\n    let isCodeViaApp = false;\n    while (1) {\n        try {\n            if (typeof authParams.phoneNumber === \"function\") {\n                try {\n                    phoneNumber = await authParams.phoneNumber();\n                }\n                catch (err) {\n                    if (err.errorMessage === \"RESTART_AUTH_WITH_QR\") {\n                        return client.signInUserWithQrCode(apiCredentials, authParams);\n                    }\n                    throw err;\n                }\n            }\n            else {\n                phoneNumber = authParams.phoneNumber;\n            }\n            const sendCodeResult = await client.sendCode(apiCredentials, phoneNumber, authParams.forceSMS);\n            phoneCodeHash = sendCodeResult.phoneCodeHash;\n            isCodeViaApp = sendCodeResult.isCodeViaApp;\n            if (typeof phoneCodeHash !== \"string\") {\n                throw new Error(\"Failed to retrieve phone code hash\");\n            }\n            break;\n        }\n        catch (err) {\n            if (typeof authParams.phoneNumber !== \"function\") {\n                throw err;\n            }\n            const shouldWeStop = await authParams.onError(err);\n            if (shouldWeStop) {\n                throw new Error(\"AUTH_USER_CANCEL\");\n            }\n        }\n    }\n    let phoneCode;\n    let isRegistrationRequired = false;\n    let termsOfService;\n    while (1) {\n        try {\n            try {\n                phoneCode = await authParams.phoneCode(isCodeViaApp);\n            }\n            catch (err) {\n                // This is the support for changing phone number from the phone code screen.\n                if (err.errorMessage === \"RESTART_AUTH\") {\n                    return client.signInUser(apiCredentials, authParams);\n                }\n            }\n            if (!phoneCode) {\n                throw new Error(\"Code is empty\");\n            }\n            // May raise PhoneCodeEmptyError, PhoneCodeExpiredError,\n            // PhoneCodeHashEmptyError or PhoneCodeInvalidError.\n            const result = await client.invoke(new tl_1.Api.auth.SignIn({\n                phoneNumber,\n                phoneCodeHash,\n                phoneCode,\n            }));\n            if (result instanceof tl_1.Api.auth.AuthorizationSignUpRequired) {\n                isRegistrationRequired = true;\n                termsOfService = result.termsOfService;\n                break;\n            }\n            return result.user;\n        }\n        catch (err) {\n            if (err.errorMessage === \"SESSION_PASSWORD_NEEDED\") {\n                return client.signInWithPassword(apiCredentials, authParams);\n            }\n            else {\n                const shouldWeStop = await authParams.onError(err);\n                if (shouldWeStop) {\n                    throw new Error(\"AUTH_USER_CANCEL\");\n                }\n            }\n        }\n    }\n    if (isRegistrationRequired) {\n        while (1) {\n            try {\n                let lastName;\n                let firstName = \"first name\";\n                if (authParams.firstAndLastNames) {\n                    const result = await authParams.firstAndLastNames();\n                    firstName = result[0];\n                    lastName = result[1];\n                }\n                if (!firstName) {\n                    throw new Error(\"First name is required\");\n                }\n                const { user } = (await client.invoke(new tl_1.Api.auth.SignUp({\n                    phoneNumber,\n                    phoneCodeHash,\n                    firstName,\n                    lastName,\n                })));\n                if (termsOfService) {\n                    // This is a violation of Telegram rules: the user should be presented with and accept TOS.\n                    await client.invoke(new tl_1.Api.help.AcceptTermsOfService({\n                        id: termsOfService.id,\n                    }));\n                }\n                return user;\n            }\n            catch (err) {\n                const shouldWeStop = await authParams.onError(err);\n                if (shouldWeStop) {\n                    throw new Error(\"AUTH_USER_CANCEL\");\n                }\n            }\n        }\n    }\n    await authParams.onError(new Error(\"Auth failed\"));\n    return client.signInUser(apiCredentials, authParams);\n}\n/** @hidden */\nasync function signInUserWithQrCode(client, apiCredentials, authParams) {\n    let isScanningComplete = false;\n    if (authParams.qrCode == undefined) {\n        throw new Error(\"qrCode callback not defined\");\n    }\n    const inputPromise = (async () => {\n        while (1) {\n            if (isScanningComplete) {\n                break;\n            }\n            const result = await client.invoke(new tl_1.Api.auth.ExportLoginToken({\n                apiId: Number(apiCredentials.apiId),\n                apiHash: apiCredentials.apiHash,\n                exceptIds: [],\n            }));\n            if (!(result instanceof tl_1.Api.auth.LoginToken)) {\n                throw new Error(\"Unexpected\");\n            }\n            const { token, expires } = result;\n            await Promise.race([\n                authParams.qrCode({ token, expires }),\n                (0, Helpers_1.sleep)(QR_CODE_TIMEOUT),\n            ]);\n            await (0, Helpers_1.sleep)(QR_CODE_TIMEOUT);\n        }\n    })();\n    const updatePromise = new Promise((resolve) => {\n        client.addEventHandler((update) => {\n            if (update instanceof tl_1.Api.UpdateLoginToken) {\n                resolve(undefined);\n            }\n        });\n    });\n    try {\n        await Promise.race([updatePromise, inputPromise]);\n    }\n    catch (err) {\n        throw err;\n    }\n    finally {\n        isScanningComplete = true;\n    }\n    try {\n        const result2 = await client.invoke(new tl_1.Api.auth.ExportLoginToken({\n            apiId: Number(apiCredentials.apiId),\n            apiHash: apiCredentials.apiHash,\n            exceptIds: [],\n        }));\n        if (result2 instanceof tl_1.Api.auth.LoginTokenSuccess &&\n            result2.authorization instanceof tl_1.Api.auth.Authorization) {\n            return result2.authorization.user;\n        }\n        else if (result2 instanceof tl_1.Api.auth.LoginTokenMigrateTo) {\n            await client._switchDC(result2.dcId);\n            const migratedResult = await client.invoke(new tl_1.Api.auth.ImportLoginToken({\n                token: result2.token,\n            }));\n            if (migratedResult instanceof tl_1.Api.auth.LoginTokenSuccess &&\n                migratedResult.authorization instanceof tl_1.Api.auth.Authorization) {\n                return migratedResult.authorization.user;\n            }\n            else {\n                client._log.error(`Received unknown result while scanning QR ${result2.className}`);\n                throw new Error(`Received unknown result while scanning QR ${result2.className}`);\n            }\n        }\n        else {\n            client._log.error(`Received unknown result while scanning QR ${result2.className}`);\n            throw new Error(`Received unknown result while scanning QR ${result2.className}`);\n        }\n    }\n    catch (err) {\n        if (err.errorMessage === \"SESSION_PASSWORD_NEEDED\") {\n            return client.signInWithPassword(apiCredentials, authParams);\n        }\n        throw err;\n    }\n    await authParams.onError(new Error(\"QR auth failed\"));\n    throw new Error(\"QR auth failed\");\n}\n/** @hidden */\nasync function sendCode(client, apiCredentials, phoneNumber, forceSMS = false) {\n    try {\n        const { apiId, apiHash } = apiCredentials;\n        const sendResult = await client.invoke(new tl_1.Api.auth.SendCode({\n            phoneNumber,\n            apiId,\n            apiHash,\n            settings: new tl_1.Api.CodeSettings({}),\n        }));\n        if (sendResult instanceof tl_1.Api.auth.SentCodeSuccess)\n            throw new Error(\"logged in right after sending the code\");\n        // If we already sent a SMS, do not resend the phoneCode (hash may be empty)\n        if (!forceSMS || sendResult.type instanceof tl_1.Api.auth.SentCodeTypeSms) {\n            return {\n                phoneCodeHash: sendResult.phoneCodeHash,\n                isCodeViaApp: sendResult.type instanceof tl_1.Api.auth.SentCodeTypeApp,\n            };\n        }\n        const resendResult = await client.invoke(new tl_1.Api.auth.ResendCode({\n            phoneNumber,\n            phoneCodeHash: sendResult.phoneCodeHash,\n        }));\n        if (resendResult instanceof tl_1.Api.auth.SentCodeSuccess)\n            throw new Error(\"logged in right after resending the code\");\n        return {\n            phoneCodeHash: resendResult.phoneCodeHash,\n            isCodeViaApp: resendResult.type instanceof tl_1.Api.auth.SentCodeTypeApp,\n        };\n    }\n    catch (err) {\n        if (err.errorMessage === \"AUTH_RESTART\") {\n            return client.sendCode(apiCredentials, phoneNumber, forceSMS);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/** @hidden */\nasync function signInWithPassword(client, apiCredentials, authParams) {\n    let emptyPassword = false;\n    while (1) {\n        try {\n            const passwordSrpResult = await client.invoke(new tl_1.Api.account.GetPassword());\n            if (!authParams.password) {\n                emptyPassword = true;\n                break;\n            }\n            const password = await authParams.password(passwordSrpResult.hint);\n            if (!password) {\n                throw new Error(\"Password is empty\");\n            }\n            const passwordSrpCheck = await (0, Password_1.computeCheck)(passwordSrpResult, password);\n            const { user } = (await client.invoke(new tl_1.Api.auth.CheckPassword({\n                password: passwordSrpCheck,\n            })));\n            return user;\n        }\n        catch (err) {\n            const shouldWeStop = await authParams.onError(err);\n            if (shouldWeStop) {\n                throw new Error(\"AUTH_USER_CANCEL\");\n            }\n        }\n    }\n    if (emptyPassword) {\n        throw new Error(\"Account has 2FA enabled.\");\n    }\n    return undefined; // Never reached (TypeScript fix)\n}\n/** @hidden */\nasync function signInBot(client, apiCredentials, authParams) {\n    const { apiId, apiHash } = apiCredentials;\n    let { botAuthToken } = authParams;\n    if (!botAuthToken) {\n        throw new Error(\"a valid BotToken is required\");\n    }\n    if (typeof botAuthToken === \"function\") {\n        let token;\n        while (true) {\n            token = await botAuthToken();\n            if (token) {\n                botAuthToken = token;\n                break;\n            }\n        }\n    }\n    const { user } = (await client.invoke(new tl_1.Api.auth.ImportBotAuthorization({\n        apiId,\n        apiHash,\n        botAuthToken,\n    })));\n    return user;\n}\n/** @hidden */\nasync function _authFlow(client, apiCredentials, authParams) {\n    const me = \"phoneNumber\" in authParams\n        ? await client.signInUser(apiCredentials, authParams)\n        : await client.signInBot(apiCredentials, authParams);\n    client._log.info(\"Signed in successfully as \" + utils.getDisplayName(me));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}