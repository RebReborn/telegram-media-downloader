{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BinaryReader = void 0;\nconst errors_1 = require(\"../errors\");\nconst core_1 = require(\"../tl/core\");\nconst AllTLObjects_1 = require(\"../tl/AllTLObjects\");\nconst Helpers_1 = require(\"../Helpers\");\nclass BinaryReader {\n  /**\n   * Small utility class to read binary data.\n   * @param data {Buffer}\n   */\n  constructor(data) {\n    this.stream = data;\n    this._last = undefined;\n    this.offset = 0;\n  }\n  // region Reading\n  // \"All numbers are written as little endian.\"\n  // https://core.telegram.org/mtproto\n  /**\n   * Reads a single byte value.\n   */\n  readByte() {\n    return this.read(1)[0];\n  }\n  /**\n   * Reads an integer (4 bytes or 32 bits) value.\n   * @param signed {Boolean}\n   */\n  readInt(signed = true) {\n    let res;\n    if (signed) {\n      res = this.stream.readInt32LE(this.offset);\n    } else {\n      res = this.stream.readUInt32LE(this.offset);\n    }\n    this.offset += 4;\n    return res;\n  }\n  /**\n   * Reads a long integer (8 bytes or 64 bits) value.\n   * @param signed\n   * @returns {BigInteger}\n   */\n  readLong(signed = true) {\n    return this.readLargeInt(64, signed);\n  }\n  /**\n   * Reads a real floating point (4 bytes) value.\n   * @returns {number}\n   */\n  readFloat() {\n    return this.read(4).readFloatLE(0);\n  }\n  /**\n   * Reads a real floating point (8 bytes) value.\n   * @returns {BigInteger}\n   */\n  readDouble() {\n    // was this a bug ? it should have been <d\n    return this.read(8).readDoubleLE(0);\n  }\n  /**\n   * Reads a n-bits long integer value.\n   * @param bits\n   * @param signed {Boolean}\n   */\n  readLargeInt(bits, signed = true) {\n    const buffer = this.read(Math.floor(bits / 8));\n    return (0, Helpers_1.readBigIntFromBuffer)(buffer, true, signed);\n  }\n  /**\n   * Read the given amount of bytes, or -1 to read all remaining.\n   * @param length {number}\n   * @param checkLength {boolean} whether to check if the length overflows or not.\n   */\n  read(length = -1, checkLength = true) {\n    if (length === -1) {\n      length = this.stream.length - this.offset;\n    }\n    const result = this.stream.slice(this.offset, this.offset + length);\n    this.offset += length;\n    if (checkLength && result.length !== length) {\n      throw Error(`No more data left to read (need ${length}, got ${result.length}: ${result}); last read ${this._last}`);\n    }\n    this._last = result;\n    return result;\n  }\n  /**\n   * Gets the byte array representing the current buffer as a whole.\n   * @returns {Buffer}\n   */\n  getBuffer() {\n    return this.stream;\n  }\n  // endregion\n  // region Telegram custom reading\n  /**\n   * Reads a Telegram-encoded byte array, without the need of\n   * specifying its length.\n   * @returns {Buffer}\n   */\n  tgReadBytes() {\n    const firstByte = this.readByte();\n    let padding;\n    let length;\n    if (firstByte === 254) {\n      length = this.readByte() | this.readByte() << 8 | this.readByte() << 16;\n      padding = length % 4;\n    } else {\n      length = firstByte;\n      padding = (length + 1) % 4;\n    }\n    const data = this.read(length);\n    if (padding > 0) {\n      padding = 4 - padding;\n      this.read(padding);\n    }\n    return data;\n  }\n  /**\n   * Reads a Telegram-encoded string.\n   * @returns {string}\n   */\n  tgReadString() {\n    return this.tgReadBytes().toString(\"utf-8\");\n  }\n  /**\n   * Reads a Telegram boolean value.\n   * @returns {boolean}\n   */\n  tgReadBool() {\n    const value = this.readInt(false);\n    if (value === 0x997275b5) {\n      // boolTrue\n      return true;\n    } else if (value === 0xbc799737) {\n      // boolFalse\n      return false;\n    } else {\n      throw new Error(`Invalid boolean code ${value.toString(16)}`);\n    }\n  }\n  /**\n   * Reads and converts Unix time (used by Telegram)\n   * into a Javascript {Date} object.\n   * @returns {Date}\n   */\n  tgReadDate() {\n    const value = this.readInt();\n    return new Date(value * 1000);\n  }\n  /**\n   * Reads a Telegram object.\n   */\n  tgReadObject() {\n    const constructorId = this.readInt(false);\n    let clazz = AllTLObjects_1.tlobjects[constructorId];\n    if (clazz === undefined) {\n      /**\n       * The class was undefined, but there's still a\n       * chance of it being a manually parsed value like bool!\n       */\n      const value = constructorId;\n      if (value === 0x997275b5) {\n        // boolTrue\n        return true;\n      } else if (value === 0xbc799737) {\n        // boolFalse\n        return false;\n      } else if (value === 0x1cb5c415) {\n        // Vector\n        const temp = [];\n        const length = this.readInt();\n        for (let i = 0; i < length; i++) {\n          temp.push(this.tgReadObject());\n        }\n        return temp;\n      }\n      clazz = core_1.coreObjects.get(constructorId);\n      if (clazz === undefined) {\n        // If there was still no luck, give up\n        this.seek(-4); // Go back\n        const pos = this.tellPosition();\n        const error = new errors_1.TypeNotFoundError(constructorId, this.read());\n        this.setPosition(pos);\n        throw error;\n      }\n    }\n    return clazz.fromReader(this);\n  }\n  /**\n   * Reads a vector (a list) of Telegram objects.\n   * @returns {[Buffer]}\n   */\n  tgReadVector() {\n    if (this.readInt(false) !== 0x1cb5c415) {\n      throw new Error(\"Invalid constructor code, vector was expected\");\n    }\n    const count = this.readInt();\n    const temp = [];\n    for (let i = 0; i < count; i++) {\n      temp.push(this.tgReadObject());\n    }\n    return temp;\n  }\n  // endregion\n  // region Position related\n  /**\n   * Tells the current position on the stream.\n   * @returns {number}\n   */\n  tellPosition() {\n    return this.offset;\n  }\n  /**\n   * Sets the current position on the stream.\n   * @param position\n   */\n  setPosition(position) {\n    this.offset = position;\n  }\n  /**\n   * Seeks the stream position given an offset from the current position.\n   * The offset may be negative.\n   * @param offset\n   */\n  seek(offset) {\n    this.offset += offset;\n  }\n}\nexports.BinaryReader = BinaryReader;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}