{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CustomFile = void 0;\nexports.uploadFile = uploadFile;\nexports._fileToMedia = _fileToMedia;\nexports._sendAlbum = _sendAlbum;\nexports.sendFile = sendFile;\nconst tl_1 = require(\"../tl\");\nconst Helpers_1 = require(\"../Helpers\");\nconst Utils_1 = require(\"../Utils\");\nconst path_1 = __importDefault(require(\"./path\"));\nconst fs_1 = require(\"./fs\");\nconst index_1 = require(\"../index\");\nconst messageParse_1 = require(\"./messageParse\");\nconst messages_1 = require(\"./messages\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\n/**\n * A custom file class that mimics the browser's File class.<br/>\n * You should use this whenever you want to upload a file.\n */\nclass CustomFile {\n  constructor(name, size, path, buffer) {\n    this.name = name;\n    this.size = size;\n    this.path = path;\n    this.buffer = buffer;\n  }\n}\nexports.CustomFile = CustomFile;\nclass CustomBuffer {\n  constructor(options) {\n    this.options = options;\n    if (!options.buffer && !options.filePath) {\n      throw new Error(\"Either one of `buffer` or `filePath` should be specified\");\n    }\n  }\n  async slice(begin, end) {\n    const {\n      buffer,\n      filePath\n    } = this.options;\n    if (buffer) {\n      return buffer.slice(begin, end);\n    } else if (filePath) {\n      const buffSize = end - begin;\n      const buff = Buffer.alloc(buffSize);\n      const fHandle = await fs_1.promises.open(filePath, \"r\");\n      await fHandle.read(buff, 0, buffSize, begin);\n      await fHandle.close();\n      return Buffer.from(buff);\n    }\n    return Buffer.alloc(0);\n  }\n}\nconst KB_TO_BYTES = 1024;\nconst LARGE_FILE_THRESHOLD = 10 * 1024 * 1024;\nconst UPLOAD_TIMEOUT = 15 * 1000;\nconst DISCONNECT_SLEEP = 1000;\nconst BUFFER_SIZE_2GB = 2 ** 31;\nconst BUFFER_SIZE_20MB = 20 * 1024 * 1024;\nasync function getFileBuffer(file, fileSize, maxBufferSize) {\n  const options = {};\n  if (fileSize > maxBufferSize && file instanceof CustomFile) {\n    options.filePath = file.path;\n  } else {\n    options.buffer = Buffer.from(await fileToBuffer(file));\n  }\n  return new CustomBuffer(options);\n}\n/** @hidden */\nasync function uploadFile(client, fileParams) {\n  const {\n    file,\n    onProgress\n  } = fileParams;\n  let {\n    workers\n  } = fileParams;\n  const {\n    name,\n    size\n  } = file;\n  const fileId = (0, Helpers_1.readBigIntFromBuffer)((0, Helpers_1.generateRandomBytes)(8), true, true);\n  const isLarge = size > LARGE_FILE_THRESHOLD;\n  const partSize = (0, Utils_1.getAppropriatedPartSize)((0, big_integer_1.default)(size)) * KB_TO_BYTES;\n  const partCount = Math.floor((size + partSize - 1) / partSize);\n  const buffer = await getFileBuffer(file, size, fileParams.maxBufferSize || BUFFER_SIZE_20MB - 1);\n  // Make sure a new sender can be created before starting upload\n  await client.getSender(client.session.dcId);\n  if (!workers || !size) {\n    workers = 1;\n  }\n  if (workers >= partCount) {\n    workers = partCount;\n  }\n  let progress = 0;\n  if (onProgress) {\n    onProgress(progress);\n  }\n  for (let i = 0; i < partCount; i += workers) {\n    const sendingParts = [];\n    let end = i + workers;\n    if (end > partCount) {\n      end = partCount;\n    }\n    for (let j = i; j < end; j++) {\n      let endPart = (j + 1) * partSize;\n      if (endPart > size) {\n        endPart = size;\n      }\n      if (endPart == j * partSize) {\n        break;\n      }\n      const bytes = await buffer.slice(j * partSize, endPart);\n      // eslint-disable-next-line no-loop-func\n      sendingParts.push((async (jMemo, bytesMemo) => {\n        while (true) {\n          let sender;\n          try {\n            // We always upload from the DC we are in\n            sender = await client.getSender(client.session.dcId);\n            await sender.send(isLarge ? new tl_1.Api.upload.SaveBigFilePart({\n              fileId,\n              filePart: jMemo,\n              fileTotalParts: partCount,\n              bytes: bytesMemo\n            }) : new tl_1.Api.upload.SaveFilePart({\n              fileId,\n              filePart: jMemo,\n              bytes: bytesMemo\n            }));\n          } catch (err) {\n            if (sender && !sender.isConnected()) {\n              await (0, Helpers_1.sleep)(DISCONNECT_SLEEP);\n              continue;\n            } else if (err instanceof index_1.errors.FloodWaitError) {\n              await (0, Helpers_1.sleep)(err.seconds * 1000);\n              continue;\n            }\n            throw err;\n          }\n          if (onProgress) {\n            if (onProgress.isCanceled) {\n              throw new Error(\"USER_CANCELED\");\n            }\n            progress += 1 / partCount;\n            onProgress(progress);\n          }\n          break;\n        }\n      })(j, bytes));\n    }\n    await Promise.all(sendingParts);\n  }\n  return isLarge ? new tl_1.Api.InputFileBig({\n    id: fileId,\n    parts: partCount,\n    name\n  }) : new tl_1.Api.InputFile({\n    id: fileId,\n    parts: partCount,\n    name,\n    md5Checksum: \"\" // This is not a \"flag\", so not sure if we can make it optional.\n  });\n}\n/** @hidden */\nasync function _fileToMedia(client, _ref) {\n  let {\n    file,\n    forceDocument,\n    fileSize,\n    progressCallback,\n    attributes,\n    thumb,\n    voiceNote = false,\n    videoNote = false,\n    supportsStreaming = false,\n    mimeType,\n    asImage,\n    workers = 1\n  } = _ref;\n  if (!file) {\n    return {\n      fileHandle: undefined,\n      media: undefined,\n      image: undefined\n    };\n  }\n  const isImage = index_1.utils.isImage(file);\n  if (asImage == undefined) {\n    asImage = isImage && !forceDocument;\n  }\n  if (typeof file == \"object\" && !Buffer.isBuffer(file) && !(file instanceof tl_1.Api.InputFile) && !(file instanceof tl_1.Api.InputFileBig) && !(file instanceof CustomFile) && !(\"read\" in file)) {\n    try {\n      return {\n        fileHandle: undefined,\n        media: index_1.utils.getInputMedia(file, {\n          isPhoto: asImage,\n          attributes: attributes,\n          forceDocument: forceDocument,\n          voiceNote: voiceNote,\n          videoNote: videoNote,\n          supportsStreaming: supportsStreaming\n        }),\n        image: asImage\n      };\n    } catch (e) {\n      return {\n        fileHandle: undefined,\n        media: undefined,\n        image: isImage\n      };\n    }\n  }\n  let media;\n  let fileHandle;\n  let createdFile;\n  if (file instanceof tl_1.Api.InputFile || file instanceof tl_1.Api.InputFileBig) {\n    fileHandle = file;\n  } else if (typeof file == \"string\" && (file.startsWith(\"https://\") || file.startsWith(\"http://\"))) {\n    if (asImage) {\n      media = new tl_1.Api.InputMediaPhotoExternal({\n        url: file\n      });\n    } else {\n      media = new tl_1.Api.InputMediaDocumentExternal({\n        url: file\n      });\n    }\n  } else if (!(typeof file == \"string\") || (await fs_1.promises.lstat(file)).isFile()) {\n    if (typeof file == \"string\") {\n      createdFile = new CustomFile(path_1.default.basename(file), (await fs_1.promises.stat(file)).size, file);\n    } else if (typeof File !== \"undefined\" && file instanceof File || file instanceof CustomFile) {\n      createdFile = file;\n    } else {\n      let name;\n      if (\"name\" in file) {\n        // @ts-ignore\n        name = file.name;\n      } else {\n        name = \"unnamed\";\n      }\n      if (Buffer.isBuffer(file)) {\n        createdFile = new CustomFile(name, file.length, \"\", file);\n      }\n    }\n    if (!createdFile) {\n      throw new Error(`Could not create file from ${JSON.stringify(file)}`);\n    }\n    fileHandle = await uploadFile(client, {\n      file: createdFile,\n      onProgress: progressCallback,\n      workers: workers\n    });\n  } else {\n    throw new Error(`\"Not a valid path nor a url ${file}`);\n  }\n  if (media != undefined) {} else if (fileHandle == undefined) {\n    throw new Error(`Failed to convert ${file} to media. Not an existing file or an HTTP URL`);\n  } else if (asImage) {\n    media = new tl_1.Api.InputMediaUploadedPhoto({\n      file: fileHandle\n    });\n  } else {\n    // @ts-ignore\n    let res = index_1.utils.getAttributes(file, {\n      mimeType: mimeType,\n      attributes: attributes,\n      forceDocument: forceDocument && !isImage,\n      voiceNote: voiceNote,\n      videoNote: videoNote,\n      supportsStreaming: supportsStreaming,\n      thumb: thumb\n    });\n    attributes = res.attrs;\n    mimeType = res.mimeType;\n    let uploadedThumb;\n    if (!thumb) {\n      uploadedThumb = undefined;\n    } else {\n      // todo refactor\n      if (typeof thumb == \"string\") {\n        uploadedThumb = new CustomFile(path_1.default.basename(thumb), (await fs_1.promises.stat(thumb)).size, thumb);\n      } else if (typeof File !== \"undefined\" && thumb instanceof File) {\n        uploadedThumb = thumb;\n      } else {\n        let name;\n        if (\"name\" in thumb) {\n          name = thumb.name;\n        } else {\n          name = \"unnamed\";\n        }\n        if (Buffer.isBuffer(thumb)) {\n          uploadedThumb = new CustomFile(name, thumb.length, \"\", thumb);\n        }\n      }\n      if (!uploadedThumb) {\n        throw new Error(`Could not create file from ${file}`);\n      }\n      uploadedThumb = await uploadFile(client, {\n        file: uploadedThumb,\n        workers: 1\n      });\n    }\n    media = new tl_1.Api.InputMediaUploadedDocument({\n      file: fileHandle,\n      mimeType: mimeType,\n      attributes: attributes,\n      thumb: uploadedThumb,\n      forceFile: forceDocument && !isImage\n    });\n  }\n  return {\n    fileHandle: fileHandle,\n    media: media,\n    image: asImage\n  };\n}\n/** @hidden */\nasync function _sendAlbum(client, entity, _ref2) {\n  let {\n    file,\n    caption,\n    forceDocument = false,\n    fileSize,\n    clearDraft = false,\n    progressCallback,\n    replyTo,\n    attributes,\n    thumb,\n    parseMode,\n    voiceNote = false,\n    videoNote = false,\n    silent,\n    supportsStreaming = false,\n    scheduleDate,\n    workers = 1,\n    noforwards,\n    commentTo,\n    topMsgId\n  } = _ref2;\n  entity = await client.getInputEntity(entity);\n  let files = [];\n  if (!Array.isArray(file)) {\n    files = [file];\n  } else {\n    files = file;\n  }\n  if (!Array.isArray(caption)) {\n    if (!caption) {\n      caption = \"\";\n    }\n    caption = [caption];\n  }\n  const captions = [];\n  for (const c of caption) {\n    captions.push(await (0, messageParse_1._parseMessageText)(client, c, parseMode));\n  }\n  if (commentTo != undefined) {\n    const discussionData = await (0, messages_1.getCommentData)(client, entity, commentTo);\n    entity = discussionData.entity;\n    replyTo = discussionData.replyTo;\n  } else {\n    replyTo = index_1.utils.getMessageId(replyTo);\n  }\n  if (!attributes) {\n    attributes = [];\n  }\n  let index = 0;\n  const albumFiles = [];\n  for (const file of files) {\n    let {\n      fileHandle,\n      media,\n      image\n    } = await _fileToMedia(client, {\n      file: file,\n      forceDocument: forceDocument,\n      fileSize: fileSize,\n      progressCallback: progressCallback,\n      // @ts-ignore\n      attributes: attributes[index],\n      thumb: thumb,\n      voiceNote: voiceNote,\n      videoNote: videoNote,\n      supportsStreaming: supportsStreaming,\n      workers: workers\n    });\n    index++;\n    if (media instanceof tl_1.Api.InputMediaUploadedPhoto || media instanceof tl_1.Api.InputMediaPhotoExternal) {\n      const r = await client.invoke(new tl_1.Api.messages.UploadMedia({\n        peer: entity,\n        media\n      }));\n      if (r instanceof tl_1.Api.MessageMediaPhoto) {\n        media = (0, Utils_1.getInputMedia)(r.photo);\n      }\n    } else if (media instanceof tl_1.Api.InputMediaUploadedDocument) {\n      const r = await client.invoke(new tl_1.Api.messages.UploadMedia({\n        peer: entity,\n        media\n      }));\n      if (r instanceof tl_1.Api.MessageMediaDocument) {\n        media = (0, Utils_1.getInputMedia)(r.document);\n      }\n    }\n    let text = \"\";\n    let msgEntities = [];\n    if (captions.length) {\n      [text, msgEntities] = captions.shift();\n    }\n    albumFiles.push(new tl_1.Api.InputSingleMedia({\n      media: media,\n      message: text,\n      entities: msgEntities\n    }));\n  }\n  let replyObject = undefined;\n  if (replyTo != undefined) {\n    replyObject = new tl_1.Api.InputReplyToMessage({\n      replyToMsgId: (0, Utils_1.getMessageId)(replyTo),\n      topMsgId: (0, Utils_1.getMessageId)(topMsgId)\n    });\n  }\n  const result = await client.invoke(new tl_1.Api.messages.SendMultiMedia({\n    peer: entity,\n    replyTo: replyObject,\n    multiMedia: albumFiles,\n    silent: silent,\n    scheduleDate: scheduleDate,\n    clearDraft: clearDraft,\n    noforwards: noforwards\n  }));\n  const randomIds = albumFiles.map(m => m.randomId);\n  return client._getResponseMessage(randomIds, result, entity);\n}\n/** @hidden */\nasync function sendFile(client, entity, _ref3) {\n  let {\n    file,\n    caption,\n    forceDocument = false,\n    fileSize,\n    clearDraft = false,\n    progressCallback,\n    replyTo,\n    attributes,\n    thumb,\n    parseMode,\n    formattingEntities,\n    voiceNote = false,\n    videoNote = false,\n    buttons,\n    silent,\n    supportsStreaming = false,\n    scheduleDate,\n    workers = 1,\n    noforwards,\n    commentTo,\n    topMsgId\n  } = _ref3;\n  if (!file) {\n    throw new Error(\"You need to specify a file\");\n  }\n  if (!caption) {\n    caption = \"\";\n  }\n  entity = await client.getInputEntity(entity);\n  if (commentTo != undefined) {\n    const discussionData = await (0, messages_1.getCommentData)(client, entity, commentTo);\n    entity = discussionData.entity;\n    replyTo = discussionData.replyTo;\n  } else {\n    replyTo = index_1.utils.getMessageId(replyTo);\n  }\n  if (Array.isArray(file)) {\n    return await _sendAlbum(client, entity, {\n      file: file,\n      caption: caption,\n      replyTo: replyTo,\n      parseMode: parseMode,\n      attributes: attributes,\n      silent: silent,\n      scheduleDate: scheduleDate,\n      supportsStreaming: supportsStreaming,\n      clearDraft: clearDraft,\n      forceDocument: forceDocument,\n      noforwards: noforwards,\n      topMsgId: topMsgId\n    });\n  }\n  if (Array.isArray(caption)) {\n    caption = caption[0] || \"\";\n  }\n  let msgEntities;\n  if (formattingEntities != undefined) {\n    msgEntities = formattingEntities;\n  } else {\n    [caption, msgEntities] = await (0, messageParse_1._parseMessageText)(client, caption, parseMode);\n  }\n  const {\n    fileHandle,\n    media,\n    image\n  } = await _fileToMedia(client, {\n    file: file,\n    forceDocument: forceDocument,\n    fileSize: fileSize,\n    progressCallback: progressCallback,\n    // @ts-ignore\n    attributes: attributes,\n    thumb: thumb,\n    voiceNote: voiceNote,\n    videoNote: videoNote,\n    supportsStreaming: supportsStreaming,\n    workers: workers\n  });\n  if (media == undefined) {\n    throw new Error(`Cannot use ${file} as file.`);\n  }\n  const markup = client.buildReplyMarkup(buttons);\n  let replyObject = undefined;\n  if (replyTo != undefined) {\n    replyObject = new tl_1.Api.InputReplyToMessage({\n      replyToMsgId: (0, Utils_1.getMessageId)(replyTo),\n      topMsgId: (0, Utils_1.getMessageId)(topMsgId)\n    });\n  }\n  const request = new tl_1.Api.messages.SendMedia({\n    peer: entity,\n    media: media,\n    replyTo: replyObject,\n    message: caption,\n    entities: msgEntities,\n    replyMarkup: markup,\n    silent: silent,\n    scheduleDate: scheduleDate,\n    clearDraft: clearDraft,\n    noforwards: noforwards\n  });\n  const result = await client.invoke(request);\n  return client._getResponseMessage(request, result, entity);\n}\nfunction fileToBuffer(file) {\n  if (typeof File !== \"undefined\" && file instanceof File) {\n    return new Response(file).arrayBuffer();\n  } else if (file instanceof CustomFile) {\n    if (file.buffer != undefined) {\n      return file.buffer;\n    } else {\n      return fs_1.promises.readFile(file.path);\n    }\n  } else {\n    throw new Error(\"Could not create buffer from file \" + file);\n  }\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}