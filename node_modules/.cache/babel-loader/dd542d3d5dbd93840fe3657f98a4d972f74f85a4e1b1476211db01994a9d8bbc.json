{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Factorizator = void 0;\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst Helpers_1 = require(\"../Helpers\");\nclass Factorizator {\n  /**\n   * Calculates the greatest common divisor\n   * @param a {BigInteger}\n   * @param b {BigInteger}\n   * @returns {BigInteger}\n   */\n  static gcd(a, b) {\n    while (b.neq(big_integer_1.default.zero)) {\n      const temp = b;\n      b = a.remainder(b);\n      a = temp;\n    }\n    return a;\n  }\n  /**\n   * Factorizes the given number and returns both the divisor and the number divided by the divisor\n   * @param pq {BigInteger}\n   * @returns {{p: *, q: *}}\n   */\n  static factorize(pq) {\n    if (pq.remainder(2).equals(big_integer_1.default.zero)) {\n      return {\n        p: (0, big_integer_1.default)(2),\n        q: pq.divide((0, big_integer_1.default)(2))\n      };\n    }\n    let y = big_integer_1.default.randBetween((0, big_integer_1.default)(1), pq.minus(1));\n    const c = big_integer_1.default.randBetween((0, big_integer_1.default)(1), pq.minus(1));\n    const m = big_integer_1.default.randBetween((0, big_integer_1.default)(1), pq.minus(1));\n    let g = big_integer_1.default.one;\n    let r = big_integer_1.default.one;\n    let q = big_integer_1.default.one;\n    let x = big_integer_1.default.zero;\n    let ys = big_integer_1.default.zero;\n    let k;\n    while (g.eq(big_integer_1.default.one)) {\n      x = y;\n      for (let i = 0; (0, big_integer_1.default)(i).lesser(r); i++) {\n        y = (0, Helpers_1.modExp)(y, (0, big_integer_1.default)(2), pq).add(c).remainder(pq);\n      }\n      k = big_integer_1.default.zero;\n      while (k.lesser(r) && g.eq(big_integer_1.default.one)) {\n        ys = y;\n        const condition = big_integer_1.default.min(m, r.minus(k));\n        for (let i = 0; (0, big_integer_1.default)(i).lesser(condition); i++) {\n          y = (0, Helpers_1.modExp)(y, (0, big_integer_1.default)(2), pq).add(c).remainder(pq);\n          q = q.multiply(x.minus(y).abs()).remainder(pq);\n        }\n        g = Factorizator.gcd(q, pq);\n        k = k.add(m);\n      }\n      r = r.multiply(2);\n    }\n    if (g.eq(pq)) {\n      while (true) {\n        ys = (0, Helpers_1.modExp)(ys, (0, big_integer_1.default)(2), pq).add(c).remainder(pq);\n        g = Factorizator.gcd(x.minus(ys).abs(), pq);\n        if (g.greater(1)) {\n          break;\n        }\n      }\n    }\n    const p = g;\n    q = pq.divide(g);\n    return p < q ? {\n      p: p,\n      q: q\n    } : {\n      p: q,\n      q: p\n    };\n  }\n}\nexports.Factorizator = Factorizator;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}