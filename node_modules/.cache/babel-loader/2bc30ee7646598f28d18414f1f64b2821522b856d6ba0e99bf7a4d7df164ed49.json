{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._EntityType = exports.TotalList = exports.sleep = exports.isArrayLike = void 0;\nexports.readBigIntFromBuffer = readBigIntFromBuffer;\nexports.generateRandomBigInt = generateRandomBigInt;\nexports.escapeRegex = escapeRegex;\nexports.groupBy = groupBy;\nexports.betterConsoleLog = betterConsoleLog;\nexports.toSignedLittleBuffer = toSignedLittleBuffer;\nexports.readBufferFromBigInt = readBufferFromBigInt;\nexports.generateRandomLong = generateRandomLong;\nexports.mod = mod;\nexports.bigIntMod = bigIntMod;\nexports.generateRandomBytes = generateRandomBytes;\nexports.stripText = stripText;\nexports.generateKeyDataFromNonce = generateKeyDataFromNonce;\nexports.convertToLittle = convertToLittle;\nexports.sha1 = sha1;\nexports.sha256 = sha256;\nexports.modExp = modExp;\nexports.getByteArray = getByteArray;\nexports.returnBigInt = returnBigInt;\nexports.getMinBigInt = getMinBigInt;\nexports.getRandomInt = getRandomInt;\nexports.bufferXor = bufferXor;\nexports.crc32 = crc32;\nexports._entityType = _entityType;\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst CryptoFile_1 = __importDefault(require(\"./CryptoFile\"));\nconst platform_1 = require(\"./platform\");\n/**\n * converts a buffer to big int\n * @param buffer\n * @param little\n * @param signed\n * @returns {bigInt.BigInteger}\n */\nfunction readBigIntFromBuffer(buffer, little = true, signed = false) {\n  let randBuffer = Buffer.from(buffer);\n  const bytesNumber = randBuffer.length;\n  if (little) {\n    randBuffer = randBuffer.reverse();\n  }\n  let bigIntVar = (0, big_integer_1.default)(randBuffer.toString(\"hex\"), 16);\n  if (signed && Math.floor(bigIntVar.toString(2).length / 8) >= bytesNumber) {\n    bigIntVar = bigIntVar.subtract((0, big_integer_1.default)(2).pow((0, big_integer_1.default)(bytesNumber * 8)));\n  }\n  return bigIntVar;\n}\nfunction generateRandomBigInt() {\n  return readBigIntFromBuffer(generateRandomBytes(8), false);\n}\nfunction escapeRegex(string) {\n  return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nfunction groupBy(list, keyGetter) {\n  const map = new Map();\n  list.forEach(item => {\n    const key = keyGetter(item);\n    const collection = map.get(key);\n    if (!collection) {\n      map.set(key, [item]);\n    } else {\n      collection.push(item);\n    }\n  });\n  return map;\n}\n/**\n * Outputs the object in a better way by hiding all the private methods/attributes.\n * @param object - the class to use\n */\nfunction betterConsoleLog(object) {\n  const toPrint = {};\n  for (const key in object) {\n    if (object.hasOwnProperty(key)) {\n      if (!key.startsWith(\"_\") && key != \"originalArgs\") {\n        toPrint[key] = object[key];\n      }\n    }\n  }\n  return toPrint;\n}\n/**\n * Helper to find if a given object is an array (or similar)\n */\nconst isArrayLike = x => x && typeof x.length === \"number\" && typeof x !== \"function\" && typeof x !== \"string\";\nexports.isArrayLike = isArrayLike;\n/*\nexport function addSurrogate(text: string) {\n    let temp = \"\";\n    for (const letter of text) {\n        const t = letter.charCodeAt(0);\n        if (0x1000 < t && t < 0x10FFFF) {\n            const b = Buffer.from(letter, \"utf16le\");\n            const r = String.fromCharCode(b.readUInt16LE(0)) + String.fromCharCode(b.readUInt16LE(2));\n            temp += r;\n        } else {\n            text += letter;\n        }\n    }\n    return temp;\n}\n\n */\n/**\n * Special case signed little ints\n * @param big\n * @param number\n * @returns {Buffer}\n */\nfunction toSignedLittleBuffer(big, number = 8) {\n  const bigNumber = returnBigInt(big);\n  const byteArray = [];\n  for (let i = 0; i < number; i++) {\n    byteArray[i] = bigNumber.shiftRight(8 * i).and(255);\n  }\n  // smh hacks\n  return Buffer.from(byteArray);\n}\n/**\n * converts a big int to a buffer\n * @param bigIntVar {BigInteger}\n * @param bytesNumber\n * @param little\n * @param signed\n * @returns {Buffer}\n */\nfunction readBufferFromBigInt(bigIntVar, bytesNumber, little = true, signed = false) {\n  bigIntVar = (0, big_integer_1.default)(bigIntVar);\n  const bitLength = bigIntVar.bitLength().toJSNumber();\n  const bytes = Math.ceil(bitLength / 8);\n  if (bytesNumber < bytes) {\n    throw new Error(\"OverflowError: int too big to convert\");\n  }\n  if (!signed && bigIntVar.lesser((0, big_integer_1.default)(0))) {\n    throw new Error(\"Cannot convert to unsigned\");\n  }\n  if (signed && bigIntVar.lesser((0, big_integer_1.default)(0))) {\n    bigIntVar = (0, big_integer_1.default)(2).pow((0, big_integer_1.default)(bytesNumber).multiply(8)).add(bigIntVar);\n  }\n  const hex = bigIntVar.toString(16).padStart(bytesNumber * 2, \"0\");\n  let buffer = Buffer.from(hex, \"hex\");\n  if (little) {\n    buffer = buffer.reverse();\n  }\n  return buffer;\n}\n/**\n * Generates a random long integer (8 bytes), which is optionally signed\n * @returns {BigInteger}\n */\nfunction generateRandomLong(signed = true) {\n  return readBigIntFromBuffer(generateRandomBytes(8), true, signed);\n}\n/**\n * .... really javascript\n * @param n {number}\n * @param m {number}\n * @returns {number}\n */\nfunction mod(n, m) {\n  return (n % m + m) % m;\n}\n/**\n * returns a positive bigInt\n * @param n {bigInt.BigInteger}\n * @param m {bigInt.BigInteger}\n * @returns {bigInt.BigInteger}\n */\nfunction bigIntMod(n, m) {\n  return n.remainder(m).add(m).remainder(m);\n}\n/**\n * Generates a random bytes array\n * @param count\n * @returns {Buffer}\n */\nfunction generateRandomBytes(count) {\n  return Buffer.from(CryptoFile_1.default.randomBytes(count));\n}\n/**\n * Calculate the key based on Telegram guidelines, specifying whether it's the client or not\n * @param sharedKey\n * @param msgKey\n * @param client\n * @returns {{iv: Buffer, key: Buffer}}\n */\n/*CONTEST\nthis is mtproto 1 (mostly used for secret chats)\nasync function calcKey(sharedKey, msgKey, client) {\n    const x = client === true ? 0 : 8\n    const [sha1a, sha1b, sha1c, sha1d] = await Promise.all([\n        sha1(Buffer.concat([msgKey, sharedKey.slice(x, x + 32)])),\n        sha1(Buffer.concat([sharedKey.slice(x + 32, x + 48), msgKey, sharedKey.slice(x + 48, x + 64)])),\n        sha1(Buffer.concat([sharedKey.slice(x + 64, x + 96), msgKey])),\n        sha1(Buffer.concat([msgKey, sharedKey.slice(x + 96, x + 128)]))\n    ])\n    const key = Buffer.concat([sha1a.slice(0, 8), sha1b.slice(8, 20), sha1c.slice(4, 16)])\n    const iv = Buffer.concat([sha1a.slice(8, 20), sha1b.slice(0, 8), sha1c.slice(16, 20), sha1d.slice(0, 8)])\n    return {\n        key,\n        iv\n    }\n}\n\n */\nfunction stripText(text, entities) {\n  if (!entities || !entities.length) {\n    return text.trim();\n  }\n  while (text && text[text.length - 1].trim() === \"\") {\n    const e = entities[entities.length - 1];\n    if (e.offset + e.length == text.length) {\n      if (e.length == 1) {\n        entities.pop();\n        if (!entities.length) {\n          return text.trim();\n        }\n      } else {\n        e.length -= 1;\n      }\n    }\n    text = text.slice(0, -1);\n  }\n  while (text && text[0].trim() === \"\") {\n    for (let i = 0; i < entities.length; i++) {\n      const e = entities[i];\n      if (e.offset != 0) {\n        e.offset--;\n        continue;\n      }\n      if (e.length == 1) {\n        entities.shift();\n        if (!entities.length) {\n          return text.trimLeft();\n        }\n      } else {\n        e.length -= 1;\n      }\n    }\n    text = text.slice(1);\n  }\n  return text;\n}\n/**\n * Generates the key data corresponding to the given nonces\n * @param serverNonceBigInt\n * @param newNonceBigInt\n * @returns {{key: Buffer, iv: Buffer}}\n */\nasync function generateKeyDataFromNonce(serverNonceBigInt, newNonceBigInt) {\n  const serverNonce = toSignedLittleBuffer(serverNonceBigInt, 16);\n  const newNonce = toSignedLittleBuffer(newNonceBigInt, 32);\n  const [hash1, hash2, hash3] = await Promise.all([sha1(Buffer.concat([newNonce, serverNonce])), sha1(Buffer.concat([serverNonce, newNonce])), sha1(Buffer.concat([newNonce, newNonce]))]);\n  const keyBuffer = Buffer.concat([hash1, hash2.slice(0, 12)]);\n  const ivBuffer = Buffer.concat([hash2.slice(12, 20), hash3, newNonce.slice(0, 4)]);\n  return {\n    key: keyBuffer,\n    iv: ivBuffer\n  };\n}\nfunction convertToLittle(buf) {\n  const correct = Buffer.alloc(buf.length * 4);\n  for (let i = 0; i < buf.length; i++) {\n    correct.writeUInt32BE(buf[i], i * 4);\n  }\n  return correct;\n}\n/**\n * Calculates the SHA1 digest for the given data\n * @param data\n * @returns {Promise}\n */\nfunction sha1(data) {\n  const shaSum = CryptoFile_1.default.createHash(\"sha1\");\n  shaSum.update(data);\n  // @ts-ignore\n  return shaSum.digest();\n}\n/**\n * Calculates the SHA256 digest for the given data\n * @param data\n * @returns {Promise}\n */\nfunction sha256(data) {\n  const shaSum = CryptoFile_1.default.createHash(\"sha256\");\n  shaSum.update(data);\n  // @ts-ignore\n  return shaSum.digest();\n}\n/**\n * Fast mod pow for RSA calculation. a^b % n\n * @param a\n * @param b\n * @param n\n * @returns {bigInt.BigInteger}\n */\nfunction modExp(a, b, n) {\n  a = a.remainder(n);\n  let result = big_integer_1.default.one;\n  let x = a;\n  while (b.greater(big_integer_1.default.zero)) {\n    const leastSignificantBit = b.remainder((0, big_integer_1.default)(2));\n    b = b.divide((0, big_integer_1.default)(2));\n    if (leastSignificantBit.eq(big_integer_1.default.one)) {\n      result = result.multiply(x);\n      result = result.remainder(n);\n    }\n    x = x.multiply(x);\n    x = x.remainder(n);\n  }\n  return result;\n}\n/**\n * Gets the arbitrary-length byte array corresponding to the given integer\n * @param integer {number,BigInteger}\n * @param signed {boolean}\n * @returns {Buffer}\n */\nfunction getByteArray(integer, signed = false) {\n  const bits = integer.toString(2).length;\n  const byteLength = Math.floor((bits + 8 - 1) / 8);\n  return readBufferFromBigInt(typeof integer == \"number\" ? (0, big_integer_1.default)(integer) : integer, byteLength, false, signed);\n}\nfunction returnBigInt(num) {\n  if (big_integer_1.default.isInstance(num)) {\n    return num;\n  }\n  if (typeof num == \"number\") {\n    return (0, big_integer_1.default)(num);\n  }\n  if (typeof num == \"bigint\") {\n    return (0, big_integer_1.default)(num);\n  }\n  return (0, big_integer_1.default)(num);\n}\n/**\n * Helper function to return the smaller big int in an array\n * @param arrayOfBigInts\n */\nfunction getMinBigInt(arrayOfBigInts) {\n  if (arrayOfBigInts.length == 0) {\n    return big_integer_1.default.zero;\n  }\n  if (arrayOfBigInts.length == 1) {\n    return returnBigInt(arrayOfBigInts[0]);\n  }\n  let smallest = returnBigInt(arrayOfBigInts[0]);\n  for (let i = 1; i < arrayOfBigInts.length; i++) {\n    if (returnBigInt(arrayOfBigInts[i]).lesser(smallest)) {\n      smallest = returnBigInt(arrayOfBigInts[i]);\n    }\n  }\n  return smallest;\n}\n/**\n * returns a random int from min (inclusive) and max (inclusive)\n * @param min\n * @param max\n * @returns {number}\n */\nfunction getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n/**\n * Sleeps a specified amount of time\n * @param ms time in milliseconds\n * @param isUnref make a timer unref'ed\n * @returns {Promise}\n */\nconst sleep = (ms, isUnref = false) => new Promise(resolve => isUnref && platform_1.isNode ? setTimeout(resolve, ms).unref() : setTimeout(resolve, ms));\nexports.sleep = sleep;\n/**\n * Helper to export two buffers of same length\n * @returns {Buffer}\n */\nfunction bufferXor(a, b) {\n  const res = [];\n  for (let i = 0; i < a.length; i++) {\n    res.push(a[i] ^ b[i]);\n  }\n  return Buffer.from(res);\n}\n// Taken from https://stackoverflow.com/questions/18638900/javascript-crc32/18639999#18639999\nfunction makeCRCTable() {\n  let c;\n  const crcTable = [];\n  for (let n = 0; n < 256; n++) {\n    c = n;\n    for (let k = 0; k < 8; k++) {\n      c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;\n    }\n    crcTable[n] = c;\n  }\n  return crcTable;\n}\nlet crcTable = undefined;\nfunction crc32(buf) {\n  if (!crcTable) {\n    crcTable = makeCRCTable();\n  }\n  if (!Buffer.isBuffer(buf)) {\n    buf = Buffer.from(buf);\n  }\n  let crc = -1;\n  for (let index = 0; index < buf.length; index++) {\n    const byte = buf[index];\n    crc = crcTable[(crc ^ byte) & 0xff] ^ crc >>> 8;\n  }\n  return (crc ^ -1) >>> 0;\n}\nclass TotalList extends Array {\n  constructor() {\n    super();\n    this.total = 0;\n  }\n}\nexports.TotalList = TotalList;\nexports._EntityType = {\n  USER: 0,\n  CHAT: 1,\n  CHANNEL: 2\n};\nObject.freeze(exports._EntityType);\nfunction _entityType(entity) {\n  if (typeof entity !== \"object\" || !(\"SUBCLASS_OF_ID\" in entity)) {\n    throw new Error(`${entity} is not a TLObject, cannot determine entity type`);\n  }\n  if (![0x2d45687,\n  // crc32('Peer')\n  0xc91c90b6,\n  // crc32('InputPeer')\n  0xe669bf46,\n  // crc32('InputUser')\n  0x40f202fd,\n  // crc32('InputChannel')\n  0x2da17977,\n  // crc32('User')\n  0xc5af5d94,\n  // crc32('Chat')\n  0x1f4661b9,\n  // crc32('UserFull')\n  0xd49a2697 // crc32('ChatFull')\n  ].includes(entity.SUBCLASS_OF_ID)) {\n    throw new Error(`${entity} does not have any entity type`);\n  }\n  const name = entity.className;\n  if (name.includes(\"User\")) {\n    return exports._EntityType.USER;\n  } else if (name.includes(\"Chat\")) {\n    return exports._EntityType.CHAT;\n  } else if (name.includes(\"Channel\")) {\n    return exports._EntityType.CHANNEL;\n  } else if (name.includes(\"Self\")) {\n    return exports._EntityType.USER;\n  }\n  // 'Empty' in name or not found, we don't care, not a valid entity.\n  throw new Error(`${entity} does not have any entity type`);\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","_EntityType","TotalList","sleep","isArrayLike","readBigIntFromBuffer","generateRandomBigInt","escapeRegex","groupBy","betterConsoleLog","toSignedLittleBuffer","readBufferFromBigInt","generateRandomLong","bigIntMod","generateRandomBytes","stripText","generateKeyDataFromNonce","convertToLittle","sha1","sha256","modExp","getByteArray","returnBigInt","getMinBigInt","getRandomInt","bufferXor","crc32","_entityType","big_integer_1","require","CryptoFile_1","platform_1","buffer","little","signed","randBuffer","Buffer","from","bytesNumber","length","reverse","bigIntVar","default","toString","Math","floor","subtract","pow","string","replace","list","keyGetter","map","Map","forEach","item","key","collection","get","set","push","object","toPrint","hasOwnProperty","startsWith","x","big","number","bigNumber","byteArray","i","shiftRight","and","bitLength","toJSNumber","bytes","ceil","Error","lesser","multiply","add","hex","padStart","n","m","remainder","count","randomBytes","text","entities","trim","e","offset","pop","slice","shift","trimLeft","serverNonceBigInt","newNonceBigInt","serverNonce","newNonce","hash1","hash2","hash3","Promise","all","concat","keyBuffer","ivBuffer","iv","buf","correct","alloc","writeUInt32BE","data","shaSum","createHash","update","digest","a","b","result","one","greater","zero","leastSignificantBit","divide","eq","integer","bits","byteLength","num","isInstance","arrayOfBigInts","smallest","min","max","random","ms","isUnref","resolve","isNode","setTimeout","unref","res","makeCRCTable","c","crcTable","k","undefined","isBuffer","crc","index","byte","Array","constructor","total","USER","CHAT","CHANNEL","freeze","entity","includes","SUBCLASS_OF_ID","name","className"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/Helpers.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._EntityType = exports.TotalList = exports.sleep = exports.isArrayLike = void 0;\nexports.readBigIntFromBuffer = readBigIntFromBuffer;\nexports.generateRandomBigInt = generateRandomBigInt;\nexports.escapeRegex = escapeRegex;\nexports.groupBy = groupBy;\nexports.betterConsoleLog = betterConsoleLog;\nexports.toSignedLittleBuffer = toSignedLittleBuffer;\nexports.readBufferFromBigInt = readBufferFromBigInt;\nexports.generateRandomLong = generateRandomLong;\nexports.mod = mod;\nexports.bigIntMod = bigIntMod;\nexports.generateRandomBytes = generateRandomBytes;\nexports.stripText = stripText;\nexports.generateKeyDataFromNonce = generateKeyDataFromNonce;\nexports.convertToLittle = convertToLittle;\nexports.sha1 = sha1;\nexports.sha256 = sha256;\nexports.modExp = modExp;\nexports.getByteArray = getByteArray;\nexports.returnBigInt = returnBigInt;\nexports.getMinBigInt = getMinBigInt;\nexports.getRandomInt = getRandomInt;\nexports.bufferXor = bufferXor;\nexports.crc32 = crc32;\nexports._entityType = _entityType;\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst CryptoFile_1 = __importDefault(require(\"./CryptoFile\"));\nconst platform_1 = require(\"./platform\");\n/**\n * converts a buffer to big int\n * @param buffer\n * @param little\n * @param signed\n * @returns {bigInt.BigInteger}\n */\nfunction readBigIntFromBuffer(buffer, little = true, signed = false) {\n    let randBuffer = Buffer.from(buffer);\n    const bytesNumber = randBuffer.length;\n    if (little) {\n        randBuffer = randBuffer.reverse();\n    }\n    let bigIntVar = (0, big_integer_1.default)(randBuffer.toString(\"hex\"), 16);\n    if (signed && Math.floor(bigIntVar.toString(2).length / 8) >= bytesNumber) {\n        bigIntVar = bigIntVar.subtract((0, big_integer_1.default)(2).pow((0, big_integer_1.default)(bytesNumber * 8)));\n    }\n    return bigIntVar;\n}\nfunction generateRandomBigInt() {\n    return readBigIntFromBuffer(generateRandomBytes(8), false);\n}\nfunction escapeRegex(string) {\n    return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nfunction groupBy(list, keyGetter) {\n    const map = new Map();\n    list.forEach((item) => {\n        const key = keyGetter(item);\n        const collection = map.get(key);\n        if (!collection) {\n            map.set(key, [item]);\n        }\n        else {\n            collection.push(item);\n        }\n    });\n    return map;\n}\n/**\n * Outputs the object in a better way by hiding all the private methods/attributes.\n * @param object - the class to use\n */\nfunction betterConsoleLog(object) {\n    const toPrint = {};\n    for (const key in object) {\n        if (object.hasOwnProperty(key)) {\n            if (!key.startsWith(\"_\") && key != \"originalArgs\") {\n                toPrint[key] = object[key];\n            }\n        }\n    }\n    return toPrint;\n}\n/**\n * Helper to find if a given object is an array (or similar)\n */\nconst isArrayLike = (x) => x &&\n    typeof x.length === \"number\" &&\n    typeof x !== \"function\" &&\n    typeof x !== \"string\";\nexports.isArrayLike = isArrayLike;\n/*\nexport function addSurrogate(text: string) {\n    let temp = \"\";\n    for (const letter of text) {\n        const t = letter.charCodeAt(0);\n        if (0x1000 < t && t < 0x10FFFF) {\n            const b = Buffer.from(letter, \"utf16le\");\n            const r = String.fromCharCode(b.readUInt16LE(0)) + String.fromCharCode(b.readUInt16LE(2));\n            temp += r;\n        } else {\n            text += letter;\n        }\n    }\n    return temp;\n}\n\n */\n/**\n * Special case signed little ints\n * @param big\n * @param number\n * @returns {Buffer}\n */\nfunction toSignedLittleBuffer(big, number = 8) {\n    const bigNumber = returnBigInt(big);\n    const byteArray = [];\n    for (let i = 0; i < number; i++) {\n        byteArray[i] = bigNumber.shiftRight(8 * i).and(255);\n    }\n    // smh hacks\n    return Buffer.from(byteArray);\n}\n/**\n * converts a big int to a buffer\n * @param bigIntVar {BigInteger}\n * @param bytesNumber\n * @param little\n * @param signed\n * @returns {Buffer}\n */\nfunction readBufferFromBigInt(bigIntVar, bytesNumber, little = true, signed = false) {\n    bigIntVar = (0, big_integer_1.default)(bigIntVar);\n    const bitLength = bigIntVar.bitLength().toJSNumber();\n    const bytes = Math.ceil(bitLength / 8);\n    if (bytesNumber < bytes) {\n        throw new Error(\"OverflowError: int too big to convert\");\n    }\n    if (!signed && bigIntVar.lesser((0, big_integer_1.default)(0))) {\n        throw new Error(\"Cannot convert to unsigned\");\n    }\n    if (signed && bigIntVar.lesser((0, big_integer_1.default)(0))) {\n        bigIntVar = (0, big_integer_1.default)(2)\n            .pow((0, big_integer_1.default)(bytesNumber).multiply(8))\n            .add(bigIntVar);\n    }\n    const hex = bigIntVar.toString(16).padStart(bytesNumber * 2, \"0\");\n    let buffer = Buffer.from(hex, \"hex\");\n    if (little) {\n        buffer = buffer.reverse();\n    }\n    return buffer;\n}\n/**\n * Generates a random long integer (8 bytes), which is optionally signed\n * @returns {BigInteger}\n */\nfunction generateRandomLong(signed = true) {\n    return readBigIntFromBuffer(generateRandomBytes(8), true, signed);\n}\n/**\n * .... really javascript\n * @param n {number}\n * @param m {number}\n * @returns {number}\n */\nfunction mod(n, m) {\n    return ((n % m) + m) % m;\n}\n/**\n * returns a positive bigInt\n * @param n {bigInt.BigInteger}\n * @param m {bigInt.BigInteger}\n * @returns {bigInt.BigInteger}\n */\nfunction bigIntMod(n, m) {\n    return n.remainder(m).add(m).remainder(m);\n}\n/**\n * Generates a random bytes array\n * @param count\n * @returns {Buffer}\n */\nfunction generateRandomBytes(count) {\n    return Buffer.from(CryptoFile_1.default.randomBytes(count));\n}\n/**\n * Calculate the key based on Telegram guidelines, specifying whether it's the client or not\n * @param sharedKey\n * @param msgKey\n * @param client\n * @returns {{iv: Buffer, key: Buffer}}\n */\n/*CONTEST\nthis is mtproto 1 (mostly used for secret chats)\nasync function calcKey(sharedKey, msgKey, client) {\n    const x = client === true ? 0 : 8\n    const [sha1a, sha1b, sha1c, sha1d] = await Promise.all([\n        sha1(Buffer.concat([msgKey, sharedKey.slice(x, x + 32)])),\n        sha1(Buffer.concat([sharedKey.slice(x + 32, x + 48), msgKey, sharedKey.slice(x + 48, x + 64)])),\n        sha1(Buffer.concat([sharedKey.slice(x + 64, x + 96), msgKey])),\n        sha1(Buffer.concat([msgKey, sharedKey.slice(x + 96, x + 128)]))\n    ])\n    const key = Buffer.concat([sha1a.slice(0, 8), sha1b.slice(8, 20), sha1c.slice(4, 16)])\n    const iv = Buffer.concat([sha1a.slice(8, 20), sha1b.slice(0, 8), sha1c.slice(16, 20), sha1d.slice(0, 8)])\n    return {\n        key,\n        iv\n    }\n}\n\n */\nfunction stripText(text, entities) {\n    if (!entities || !entities.length) {\n        return text.trim();\n    }\n    while (text && text[text.length - 1].trim() === \"\") {\n        const e = entities[entities.length - 1];\n        if (e.offset + e.length == text.length) {\n            if (e.length == 1) {\n                entities.pop();\n                if (!entities.length) {\n                    return text.trim();\n                }\n            }\n            else {\n                e.length -= 1;\n            }\n        }\n        text = text.slice(0, -1);\n    }\n    while (text && text[0].trim() === \"\") {\n        for (let i = 0; i < entities.length; i++) {\n            const e = entities[i];\n            if (e.offset != 0) {\n                e.offset--;\n                continue;\n            }\n            if (e.length == 1) {\n                entities.shift();\n                if (!entities.length) {\n                    return text.trimLeft();\n                }\n            }\n            else {\n                e.length -= 1;\n            }\n        }\n        text = text.slice(1);\n    }\n    return text;\n}\n/**\n * Generates the key data corresponding to the given nonces\n * @param serverNonceBigInt\n * @param newNonceBigInt\n * @returns {{key: Buffer, iv: Buffer}}\n */\nasync function generateKeyDataFromNonce(serverNonceBigInt, newNonceBigInt) {\n    const serverNonce = toSignedLittleBuffer(serverNonceBigInt, 16);\n    const newNonce = toSignedLittleBuffer(newNonceBigInt, 32);\n    const [hash1, hash2, hash3] = await Promise.all([\n        sha1(Buffer.concat([newNonce, serverNonce])),\n        sha1(Buffer.concat([serverNonce, newNonce])),\n        sha1(Buffer.concat([newNonce, newNonce])),\n    ]);\n    const keyBuffer = Buffer.concat([hash1, hash2.slice(0, 12)]);\n    const ivBuffer = Buffer.concat([\n        hash2.slice(12, 20),\n        hash3,\n        newNonce.slice(0, 4),\n    ]);\n    return {\n        key: keyBuffer,\n        iv: ivBuffer,\n    };\n}\nfunction convertToLittle(buf) {\n    const correct = Buffer.alloc(buf.length * 4);\n    for (let i = 0; i < buf.length; i++) {\n        correct.writeUInt32BE(buf[i], i * 4);\n    }\n    return correct;\n}\n/**\n * Calculates the SHA1 digest for the given data\n * @param data\n * @returns {Promise}\n */\nfunction sha1(data) {\n    const shaSum = CryptoFile_1.default.createHash(\"sha1\");\n    shaSum.update(data);\n    // @ts-ignore\n    return shaSum.digest();\n}\n/**\n * Calculates the SHA256 digest for the given data\n * @param data\n * @returns {Promise}\n */\nfunction sha256(data) {\n    const shaSum = CryptoFile_1.default.createHash(\"sha256\");\n    shaSum.update(data);\n    // @ts-ignore\n    return shaSum.digest();\n}\n/**\n * Fast mod pow for RSA calculation. a^b % n\n * @param a\n * @param b\n * @param n\n * @returns {bigInt.BigInteger}\n */\nfunction modExp(a, b, n) {\n    a = a.remainder(n);\n    let result = big_integer_1.default.one;\n    let x = a;\n    while (b.greater(big_integer_1.default.zero)) {\n        const leastSignificantBit = b.remainder((0, big_integer_1.default)(2));\n        b = b.divide((0, big_integer_1.default)(2));\n        if (leastSignificantBit.eq(big_integer_1.default.one)) {\n            result = result.multiply(x);\n            result = result.remainder(n);\n        }\n        x = x.multiply(x);\n        x = x.remainder(n);\n    }\n    return result;\n}\n/**\n * Gets the arbitrary-length byte array corresponding to the given integer\n * @param integer {number,BigInteger}\n * @param signed {boolean}\n * @returns {Buffer}\n */\nfunction getByteArray(integer, signed = false) {\n    const bits = integer.toString(2).length;\n    const byteLength = Math.floor((bits + 8 - 1) / 8);\n    return readBufferFromBigInt(typeof integer == \"number\" ? (0, big_integer_1.default)(integer) : integer, byteLength, false, signed);\n}\nfunction returnBigInt(num) {\n    if (big_integer_1.default.isInstance(num)) {\n        return num;\n    }\n    if (typeof num == \"number\") {\n        return (0, big_integer_1.default)(num);\n    }\n    if (typeof num == \"bigint\") {\n        return (0, big_integer_1.default)(num);\n    }\n    return (0, big_integer_1.default)(num);\n}\n/**\n * Helper function to return the smaller big int in an array\n * @param arrayOfBigInts\n */\nfunction getMinBigInt(arrayOfBigInts) {\n    if (arrayOfBigInts.length == 0) {\n        return big_integer_1.default.zero;\n    }\n    if (arrayOfBigInts.length == 1) {\n        return returnBigInt(arrayOfBigInts[0]);\n    }\n    let smallest = returnBigInt(arrayOfBigInts[0]);\n    for (let i = 1; i < arrayOfBigInts.length; i++) {\n        if (returnBigInt(arrayOfBigInts[i]).lesser(smallest)) {\n            smallest = returnBigInt(arrayOfBigInts[i]);\n        }\n    }\n    return smallest;\n}\n/**\n * returns a random int from min (inclusive) and max (inclusive)\n * @param min\n * @param max\n * @returns {number}\n */\nfunction getRandomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n/**\n * Sleeps a specified amount of time\n * @param ms time in milliseconds\n * @param isUnref make a timer unref'ed\n * @returns {Promise}\n */\nconst sleep = (ms, isUnref = false) => new Promise((resolve) => isUnref && platform_1.isNode\n    ? setTimeout(resolve, ms).unref()\n    : setTimeout(resolve, ms));\nexports.sleep = sleep;\n/**\n * Helper to export two buffers of same length\n * @returns {Buffer}\n */\nfunction bufferXor(a, b) {\n    const res = [];\n    for (let i = 0; i < a.length; i++) {\n        res.push(a[i] ^ b[i]);\n    }\n    return Buffer.from(res);\n}\n// Taken from https://stackoverflow.com/questions/18638900/javascript-crc32/18639999#18639999\nfunction makeCRCTable() {\n    let c;\n    const crcTable = [];\n    for (let n = 0; n < 256; n++) {\n        c = n;\n        for (let k = 0; k < 8; k++) {\n            c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;\n        }\n        crcTable[n] = c;\n    }\n    return crcTable;\n}\nlet crcTable = undefined;\nfunction crc32(buf) {\n    if (!crcTable) {\n        crcTable = makeCRCTable();\n    }\n    if (!Buffer.isBuffer(buf)) {\n        buf = Buffer.from(buf);\n    }\n    let crc = -1;\n    for (let index = 0; index < buf.length; index++) {\n        const byte = buf[index];\n        crc = crcTable[(crc ^ byte) & 0xff] ^ (crc >>> 8);\n    }\n    return (crc ^ -1) >>> 0;\n}\nclass TotalList extends Array {\n    constructor() {\n        super();\n        this.total = 0;\n    }\n}\nexports.TotalList = TotalList;\nexports._EntityType = {\n    USER: 0,\n    CHAT: 1,\n    CHANNEL: 2,\n};\nObject.freeze(exports._EntityType);\nfunction _entityType(entity) {\n    if (typeof entity !== \"object\" || !(\"SUBCLASS_OF_ID\" in entity)) {\n        throw new Error(`${entity} is not a TLObject, cannot determine entity type`);\n    }\n    if (![\n        0x2d45687, // crc32('Peer')\n        0xc91c90b6, // crc32('InputPeer')\n        0xe669bf46, // crc32('InputUser')\n        0x40f202fd, // crc32('InputChannel')\n        0x2da17977, // crc32('User')\n        0xc5af5d94, // crc32('Chat')\n        0x1f4661b9, // crc32('UserFull')\n        0xd49a2697, // crc32('ChatFull')\n    ].includes(entity.SUBCLASS_OF_ID)) {\n        throw new Error(`${entity} does not have any entity type`);\n    }\n    const name = entity.className;\n    if (name.includes(\"User\")) {\n        return exports._EntityType.USER;\n    }\n    else if (name.includes(\"Chat\")) {\n        return exports._EntityType.CHAT;\n    }\n    else if (name.includes(\"Channel\")) {\n        return exports._EntityType.CHANNEL;\n    }\n    else if (name.includes(\"Self\")) {\n        return exports._EntityType.USER;\n    }\n    // 'Empty' in name or not found, we don't care, not a valid entity.\n    throw new Error(`${entity} does not have any entity type`);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}