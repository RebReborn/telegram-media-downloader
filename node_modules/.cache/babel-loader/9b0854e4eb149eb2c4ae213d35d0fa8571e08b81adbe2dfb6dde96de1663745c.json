{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TelegramBaseClient = void 0;\nconst __1 = require(\"../\");\nconst Helpers_1 = require(\"../Helpers\");\nconst connection_1 = require(\"../network/connection\");\nconst sessions_1 = require(\"../sessions\");\nconst extensions_1 = require(\"../extensions\");\nconst tl_1 = require(\"../tl\");\nconst os_1 = __importDefault(require(\"./os\"));\nconst entityCache_1 = require(\"../entityCache\");\nconst markdown_1 = require(\"../extensions/markdown\");\nconst network_1 = require(\"../network\");\nconst AllTLObjects_1 = require(\"../tl/AllTLObjects\");\nconst TCPMTProxy_1 = require(\"../network/connection/TCPMTProxy\");\nconst async_mutex_1 = require(\"async-mutex\");\nconst Logger_1 = require(\"../extensions/Logger\");\nconst platform_1 = require(\"../platform\");\nconst Deferred_1 = __importDefault(require(\"../extensions/Deferred\"));\nconst EXPORTED_SENDER_RECONNECT_TIMEOUT = 1000; // 1 sec\nconst EXPORTED_SENDER_RELEASE_TIMEOUT = 30000; // 30 sec\nconst DEFAULT_DC_ID = 4;\nconst DEFAULT_IPV4_IP = platform_1.isNode ? \"149.154.167.91\" : \"vesta.web.telegram.org\";\nconst DEFAULT_IPV6_IP = \"2001:067c:04e8:f004:0000:0000:0000:000a\";\nconst clientParamsDefault = {\n  connection: platform_1.isNode ? connection_1.ConnectionTCPFull : connection_1.ConnectionTCPObfuscated,\n  networkSocket: platform_1.isNode ? extensions_1.PromisedNetSockets : extensions_1.PromisedWebSockets,\n  useIPV6: false,\n  timeout: 10,\n  requestRetries: 5,\n  connectionRetries: Infinity,\n  retryDelay: 1000,\n  downloadRetries: 5,\n  autoReconnect: true,\n  sequentialUpdates: false,\n  floodSleepThreshold: 60,\n  deviceModel: \"\",\n  systemVersion: \"\",\n  appVersion: \"\",\n  langCode: \"en\",\n  systemLangCode: \"en\",\n  _securityChecks: true,\n  useWSS: platform_1.isBrowser ? window.location.protocol == \"https:\" : false,\n  testServers: false\n};\nclass TelegramBaseClient {\n  constructor(session, apiId, apiHash, clientParams) {\n    /** The current gramJS version. */\n    this.__version__ = __1.version;\n    /** @hidden */\n    this._ALBUMS = new Map();\n    /** @hidden */\n    this._exportedSenderPromises = new Map();\n    /** @hidden */\n    this._exportedSenderReleaseTimeouts = new Map();\n    clientParams = Object.assign(Object.assign({}, clientParamsDefault), clientParams);\n    if (!apiId || !apiHash) {\n      throw new Error(\"Your API ID or Hash cannot be empty or undefined\");\n    }\n    if (clientParams.baseLogger) {\n      this._log = clientParams.baseLogger;\n    } else {\n      this._log = new extensions_1.Logger();\n    }\n    this._log.info(\"Running gramJS version \" + __1.version);\n    if (session && typeof session == \"string\") {\n      session = new sessions_1.StoreSession(session);\n    }\n    if (!(session instanceof sessions_1.Session)) {\n      throw new Error(\"Only StringSession and StoreSessions are supported currently :( \");\n    }\n    this._floodSleepThreshold = clientParams.floodSleepThreshold;\n    this.session = session;\n    this.apiId = apiId;\n    this.apiHash = apiHash;\n    this._useIPV6 = clientParams.useIPV6;\n    this._requestRetries = clientParams.requestRetries;\n    this._downloadRetries = clientParams.downloadRetries;\n    this._connectionRetries = clientParams.connectionRetries;\n    this._reconnectRetries = clientParams.reconnectRetries;\n    this._retryDelay = clientParams.retryDelay || 0;\n    this._timeout = clientParams.timeout;\n    this._autoReconnect = clientParams.autoReconnect;\n    this._proxy = clientParams.proxy;\n    this._semaphore = new async_mutex_1.Semaphore(clientParams.maxConcurrentDownloads || 1);\n    this.testServers = clientParams.testServers || false;\n    this.networkSocket = clientParams.networkSocket || extensions_1.PromisedNetSockets;\n    if (!(clientParams.connection instanceof Function)) {\n      throw new Error(\"Connection should be a class not an instance\");\n    }\n    this._connection = clientParams.connection;\n    let initProxy;\n    if (this._proxy && \"MTProxy\" in this._proxy) {\n      this._connection = TCPMTProxy_1.ConnectionTCPMTProxyAbridged;\n      initProxy = new tl_1.Api.InputClientProxy({\n        address: this._proxy.ip,\n        port: this._proxy.port\n      });\n    }\n    this._initRequest = new tl_1.Api.InitConnection({\n      apiId: this.apiId,\n      deviceModel: clientParams.deviceModel || os_1.default.type().toString() || \"Unknown\",\n      systemVersion: clientParams.systemVersion || os_1.default.release().toString() || \"1.0\",\n      appVersion: clientParams.appVersion || \"1.0\",\n      langCode: clientParams.langCode,\n      langPack: \"\",\n      // this should be left empty.\n      systemLangCode: clientParams.systemLangCode,\n      proxy: initProxy\n    });\n    this._eventBuilders = [];\n    this._floodWaitedRequests = {};\n    this._borrowedSenderPromises = {};\n    this._bot = undefined;\n    this._selfInputPeer = undefined;\n    this.useWSS = clientParams.useWSS;\n    this._securityChecks = !!clientParams.securityChecks;\n    if (this.useWSS && this._proxy) {\n      throw new Error(\"Cannot use SSL with proxies. You need to disable the useWSS client param in TelegramClient\");\n    }\n    this._entityCache = new entityCache_1.EntityCache();\n    // These will be set later\n    this._config = undefined;\n    this._loopStarted = false;\n    this._reconnecting = false;\n    this._destroyed = false;\n    this._isSwitchingDc = false;\n    this._connectedDeferred = new Deferred_1.default();\n    // parse mode\n    this._parseMode = markdown_1.MarkdownParser;\n  }\n  get floodSleepThreshold() {\n    return this._floodSleepThreshold;\n  }\n  set floodSleepThreshold(value) {\n    this._floodSleepThreshold = Math.min(value || 0, 24 * 60 * 60);\n  }\n  set maxConcurrentDownloads(value) {\n    // @ts-ignore\n    this._semaphore._value = value;\n  }\n  // region connecting\n  async _initSession() {\n    await this.session.load();\n    if (!this.session.serverAddress) {\n      this.session.setDC(DEFAULT_DC_ID, this._useIPV6 ? DEFAULT_IPV6_IP : DEFAULT_IPV4_IP, this.useWSS ? 443 : 80);\n    } else {\n      this._useIPV6 = this.session.serverAddress.includes(\":\");\n    }\n  }\n  get connected() {\n    return this._sender && this._sender.isConnected();\n  }\n  async disconnect() {\n    await this._disconnect();\n    await Promise.all(Object.values(this._exportedSenderPromises).map(promises => {\n      return Object.values(promises).map(promise => {\n        return promise && promise.then(sender => {\n          if (sender) {\n            return sender.disconnect();\n          }\n          return undefined;\n        });\n      });\n    }).flat());\n    Object.values(this._exportedSenderReleaseTimeouts).forEach(timeouts => {\n      Object.values(timeouts).forEach(releaseTimeout => {\n        clearTimeout(releaseTimeout);\n      });\n    });\n    this._exportedSenderPromises.clear();\n  }\n  get disconnected() {\n    return !this._sender || this._sender._disconnected;\n  }\n  async _disconnect() {\n    var _a;\n    await ((_a = this._sender) === null || _a === void 0 ? void 0 : _a.disconnect());\n  }\n  /**\n   * Disconnects all senders and removes all handlers\n   * Disconnect is safer as it will not remove your event handlers\n   */\n  async destroy() {\n    this._destroyed = true;\n    await Promise.all([this.disconnect(), ...Object.values(this._borrowedSenderPromises).map(promise => {\n      return promise.then(sender => sender.disconnect());\n    })]);\n    this._eventBuilders = [];\n  }\n  /** @hidden */\n  async _authKeyCallback(authKey, dcId) {\n    this.session.setAuthKey(authKey, dcId);\n    await this.session.save();\n  }\n  /** @hidden */\n  async _cleanupExportedSender(dcId) {\n    if (this.session.dcId !== dcId) {\n      this.session.setAuthKey(undefined, dcId);\n    }\n    let sender = await this._exportedSenderPromises.get(dcId);\n    this._exportedSenderPromises.delete(dcId);\n    await (sender === null || sender === void 0 ? void 0 : sender.disconnect());\n  }\n  /** @hidden */\n  async _connectSender(sender, dcId) {\n    // if we don't already have an auth key we want to use normal DCs not -1\n    const dc = await this.getDC(dcId, !!sender.authKey.getKey());\n    while (true) {\n      try {\n        await sender.connect(new this._connection({\n          ip: dc.ipAddress,\n          port: dc.port,\n          dcId: dcId,\n          loggers: this._log,\n          proxy: this._proxy,\n          testServers: this.testServers,\n          socket: this.networkSocket\n        }), false);\n        if (this.session.dcId !== dcId && !sender._authenticated) {\n          this._log.info(`Exporting authorization for data center ${dc.ipAddress} with layer ${AllTLObjects_1.LAYER}`);\n          const auth = await this.invoke(new tl_1.Api.auth.ExportAuthorization({\n            dcId: dcId\n          }));\n          this._initRequest.query = new tl_1.Api.auth.ImportAuthorization({\n            id: auth.id,\n            bytes: auth.bytes\n          });\n          const req = new tl_1.Api.InvokeWithLayer({\n            layer: AllTLObjects_1.LAYER,\n            query: this._initRequest\n          });\n          await sender.send(req);\n          sender._authenticated = true;\n        }\n        sender.dcId = dcId;\n        sender.userDisconnected = false;\n        return sender;\n      } catch (err) {\n        if (err.errorMessage === \"DC_ID_INVALID\") {\n          sender._authenticated = true;\n          sender.userDisconnected = false;\n          return sender;\n        }\n        if (this._errorHandler) {\n          await this._errorHandler(err);\n        } else if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\n          console.error(err);\n        }\n        await (0, Helpers_1.sleep)(1000);\n        await sender.disconnect();\n      }\n    }\n  }\n  /** @hidden */\n  async _borrowExportedSender(dcId, shouldReconnect, existingSender) {\n    if (!this._exportedSenderPromises.get(dcId) || shouldReconnect) {\n      this._exportedSenderPromises.set(dcId, this._connectSender(existingSender || this._createExportedSender(dcId), dcId));\n    }\n    let sender;\n    try {\n      sender = await this._exportedSenderPromises.get(dcId);\n      if (!sender.isConnected()) {\n        if (sender.isConnecting) {\n          await (0, Helpers_1.sleep)(EXPORTED_SENDER_RECONNECT_TIMEOUT);\n          return this._borrowExportedSender(dcId, false, sender);\n        } else {\n          return this._borrowExportedSender(dcId, true, sender);\n        }\n      }\n    } catch (err) {\n      if (this._errorHandler) {\n        await this._errorHandler(err);\n      }\n      if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\n        console.error(err);\n      }\n      return this._borrowExportedSender(dcId, true);\n    }\n    if (this._exportedSenderReleaseTimeouts.get(dcId)) {\n      clearTimeout(this._exportedSenderReleaseTimeouts.get(dcId));\n      this._exportedSenderReleaseTimeouts.delete(dcId);\n    }\n    this._exportedSenderReleaseTimeouts.set(dcId, setTimeout(() => {\n      this._exportedSenderReleaseTimeouts.delete(dcId);\n      if (sender._pendingState.values().length) {\n        console.log(\"sender already has some hanging states. reconnecting\");\n        sender._reconnect();\n        this._borrowExportedSender(dcId, false, sender);\n      } else {\n        sender.disconnect();\n      }\n    }, EXPORTED_SENDER_RELEASE_TIMEOUT));\n    return sender;\n  }\n  /** @hidden */\n  _createExportedSender(dcId) {\n    return new network_1.MTProtoSender(this.session.getAuthKey(dcId), {\n      logger: this._log,\n      dcId,\n      retries: this._connectionRetries,\n      delay: this._retryDelay,\n      autoReconnect: this._autoReconnect,\n      connectTimeout: this._timeout,\n      authKeyCallback: this._authKeyCallback.bind(this),\n      isMainSender: dcId === this.session.dcId,\n      onConnectionBreak: this._cleanupExportedSender.bind(this),\n      client: this,\n      securityChecks: this._securityChecks,\n      _exportedSenderPromises: this._exportedSenderPromises,\n      reconnectRetries: this._reconnectRetries\n    });\n  }\n  /** @hidden */\n  getSender(dcId) {\n    return dcId ? this._borrowExportedSender(dcId) : Promise.resolve(this._sender);\n  }\n  // endregion\n  async getDC(dcId, download) {\n    throw new Error(\"Cannot be called from here!\");\n  }\n  invoke(request) {\n    throw new Error(\"Cannot be called from here!\");\n  }\n  setLogLevel(level) {\n    this._log.setLevel(level);\n  }\n  get logger() {\n    return this._log;\n  }\n  /**\n   * Custom error handler for the client\n   * @example\n   * ```ts\n   * client.onError = async (error)=>{\n   *         console.log(\"error is\",error)\n   *     }\n   * ```\n   */\n  set onError(handler) {\n    this._errorHandler = async error => {\n      try {\n        await handler(error);\n      } catch (e) {\n        if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\n          e.message = `Error ${e.message} thrown while handling top-level error: ${error.message}`;\n          console.error(e);\n        }\n      }\n    };\n  }\n}\nexports.TelegramBaseClient = TelegramBaseClient;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}