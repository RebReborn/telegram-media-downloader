{"ast":null,"code":"\"use strict\";\n\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RequestIter = void 0;\nconst Helpers_1 = require(\"./Helpers\");\nconst _1 = require(\"./\");\nclass RequestIter {\n  constructor(client, limit, params = {}, args = {}) {\n    this.client = client;\n    this.reverse = params.reverse;\n    this.waitTime = params.waitTime;\n    this.limit = Math.max(!limit ? Number.MAX_SAFE_INTEGER : limit, 0);\n    this.left = this.limit;\n    this.buffer = undefined;\n    this.kwargs = args;\n    this.index = 0;\n    this.total = undefined;\n    this.lastLoad = 0;\n  }\n  async _init(kwargs) {\n    // for overload\n  }\n  [Symbol.asyncIterator]() {\n    this.buffer = undefined;\n    this.index = 0;\n    this.lastLoad = 0;\n    this.left = this.limit;\n    return {\n      next: async () => {\n        if (this.buffer == undefined) {\n          this.buffer = [];\n          if (await this._init(this.kwargs)) {\n            this.left = this.buffer.length;\n          }\n        }\n        if (this.left <= 0) {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n        if (this.index == this.buffer.length) {\n          if (this.waitTime) {\n            await (0, Helpers_1.sleep)(this.waitTime - (new Date().getTime() / 1000 - this.lastLoad));\n          }\n          this.lastLoad = new Date().getTime() / 1000;\n          this.index = 0;\n          this.buffer = [];\n          const nextChunk = await this._loadNextChunk();\n          if (nextChunk === false) {\n            // we exit;\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          if (nextChunk) {\n            this.left = this.buffer.length;\n          }\n        }\n        if (!this.buffer || !this.buffer.length) {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n        const result = this.buffer[this.index];\n        this.left -= 1;\n        this.index += 1;\n        return {\n          value: result,\n          done: false\n        };\n      }\n    };\n  }\n  async collect() {\n    var _a, e_1, _b, _c;\n    const result = new _1.helpers.TotalList();\n    try {\n      for (var _d = true, _e = __asyncValues(this), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {\n        _c = _f.value;\n        _d = false;\n        const message = _c;\n        result.push(message);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    result.total = this.total;\n    return result;\n  }\n  async _loadNextChunk() {\n    throw new Error(\"Not Implemented\");\n  }\n}\nexports.RequestIter = RequestIter;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}