{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MemorySession = void 0;\nconst Abstract_1 = require(\"./Abstract\");\nconst tl_1 = require(\"../tl\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst Utils_1 = require(\"../Utils\");\nconst Helpers_1 = require(\"../Helpers\");\nconst __1 = require(\"../\");\nclass MemorySession extends Abstract_1.Session {\n  constructor() {\n    super();\n    this._serverAddress = undefined;\n    this._dcId = 0;\n    this._port = undefined;\n    this._takeoutId = undefined;\n    this._entities = new Set();\n    this._updateStates = {};\n  }\n  setDC(dcId, serverAddress, port) {\n    this._dcId = dcId | 0;\n    this._serverAddress = serverAddress;\n    this._port = port;\n  }\n  get dcId() {\n    return this._dcId;\n  }\n  get serverAddress() {\n    return this._serverAddress;\n  }\n  get port() {\n    return this._port;\n  }\n  get authKey() {\n    return this._authKey;\n  }\n  set authKey(value) {\n    this._authKey = value;\n  }\n  get takeoutId() {\n    return this._takeoutId;\n  }\n  set takeoutId(value) {\n    this._takeoutId = value;\n  }\n  getAuthKey(dcId) {\n    if (dcId && dcId !== this.dcId) {\n      // Not supported.\n      return undefined;\n    }\n    return this.authKey;\n  }\n  setAuthKey(authKey, dcId) {\n    if (dcId && dcId !== this.dcId) {\n      // Not supported.\n      return undefined;\n    }\n    this.authKey = authKey;\n  }\n  close() {}\n  save() {}\n  async load() {}\n  delete() {}\n  _entityValuesToRow(id, hash, username, phone, name) {\n    // While this is a simple implementation it might be overrode by,\n    // other classes so they don't need to implement the plural form\n    // of the method. Don't remove.\n    return [id, hash, username, phone, name];\n  }\n  _entityToRow(e) {\n    if (!(e.classType === \"constructor\")) {\n      return;\n    }\n    let p;\n    let markedId;\n    try {\n      p = (0, Utils_1.getInputPeer)(e, false);\n      markedId = (0, Utils_1.getPeerId)(p);\n    } catch (e) {\n      return;\n    }\n    let pHash;\n    if (p instanceof tl_1.Api.InputPeerUser || p instanceof tl_1.Api.InputPeerChannel) {\n      pHash = p.accessHash;\n    } else if (p instanceof tl_1.Api.InputPeerChat) {\n      pHash = big_integer_1.default.zero;\n    } else {\n      return;\n    }\n    let username = e.username;\n    if (username) {\n      username = username.toLowerCase();\n    }\n    const phone = e.phone;\n    const name = (0, Utils_1.getDisplayName)(e);\n    return this._entityValuesToRow(markedId, pHash, username, phone, name);\n  }\n  _entitiesToRows(tlo) {\n    let entities = [];\n    if (!(tlo.classType === \"constructor\") && (0, Helpers_1.isArrayLike)(tlo)) {\n      // This may be a list of users already for instance\n      entities = tlo;\n    } else {\n      if (typeof tlo === \"object\") {\n        if (\"user\" in tlo) {\n          entities.push(tlo.user);\n        }\n        if (\"chat\" in tlo) {\n          entities.push(tlo.chat);\n        }\n        if (\"channel\" in tlo) {\n          entities.push(tlo.channel);\n        }\n        if (\"chats\" in tlo && (0, Helpers_1.isArrayLike)(tlo.chats)) {\n          entities = entities.concat(tlo.chats);\n        }\n        if (\"users\" in tlo && (0, Helpers_1.isArrayLike)(tlo.users)) {\n          entities = entities.concat(tlo.users);\n        }\n      }\n    }\n    const rows = []; // Rows to add (id, hash, username, phone, name)\n    for (const e of entities) {\n      const row = this._entityToRow(e);\n      if (row) {\n        rows.push(row);\n      }\n    }\n    return rows;\n  }\n  processEntities(tlo) {\n    const entitiesSet = this._entitiesToRows(tlo);\n    for (const e of entitiesSet) {\n      this._entities.add(e);\n    }\n  }\n  getEntityRowsByPhone(phone) {\n    for (const e of this._entities) {\n      // id, hash, username, phone, name\n      if (e[3] === phone) {\n        return [e[0], e[1]];\n      }\n    }\n  }\n  getEntityRowsByUsername(username) {\n    for (const e of this._entities) {\n      // id, hash, username, phone, name\n      if (e[2] === username) {\n        return [e[0], e[1]];\n      }\n    }\n  }\n  getEntityRowsByName(name) {\n    for (const e of this._entities) {\n      // id, hash, username, phone, name\n      if (e[4] === name) {\n        return [e[0], e[1]];\n      }\n    }\n  }\n  getEntityRowsById(id, exact = true) {\n    if (exact) {\n      for (const e of this._entities) {\n        // id, hash, username, phone, name\n        if (e[0] === id) {\n          return [e[0], e[1]];\n        }\n      }\n    } else {\n      const ids = [__1.utils.getPeerId(new tl_1.Api.PeerUser({\n        userId: (0, Helpers_1.returnBigInt)(id)\n      })), __1.utils.getPeerId(new tl_1.Api.PeerChat({\n        chatId: (0, Helpers_1.returnBigInt)(id)\n      })), __1.utils.getPeerId(new tl_1.Api.PeerChannel({\n        channelId: (0, Helpers_1.returnBigInt)(id)\n      }))];\n      for (const e of this._entities) {\n        // id, hash, username, phone, name\n        if (ids.includes(e[0])) {\n          return [e[0], e[1]];\n        }\n      }\n    }\n  }\n  getInputEntity(key) {\n    let exact;\n    if (typeof key === \"object\" && !big_integer_1.default.isInstance(key) && key.SUBCLASS_OF_ID) {\n      if (key.SUBCLASS_OF_ID == 0xc91c90b6 || key.SUBCLASS_OF_ID == 0xe669bf46 || key.SUBCLASS_OF_ID == 0x40f202fd) {\n        // @ts-ignore\n        return key;\n      }\n      // Try to early return if this key can be casted as input peer\n      return __1.utils.getInputPeer(key);\n    } else {\n      // Not a TLObject or can't be cast into InputPeer\n      if (typeof key === \"object\") {\n        key = __1.utils.getPeerId(key);\n        exact = true;\n      } else {\n        exact = false;\n      }\n    }\n    if (big_integer_1.default.isInstance(key) || typeof key == \"bigint\" || typeof key == \"number\") {\n      key = key.toString();\n    }\n    let result = undefined;\n    if (typeof key === \"string\") {\n      const phone = __1.utils.parsePhone(key);\n      if (phone) {\n        result = this.getEntityRowsByPhone(phone);\n      } else {\n        const {\n          username,\n          isInvite\n        } = __1.utils.parseUsername(key);\n        if (username && !isInvite) {\n          result = this.getEntityRowsByUsername(username);\n        }\n      }\n      if (!result) {\n        const id = __1.utils.parseID(key);\n        if (id) {\n          result = this.getEntityRowsById(id, exact);\n        }\n      }\n      if (!result) {\n        result = this.getEntityRowsByName(key);\n      }\n    }\n    if (result) {\n      let entityId = result[0]; // unpack resulting tuple\n      const entityHash = (0, big_integer_1.default)(result[1]);\n      const resolved = __1.utils.resolveId((0, Helpers_1.returnBigInt)(entityId));\n      entityId = resolved[0];\n      const kind = resolved[1];\n      // removes the mark and returns type of entity\n      if (kind === tl_1.Api.PeerUser) {\n        return new tl_1.Api.InputPeerUser({\n          userId: entityId,\n          accessHash: entityHash\n        });\n      } else if (kind === tl_1.Api.PeerChat) {\n        return new tl_1.Api.InputPeerChat({\n          chatId: entityId\n        });\n      } else if (kind === tl_1.Api.PeerChannel) {\n        return new tl_1.Api.InputPeerChannel({\n          channelId: entityId,\n          accessHash: entityHash\n        });\n      }\n    } else {\n      throw new Error(\"Could not find input entity with key \" + key);\n    }\n    throw new Error(\"Could not find input entity with key \" + key);\n  }\n}\nexports.MemorySession = MemorySession;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}