{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StringSession = void 0;\nconst Memory_1 = require(\"./Memory\");\nconst extensions_1 = require(\"../extensions\");\nconst AuthKey_1 = require(\"../crypto/AuthKey\");\nconst CURRENT_VERSION = \"1\";\nclass StringSession extends Memory_1.MemorySession {\n  /**\n   * This session file can be easily saved and loaded as a string. According\n   * to the initial design, it contains only the data that is necessary for\n   * successful connection and authentication, so takeout ID is not stored.\n    * It is thought to be used where you don't want to create any on-disk\n   * files but would still like to be able to save and load existing sessions\n   * by other means.\n    * You can use custom `encode` and `decode` functions, if present:\n    * `encode` definition must be ``function encode(value: Buffer) -> string:``.\n   * `decode` definition must be ``function decode(value: string) -> Buffer:``.\n   * @param session {string|null}\n   */\n  constructor(session) {\n    super();\n    if (session) {\n      if (session[0] !== CURRENT_VERSION) {\n        throw new Error(\"Not a valid string\");\n      }\n      session = session.slice(1);\n      const r = StringSession.decode(session);\n      const reader = new extensions_1.BinaryReader(r);\n      this._dcId = reader.read(1).readUInt8(0);\n      if (session.length == 352) {\n        // Telethon session\n        const ip_v4 = reader.read(4);\n        // TODO looks ugly smh\n        this._serverAddress = ip_v4[0].toString() + \".\" + ip_v4[1].toString() + \".\" + ip_v4[2].toString() + \".\" + ip_v4[3].toString();\n      } else {\n        // TODO find a better of doing this\n        const serverAddressLen = reader.read(2).readInt16BE(0);\n        if (serverAddressLen > 100) {\n          reader.offset -= 2;\n          this._serverAddress = reader.read(16).toString(\"hex\").match(/.{1,4}/g).map(val => val.replace(/^0+/, \"\")).join(\":\").replace(/0000\\:/g, \":\").replace(/:{2,}/g, \"::\");\n        } else {\n          this._serverAddress = reader.read(serverAddressLen).toString();\n        }\n      }\n      this._port = reader.read(2).readInt16BE(0);\n      this._key = reader.read(-1);\n    }\n  }\n  /**\n   * @param x {Buffer}\n   * @returns {string}\n   */\n  static encode(x) {\n    return x.toString(\"base64\");\n  }\n  /**\n   * @param x {string}\n   * @returns {Buffer}\n   */\n  static decode(x) {\n    return Buffer.from(x, \"base64\");\n  }\n  async load() {\n    if (this._key) {\n      this._authKey = new AuthKey_1.AuthKey();\n      await this._authKey.setKey(this._key);\n    }\n  }\n  save() {\n    if (!this.authKey || !this.serverAddress || !this.port) {\n      return \"\";\n    }\n    // TS is weird\n    const key = this.authKey.getKey();\n    if (!key) {\n      return \"\";\n    }\n    const dcBuffer = Buffer.from([this.dcId]);\n    const addressBuffer = Buffer.from(this.serverAddress);\n    const addressLengthBuffer = Buffer.alloc(2);\n    addressLengthBuffer.writeInt16BE(addressBuffer.length, 0);\n    const portBuffer = Buffer.alloc(2);\n    portBuffer.writeInt16BE(this.port, 0);\n    return CURRENT_VERSION + StringSession.encode(Buffer.concat([dcBuffer, addressLengthBuffer, addressBuffer, portBuffer, key]));\n  }\n}\nexports.StringSession = StringSession;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}