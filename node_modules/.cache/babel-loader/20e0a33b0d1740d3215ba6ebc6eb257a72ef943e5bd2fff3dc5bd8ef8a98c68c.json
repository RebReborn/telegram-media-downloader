{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.invoke = invoke;\nexports.getMe = getMe;\nexports.isBot = isBot;\nexports.isUserAuthorized = isUserAuthorized;\nexports.getEntity = getEntity;\nexports.getInputEntity = getInputEntity;\nexports._getEntityFromString = _getEntityFromString;\nexports.getPeerId = getPeerId;\nexports._getPeer = _getPeer;\nexports._getInputDialog = _getInputDialog;\nexports._getInputNotify = _getInputNotify;\nexports._selfId = _selfId;\nconst tl_1 = require(\"../tl\");\nconst Utils_1 = require(\"../Utils\");\nconst Helpers_1 = require(\"../Helpers\");\nconst __1 = require(\"../\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst Logger_1 = require(\"../extensions/Logger\");\nconst RequestState_1 = require(\"../network/RequestState\");\n// UserMethods {\n// region Invoking Telegram request\n/** @hidden */\nasync function invoke(client, request, dcId, otherSender) {\n  if (request.classType !== \"request\") {\n    throw new Error(\"You can only invoke MTProtoRequests\");\n  }\n  let sender = client._sender;\n  if (dcId) {\n    sender = await client.getSender(dcId);\n  }\n  if (otherSender != undefined) {\n    sender = otherSender;\n  }\n  if (sender == undefined) {\n    throw new Error(\"Cannot send requests while disconnected. You need to call .connect()\");\n  }\n  if (sender.userDisconnected) {\n    throw new Error(\"Cannot send requests while disconnected. Please reconnect.\");\n  }\n  await client._connectedDeferred.promise;\n  await request.resolve(client, __1.utils);\n  client._lastRequest = new Date().getTime();\n  const state = new RequestState_1.RequestState(request);\n  let attempt = 0;\n  for (attempt = 0; attempt < client._requestRetries; attempt++) {\n    sender.addStateToQueue(state);\n    try {\n      const result = await state.promise;\n      state.finished.resolve();\n      client.session.processEntities(result);\n      client._entityCache.add(result);\n      return result;\n    } catch (e) {\n      if (e instanceof __1.errors.ServerError || e.errorMessage === \"RPC_CALL_FAIL\" || e.errorMessage === \"RPC_MCGET_FAIL\") {\n        client._log.warn(`Telegram is having internal issues ${e.constructor.name}`);\n        await (0, Helpers_1.sleep)(2000);\n      } else if (e instanceof __1.errors.FloodWaitError || e instanceof __1.errors.FloodTestPhoneWaitError) {\n        if (e.seconds <= client.floodSleepThreshold) {\n          client._log.info(`Sleeping for ${e.seconds}s on flood wait (Caused by ${request.className})`);\n          await (0, Helpers_1.sleep)(e.seconds * 1000);\n        } else {\n          state.finished.resolve();\n          throw e;\n        }\n      } else if (e instanceof __1.errors.PhoneMigrateError || e instanceof __1.errors.NetworkMigrateError || e instanceof __1.errors.UserMigrateError) {\n        client._log.info(`Phone migrated to ${e.newDc}`);\n        const shouldRaise = e instanceof __1.errors.PhoneMigrateError || e instanceof __1.errors.NetworkMigrateError;\n        if (shouldRaise && (await client.isUserAuthorized())) {\n          state.finished.resolve();\n          throw e;\n        }\n        await client._switchDC(e.newDc);\n        sender = dcId === undefined ? client._sender : await client.getSender(dcId);\n      } else if (e instanceof __1.errors.MsgWaitError) {\n        // We need to resend this after the old one was confirmed.\n        await state.isReady();\n        state.after = undefined;\n      } else if (e.message === \"CONNECTION_NOT_INITED\") {\n        await client.disconnect();\n        await (0, Helpers_1.sleep)(2000);\n        await client.connect();\n      } else {\n        state.finished.resolve();\n        throw e;\n      }\n    }\n    state.resetPromise();\n  }\n  throw new Error(`Request was unsuccessful ${attempt} time(s)`);\n}\n/** @hidden */\nasync function getMe(client, inputPeer) {\n  if (inputPeer && client._selfInputPeer) {\n    return client._selfInputPeer;\n  }\n  const me = (await client.invoke(new tl_1.Api.users.GetUsers({\n    id: [new tl_1.Api.InputUserSelf()]\n  })))[0];\n  client._bot = me.bot;\n  if (!client._selfInputPeer) {\n    client._selfInputPeer = __1.utils.getInputPeer(me, false);\n  }\n  return inputPeer ? client._selfInputPeer : me;\n}\n/** @hidden */\nasync function isBot(client) {\n  if (client._bot === undefined) {\n    const me = await client.getMe();\n    if (me) {\n      return !(me instanceof tl_1.Api.InputPeerUser) ? me.bot : undefined;\n    }\n  }\n  return client._bot;\n}\n/** @hidden */\nasync function isUserAuthorized(client) {\n  try {\n    await client.invoke(new tl_1.Api.updates.GetState());\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/** @hidden */\nasync function getEntity(client, entity) {\n  const single = !(0, Helpers_1.isArrayLike)(entity);\n  let entityArray = [];\n  if ((0, Helpers_1.isArrayLike)(entity)) {\n    entityArray = entity;\n  } else {\n    entityArray.push(entity);\n  }\n  const inputs = [];\n  for (const x of entityArray) {\n    if (typeof x === \"string\") {\n      const valid = (0, Utils_1.parseID)(x);\n      if (valid) {\n        inputs.push(await client.getInputEntity(valid));\n      } else {\n        inputs.push(x);\n      }\n    } else {\n      inputs.push(await client.getInputEntity(x));\n    }\n  }\n  const lists = new Map([[Helpers_1._EntityType.USER, []], [Helpers_1._EntityType.CHAT, []], [Helpers_1._EntityType.CHANNEL, []]]);\n  for (const x of inputs) {\n    try {\n      lists.get((0, Helpers_1._entityType)(x)).push(x);\n    } catch (e) {}\n  }\n  let users = lists.get(Helpers_1._EntityType.USER);\n  let chats = lists.get(Helpers_1._EntityType.CHAT);\n  let channels = lists.get(Helpers_1._EntityType.CHANNEL);\n  if (users.length) {\n    users = await client.invoke(new tl_1.Api.users.GetUsers({\n      id: users\n    }));\n  }\n  if (chats.length) {\n    const chatIds = chats.map(x => x.chatId);\n    chats = (await client.invoke(new tl_1.Api.messages.GetChats({\n      id: chatIds\n    }))).chats;\n  }\n  if (channels.length) {\n    channels = (await client.invoke(new tl_1.Api.channels.GetChannels({\n      id: channels\n    }))).chats;\n  }\n  const idEntity = new Map();\n  for (const user of users) {\n    idEntity.set((0, Utils_1.getPeerId)(user), user);\n  }\n  for (const channel of channels) {\n    idEntity.set((0, Utils_1.getPeerId)(channel), channel);\n  }\n  for (const chat of chats) {\n    idEntity.set((0, Utils_1.getPeerId)(chat), chat);\n  }\n  const result = [];\n  for (const x of inputs) {\n    if (typeof x === \"string\") {\n      result.push(await _getEntityFromString(client, x));\n    } else if (!(x instanceof tl_1.Api.InputPeerSelf)) {\n      result.push(idEntity.get((0, Utils_1.getPeerId)(x)));\n    } else {\n      for (const [key, u] of idEntity.entries()) {\n        if (u instanceof tl_1.Api.User && u.self) {\n          result.push(u);\n          break;\n        }\n      }\n    }\n  }\n  return single ? result[0] : result;\n}\n/** @hidden */\nasync function getInputEntity(client, peer) {\n  // Short-circuit if the input parameter directly maps to an InputPeer\n  try {\n    return __1.utils.getInputPeer(peer);\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  // Next in priority is having a peer (or its ID) cached in-memory\n  try {\n    if (typeof peer == \"string\") {\n      const valid = (0, Utils_1.parseID)(peer);\n      if (valid) {\n        const res = client._entityCache.get(peer);\n        if (res) {\n          return res;\n        }\n      }\n    }\n    if (typeof peer === \"number\" || typeof peer === \"bigint\" || big_integer_1.default.isInstance(peer)) {\n      const res = client._entityCache.get(peer.toString());\n      if (res) {\n        return res;\n      }\n    }\n    // 0x2d45687 == crc32(b'Peer')\n    if (typeof peer == \"object\" && !big_integer_1.default.isInstance(peer) && peer.SUBCLASS_OF_ID === 0x2d45687) {\n      const res = client._entityCache.get(__1.utils.getPeerId(peer));\n      if (res) {\n        return res;\n      }\n    }\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  // Then come known strings that take precedence\n  if (typeof peer == \"string\") {\n    if ([\"me\", \"this\", \"self\"].includes(peer)) {\n      return new tl_1.Api.InputPeerSelf();\n    }\n  }\n  // No InputPeer, cached peer, or known string. Fetch from disk cache\n  try {\n    if (peer != undefined) {\n      return client.session.getInputEntity(peer);\n    }\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  // Only network left to try\n  if (typeof peer === \"string\") {\n    return __1.utils.getInputPeer(await _getEntityFromString(client, peer));\n  }\n  // If we're a bot and the user has messaged us privately users.getUsers\n  // will work with accessHash = 0. Similar for channels.getChannels.\n  // If we're not a bot but the user is in our contacts, it seems to work\n  // regardless. These are the only two special-cased requests.\n  if (typeof peer === \"number\") {\n    peer = (0, Helpers_1.returnBigInt)(peer);\n  }\n  peer = __1.utils.getPeer(peer);\n  if (peer instanceof tl_1.Api.PeerUser) {\n    const users = await client.invoke(new tl_1.Api.users.GetUsers({\n      id: [new tl_1.Api.InputUser({\n        userId: peer.userId,\n        accessHash: big_integer_1.default.zero\n      })]\n    }));\n    if (users.length && !(users[0] instanceof tl_1.Api.UserEmpty)) {\n      // If the user passed a valid ID they expect to work for\n      // channels but would be valid for users, we get UserEmpty.\n      // Avoid returning the invalid empty input peer for that.\n      //\n      // We *could* try to guess if it's a channel first, and if\n      // it's not, work as a chat and try to validate it through\n      // another request, but that becomes too much work.\n      return __1.utils.getInputPeer(users[0]);\n    }\n  } else if (peer instanceof tl_1.Api.PeerChat) {\n    return new tl_1.Api.InputPeerChat({\n      chatId: peer.chatId\n    });\n  } else if (peer instanceof tl_1.Api.PeerChannel) {\n    try {\n      const channels = await client.invoke(new tl_1.Api.channels.GetChannels({\n        id: [new tl_1.Api.InputChannel({\n          channelId: peer.channelId,\n          accessHash: big_integer_1.default.zero\n        })]\n      }));\n      return __1.utils.getInputPeer(channels.chats[0]);\n    } catch (e) {\n      if (client._errorHandler) {\n        await client._errorHandler(e);\n      }\n      if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\n        console.error(e);\n      }\n    }\n  }\n  throw new Error(`Could not find the input entity for ${JSON.stringify(peer)}.\n         Please read https://` + \"docs.telethon.dev/en/stable/concepts/entities.html to\" + \" find out more details.\");\n}\n/** @hidden */\nasync function _getEntityFromString(client, string) {\n  const phone = __1.utils.parsePhone(string);\n  if (phone) {\n    try {\n      const result = await client.invoke(new tl_1.Api.contacts.GetContacts({\n        hash: big_integer_1.default.zero\n      }));\n      if (!(result instanceof tl_1.Api.contacts.ContactsNotModified)) {\n        for (const user of result.users) {\n          if (user instanceof tl_1.Api.User && user.phone === phone) {\n            return user;\n          }\n        }\n      }\n    } catch (e) {\n      if (e.errorMessage === \"BOT_METHOD_INVALID\") {\n        throw new Error(\"Cannot get entity by phone number as a \" + \"bot (try using integer IDs, not strings)\");\n      }\n      throw e;\n    }\n  }\n  const id = __1.utils.parseID(string);\n  if (id != undefined) {\n    return getInputEntity(client, id);\n  } else if ([\"me\", \"this\"].includes(string.toLowerCase())) {\n    return client.getMe();\n  } else {\n    const {\n      username,\n      isInvite\n    } = __1.utils.parseUsername(string);\n    if (isInvite) {\n      const invite = await client.invoke(new tl_1.Api.messages.CheckChatInvite({\n        hash: username\n      }));\n      if (invite instanceof tl_1.Api.ChatInvite) {\n        throw new Error(\"Cannot get entity from a channel (or group) \" + \"that you are not part of. Join the group and retry\");\n      } else if (invite instanceof tl_1.Api.ChatInviteAlready) {\n        return invite.chat;\n      }\n    } else if (username) {\n      try {\n        const result = await client.invoke(new tl_1.Api.contacts.ResolveUsername({\n          username: username\n        }));\n        const pid = __1.utils.getPeerId(result.peer, false);\n        if (result.peer instanceof tl_1.Api.PeerUser) {\n          for (const x of result.users) {\n            if ((0, Helpers_1.returnBigInt)(x.id).equals((0, Helpers_1.returnBigInt)(pid))) {\n              return x;\n            }\n          }\n        } else {\n          for (const x of result.chats) {\n            if ((0, Helpers_1.returnBigInt)(x.id).equals((0, Helpers_1.returnBigInt)(pid))) {\n              return x;\n            }\n          }\n        }\n      } catch (e) {\n        if (e.errorMessage === \"USERNAME_NOT_OCCUPIED\") {\n          throw new Error(`No user has \"${username}\" as username`);\n        }\n        throw e;\n      }\n    }\n  }\n  throw new Error(`Cannot find any entity corresponding to \"${string}\"`);\n}\n/** @hidden */\nasync function getPeerId(client, peer, addMark = true) {\n  if (typeof peer == \"string\") {\n    const valid = (0, Utils_1.parseID)(peer);\n    if (valid) {\n      return __1.utils.getPeerId(peer, addMark);\n    } else {\n      peer = await client.getInputEntity(peer);\n    }\n  }\n  if (typeof peer == \"number\" || typeof peer == \"bigint\" || big_integer_1.default.isInstance(peer)) {\n    return __1.utils.getPeerId(peer, addMark);\n  }\n  if (peer.SUBCLASS_OF_ID == 0x2d45687 || peer.SUBCLASS_OF_ID == 0xc91c90b6) {\n    peer = await client.getInputEntity(peer);\n  }\n  if (peer instanceof tl_1.Api.InputPeerSelf) {\n    peer = await client.getMe(true);\n  }\n  return __1.utils.getPeerId(peer, addMark);\n}\n/** @hidden */\nasync function _getPeer(client, peer) {\n  if (!peer) {\n    return undefined;\n  }\n  const [i, cls] = __1.utils.resolveId((0, Helpers_1.returnBigInt)(await client.getPeerId(peer)));\n  return new cls({\n    userId: i,\n    channelId: i,\n    chatId: i\n  });\n}\n/** @hidden */\nasync function _getInputDialog(client, dialog) {\n  try {\n    if (dialog.SUBCLASS_OF_ID == 0xa21c9795) {\n      // crc32(b'InputDialogPeer')\n      dialog.peer = await client.getInputEntity(dialog.peer);\n      return dialog;\n    } else if (dialog.SUBCLASS_OF_ID == 0xc91c90b6) {\n      //crc32(b'InputPeer')\n      return new tl_1.Api.InputDialogPeer({\n        peer: dialog\n      });\n    }\n  } catch (e) {}\n  return new tl_1.Api.InputDialogPeer({\n    peer: dialog\n  });\n}\n/** @hidden */\nasync function _getInputNotify(client, notify) {\n  try {\n    if (notify.SUBCLASS_OF_ID == 0x58981615) {\n      if (notify instanceof tl_1.Api.InputNotifyPeer) {\n        notify.peer = await client.getInputEntity(notify.peer);\n      }\n      return notify;\n    }\n  } catch (e) {}\n  return new tl_1.Api.InputNotifyPeer({\n    peer: await client.getInputEntity(notify)\n  });\n}\n/** @hidden */\nfunction _selfId(client) {\n  return client._selfInputPeer ? client._selfInputPeer.userId : undefined;\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","invoke","getMe","isBot","isUserAuthorized","getEntity","getInputEntity","_getEntityFromString","getPeerId","_getPeer","_getInputDialog","_getInputNotify","_selfId","tl_1","require","Utils_1","Helpers_1","__1","big_integer_1","Logger_1","RequestState_1","client","request","dcId","otherSender","classType","Error","sender","_sender","getSender","undefined","userDisconnected","_connectedDeferred","promise","resolve","utils","_lastRequest","Date","getTime","state","RequestState","attempt","_requestRetries","addStateToQueue","result","finished","session","processEntities","_entityCache","add","e","errors","ServerError","errorMessage","_log","warn","constructor","name","sleep","FloodWaitError","FloodTestPhoneWaitError","seconds","floodSleepThreshold","info","className","PhoneMigrateError","NetworkMigrateError","UserMigrateError","newDc","shouldRaise","_switchDC","MsgWaitError","isReady","after","message","disconnect","connect","resetPromise","inputPeer","_selfInputPeer","me","Api","users","GetUsers","id","InputUserSelf","_bot","bot","getInputPeer","InputPeerUser","updates","GetState","entity","single","isArrayLike","entityArray","push","inputs","x","valid","parseID","lists","Map","_EntityType","USER","CHAT","CHANNEL","get","_entityType","chats","channels","length","chatIds","map","chatId","messages","GetChats","GetChannels","idEntity","user","set","channel","chat","InputPeerSelf","key","u","entries","User","self","peer","res","default","isInstance","toString","SUBCLASS_OF_ID","includes","returnBigInt","getPeer","PeerUser","InputUser","userId","accessHash","zero","UserEmpty","PeerChat","InputPeerChat","PeerChannel","InputChannel","channelId","_errorHandler","canSend","LogLevel","ERROR","console","error","JSON","stringify","string","phone","parsePhone","contacts","GetContacts","hash","ContactsNotModified","toLowerCase","username","isInvite","parseUsername","invite","CheckChatInvite","ChatInvite","ChatInviteAlready","ResolveUsername","pid","equals","addMark","i","cls","resolveId","dialog","InputDialogPeer","notify","InputNotifyPeer"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/client/users.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.invoke = invoke;\nexports.getMe = getMe;\nexports.isBot = isBot;\nexports.isUserAuthorized = isUserAuthorized;\nexports.getEntity = getEntity;\nexports.getInputEntity = getInputEntity;\nexports._getEntityFromString = _getEntityFromString;\nexports.getPeerId = getPeerId;\nexports._getPeer = _getPeer;\nexports._getInputDialog = _getInputDialog;\nexports._getInputNotify = _getInputNotify;\nexports._selfId = _selfId;\nconst tl_1 = require(\"../tl\");\nconst Utils_1 = require(\"../Utils\");\nconst Helpers_1 = require(\"../Helpers\");\nconst __1 = require(\"../\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst Logger_1 = require(\"../extensions/Logger\");\nconst RequestState_1 = require(\"../network/RequestState\");\n// UserMethods {\n// region Invoking Telegram request\n/** @hidden */\nasync function invoke(client, request, dcId, otherSender) {\n    if (request.classType !== \"request\") {\n        throw new Error(\"You can only invoke MTProtoRequests\");\n    }\n    let sender = client._sender;\n    if (dcId) {\n        sender = await client.getSender(dcId);\n    }\n    if (otherSender != undefined) {\n        sender = otherSender;\n    }\n    if (sender == undefined) {\n        throw new Error(\"Cannot send requests while disconnected. You need to call .connect()\");\n    }\n    if (sender.userDisconnected) {\n        throw new Error(\"Cannot send requests while disconnected. Please reconnect.\");\n    }\n    await client._connectedDeferred.promise;\n    await request.resolve(client, __1.utils);\n    client._lastRequest = new Date().getTime();\n    const state = new RequestState_1.RequestState(request);\n    let attempt = 0;\n    for (attempt = 0; attempt < client._requestRetries; attempt++) {\n        sender.addStateToQueue(state);\n        try {\n            const result = await state.promise;\n            state.finished.resolve();\n            client.session.processEntities(result);\n            client._entityCache.add(result);\n            return result;\n        }\n        catch (e) {\n            if (e instanceof __1.errors.ServerError ||\n                e.errorMessage === \"RPC_CALL_FAIL\" ||\n                e.errorMessage === \"RPC_MCGET_FAIL\") {\n                client._log.warn(`Telegram is having internal issues ${e.constructor.name}`);\n                await (0, Helpers_1.sleep)(2000);\n            }\n            else if (e instanceof __1.errors.FloodWaitError ||\n                e instanceof __1.errors.FloodTestPhoneWaitError) {\n                if (e.seconds <= client.floodSleepThreshold) {\n                    client._log.info(`Sleeping for ${e.seconds}s on flood wait (Caused by ${request.className})`);\n                    await (0, Helpers_1.sleep)(e.seconds * 1000);\n                }\n                else {\n                    state.finished.resolve();\n                    throw e;\n                }\n            }\n            else if (e instanceof __1.errors.PhoneMigrateError ||\n                e instanceof __1.errors.NetworkMigrateError ||\n                e instanceof __1.errors.UserMigrateError) {\n                client._log.info(`Phone migrated to ${e.newDc}`);\n                const shouldRaise = e instanceof __1.errors.PhoneMigrateError ||\n                    e instanceof __1.errors.NetworkMigrateError;\n                if (shouldRaise && (await client.isUserAuthorized())) {\n                    state.finished.resolve();\n                    throw e;\n                }\n                await client._switchDC(e.newDc);\n                sender =\n                    dcId === undefined\n                        ? client._sender\n                        : await client.getSender(dcId);\n            }\n            else if (e instanceof __1.errors.MsgWaitError) {\n                // We need to resend this after the old one was confirmed.\n                await state.isReady();\n                state.after = undefined;\n            }\n            else if (e.message === \"CONNECTION_NOT_INITED\") {\n                await client.disconnect();\n                await (0, Helpers_1.sleep)(2000);\n                await client.connect();\n            }\n            else {\n                state.finished.resolve();\n                throw e;\n            }\n        }\n        state.resetPromise();\n    }\n    throw new Error(`Request was unsuccessful ${attempt} time(s)`);\n}\n/** @hidden */\nasync function getMe(client, inputPeer) {\n    if (inputPeer && client._selfInputPeer) {\n        return client._selfInputPeer;\n    }\n    const me = (await client.invoke(new tl_1.Api.users.GetUsers({ id: [new tl_1.Api.InputUserSelf()] })))[0];\n    client._bot = me.bot;\n    if (!client._selfInputPeer) {\n        client._selfInputPeer = __1.utils.getInputPeer(me, false);\n    }\n    return inputPeer\n        ? client._selfInputPeer\n        : me;\n}\n/** @hidden */\nasync function isBot(client) {\n    if (client._bot === undefined) {\n        const me = await client.getMe();\n        if (me) {\n            return !(me instanceof tl_1.Api.InputPeerUser) ? me.bot : undefined;\n        }\n    }\n    return client._bot;\n}\n/** @hidden */\nasync function isUserAuthorized(client) {\n    try {\n        await client.invoke(new tl_1.Api.updates.GetState());\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n/** @hidden */\nasync function getEntity(client, entity) {\n    const single = !(0, Helpers_1.isArrayLike)(entity);\n    let entityArray = [];\n    if ((0, Helpers_1.isArrayLike)(entity)) {\n        entityArray = entity;\n    }\n    else {\n        entityArray.push(entity);\n    }\n    const inputs = [];\n    for (const x of entityArray) {\n        if (typeof x === \"string\") {\n            const valid = (0, Utils_1.parseID)(x);\n            if (valid) {\n                inputs.push(await client.getInputEntity(valid));\n            }\n            else {\n                inputs.push(x);\n            }\n        }\n        else {\n            inputs.push(await client.getInputEntity(x));\n        }\n    }\n    const lists = new Map([\n        [Helpers_1._EntityType.USER, []],\n        [Helpers_1._EntityType.CHAT, []],\n        [Helpers_1._EntityType.CHANNEL, []],\n    ]);\n    for (const x of inputs) {\n        try {\n            lists.get((0, Helpers_1._entityType)(x)).push(x);\n        }\n        catch (e) { }\n    }\n    let users = lists.get(Helpers_1._EntityType.USER);\n    let chats = lists.get(Helpers_1._EntityType.CHAT);\n    let channels = lists.get(Helpers_1._EntityType.CHANNEL);\n    if (users.length) {\n        users = await client.invoke(new tl_1.Api.users.GetUsers({\n            id: users,\n        }));\n    }\n    if (chats.length) {\n        const chatIds = chats.map((x) => x.chatId);\n        chats = (await client.invoke(new tl_1.Api.messages.GetChats({ id: chatIds }))).chats;\n    }\n    if (channels.length) {\n        channels = (await client.invoke(new tl_1.Api.channels.GetChannels({ id: channels }))).chats;\n    }\n    const idEntity = new Map();\n    for (const user of users) {\n        idEntity.set((0, Utils_1.getPeerId)(user), user);\n    }\n    for (const channel of channels) {\n        idEntity.set((0, Utils_1.getPeerId)(channel), channel);\n    }\n    for (const chat of chats) {\n        idEntity.set((0, Utils_1.getPeerId)(chat), chat);\n    }\n    const result = [];\n    for (const x of inputs) {\n        if (typeof x === \"string\") {\n            result.push(await _getEntityFromString(client, x));\n        }\n        else if (!(x instanceof tl_1.Api.InputPeerSelf)) {\n            result.push(idEntity.get((0, Utils_1.getPeerId)(x)));\n        }\n        else {\n            for (const [key, u] of idEntity.entries()) {\n                if (u instanceof tl_1.Api.User && u.self) {\n                    result.push(u);\n                    break;\n                }\n            }\n        }\n    }\n    return single ? result[0] : result;\n}\n/** @hidden */\nasync function getInputEntity(client, peer) {\n    // Short-circuit if the input parameter directly maps to an InputPeer\n    try {\n        return __1.utils.getInputPeer(peer);\n        // eslint-disable-next-line no-empty\n    }\n    catch (e) { }\n    // Next in priority is having a peer (or its ID) cached in-memory\n    try {\n        if (typeof peer == \"string\") {\n            const valid = (0, Utils_1.parseID)(peer);\n            if (valid) {\n                const res = client._entityCache.get(peer);\n                if (res) {\n                    return res;\n                }\n            }\n        }\n        if (typeof peer === \"number\" ||\n            typeof peer === \"bigint\" ||\n            big_integer_1.default.isInstance(peer)) {\n            const res = client._entityCache.get(peer.toString());\n            if (res) {\n                return res;\n            }\n        }\n        // 0x2d45687 == crc32(b'Peer')\n        if (typeof peer == \"object\" &&\n            !big_integer_1.default.isInstance(peer) &&\n            peer.SUBCLASS_OF_ID === 0x2d45687) {\n            const res = client._entityCache.get(__1.utils.getPeerId(peer));\n            if (res) {\n                return res;\n            }\n        }\n        // eslint-disable-next-line no-empty\n    }\n    catch (e) { }\n    // Then come known strings that take precedence\n    if (typeof peer == \"string\") {\n        if ([\"me\", \"this\", \"self\"].includes(peer)) {\n            return new tl_1.Api.InputPeerSelf();\n        }\n    }\n    // No InputPeer, cached peer, or known string. Fetch from disk cache\n    try {\n        if (peer != undefined) {\n            return client.session.getInputEntity(peer);\n        }\n        // eslint-disable-next-line no-empty\n    }\n    catch (e) { }\n    // Only network left to try\n    if (typeof peer === \"string\") {\n        return __1.utils.getInputPeer(await _getEntityFromString(client, peer));\n    }\n    // If we're a bot and the user has messaged us privately users.getUsers\n    // will work with accessHash = 0. Similar for channels.getChannels.\n    // If we're not a bot but the user is in our contacts, it seems to work\n    // regardless. These are the only two special-cased requests.\n    if (typeof peer === \"number\") {\n        peer = (0, Helpers_1.returnBigInt)(peer);\n    }\n    peer = __1.utils.getPeer(peer);\n    if (peer instanceof tl_1.Api.PeerUser) {\n        const users = await client.invoke(new tl_1.Api.users.GetUsers({\n            id: [\n                new tl_1.Api.InputUser({\n                    userId: peer.userId,\n                    accessHash: big_integer_1.default.zero,\n                }),\n            ],\n        }));\n        if (users.length && !(users[0] instanceof tl_1.Api.UserEmpty)) {\n            // If the user passed a valid ID they expect to work for\n            // channels but would be valid for users, we get UserEmpty.\n            // Avoid returning the invalid empty input peer for that.\n            //\n            // We *could* try to guess if it's a channel first, and if\n            // it's not, work as a chat and try to validate it through\n            // another request, but that becomes too much work.\n            return __1.utils.getInputPeer(users[0]);\n        }\n    }\n    else if (peer instanceof tl_1.Api.PeerChat) {\n        return new tl_1.Api.InputPeerChat({\n            chatId: peer.chatId,\n        });\n    }\n    else if (peer instanceof tl_1.Api.PeerChannel) {\n        try {\n            const channels = await client.invoke(new tl_1.Api.channels.GetChannels({\n                id: [\n                    new tl_1.Api.InputChannel({\n                        channelId: peer.channelId,\n                        accessHash: big_integer_1.default.zero,\n                    }),\n                ],\n            }));\n            return __1.utils.getInputPeer(channels.chats[0]);\n        }\n        catch (e) {\n            if (client._errorHandler) {\n                await client._errorHandler(e);\n            }\n            if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\n                console.error(e);\n            }\n        }\n    }\n    throw new Error(`Could not find the input entity for ${JSON.stringify(peer)}.\r\n         Please read https://` +\n        \"docs.telethon.dev/en/stable/concepts/entities.html to\" +\n        \" find out more details.\");\n}\n/** @hidden */\nasync function _getEntityFromString(client, string) {\n    const phone = __1.utils.parsePhone(string);\n    if (phone) {\n        try {\n            const result = await client.invoke(new tl_1.Api.contacts.GetContacts({\n                hash: big_integer_1.default.zero,\n            }));\n            if (!(result instanceof tl_1.Api.contacts.ContactsNotModified)) {\n                for (const user of result.users) {\n                    if (user instanceof tl_1.Api.User && user.phone === phone) {\n                        return user;\n                    }\n                }\n            }\n        }\n        catch (e) {\n            if (e.errorMessage === \"BOT_METHOD_INVALID\") {\n                throw new Error(\"Cannot get entity by phone number as a \" +\n                    \"bot (try using integer IDs, not strings)\");\n            }\n            throw e;\n        }\n    }\n    const id = __1.utils.parseID(string);\n    if (id != undefined) {\n        return getInputEntity(client, id);\n    }\n    else if ([\"me\", \"this\"].includes(string.toLowerCase())) {\n        return client.getMe();\n    }\n    else {\n        const { username, isInvite } = __1.utils.parseUsername(string);\n        if (isInvite) {\n            const invite = await client.invoke(new tl_1.Api.messages.CheckChatInvite({\n                hash: username,\n            }));\n            if (invite instanceof tl_1.Api.ChatInvite) {\n                throw new Error(\"Cannot get entity from a channel (or group) \" +\n                    \"that you are not part of. Join the group and retry\");\n            }\n            else if (invite instanceof tl_1.Api.ChatInviteAlready) {\n                return invite.chat;\n            }\n        }\n        else if (username) {\n            try {\n                const result = await client.invoke(new tl_1.Api.contacts.ResolveUsername({ username: username }));\n                const pid = __1.utils.getPeerId(result.peer, false);\n                if (result.peer instanceof tl_1.Api.PeerUser) {\n                    for (const x of result.users) {\n                        if ((0, Helpers_1.returnBigInt)(x.id).equals((0, Helpers_1.returnBigInt)(pid))) {\n                            return x;\n                        }\n                    }\n                }\n                else {\n                    for (const x of result.chats) {\n                        if ((0, Helpers_1.returnBigInt)(x.id).equals((0, Helpers_1.returnBigInt)(pid))) {\n                            return x;\n                        }\n                    }\n                }\n            }\n            catch (e) {\n                if (e.errorMessage === \"USERNAME_NOT_OCCUPIED\") {\n                    throw new Error(`No user has \"${username}\" as username`);\n                }\n                throw e;\n            }\n        }\n    }\n    throw new Error(`Cannot find any entity corresponding to \"${string}\"`);\n}\n/** @hidden */\nasync function getPeerId(client, peer, addMark = true) {\n    if (typeof peer == \"string\") {\n        const valid = (0, Utils_1.parseID)(peer);\n        if (valid) {\n            return __1.utils.getPeerId(peer, addMark);\n        }\n        else {\n            peer = await client.getInputEntity(peer);\n        }\n    }\n    if (typeof peer == \"number\" ||\n        typeof peer == \"bigint\" ||\n        big_integer_1.default.isInstance(peer)) {\n        return __1.utils.getPeerId(peer, addMark);\n    }\n    if (peer.SUBCLASS_OF_ID == 0x2d45687 || peer.SUBCLASS_OF_ID == 0xc91c90b6) {\n        peer = await client.getInputEntity(peer);\n    }\n    if (peer instanceof tl_1.Api.InputPeerSelf) {\n        peer = await client.getMe(true);\n    }\n    return __1.utils.getPeerId(peer, addMark);\n}\n/** @hidden */\nasync function _getPeer(client, peer) {\n    if (!peer) {\n        return undefined;\n    }\n    const [i, cls] = __1.utils.resolveId((0, Helpers_1.returnBigInt)(await client.getPeerId(peer)));\n    return new cls({\n        userId: i,\n        channelId: i,\n        chatId: i,\n    });\n}\n/** @hidden */\nasync function _getInputDialog(client, dialog) {\n    try {\n        if (dialog.SUBCLASS_OF_ID == 0xa21c9795) {\n            // crc32(b'InputDialogPeer')\n            dialog.peer = await client.getInputEntity(dialog.peer);\n            return dialog;\n        }\n        else if (dialog.SUBCLASS_OF_ID == 0xc91c90b6) {\n            //crc32(b'InputPeer')\n            return new tl_1.Api.InputDialogPeer({\n                peer: dialog,\n            });\n        }\n    }\n    catch (e) { }\n    return new tl_1.Api.InputDialogPeer({\n        peer: dialog,\n    });\n}\n/** @hidden */\nasync function _getInputNotify(client, notify) {\n    try {\n        if (notify.SUBCLASS_OF_ID == 0x58981615) {\n            if (notify instanceof tl_1.Api.InputNotifyPeer) {\n                notify.peer = await client.getInputEntity(notify.peer);\n            }\n            return notify;\n        }\n    }\n    catch (e) { }\n    return new tl_1.Api.InputNotifyPeer({\n        peer: await client.getInputEntity(notify),\n    });\n}\n/** @hidden */\nfunction _selfId(client) {\n    return client._selfInputPeer ? client._selfInputPeer.userId : undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}