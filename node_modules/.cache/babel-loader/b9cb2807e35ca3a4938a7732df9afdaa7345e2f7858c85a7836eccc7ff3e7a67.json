{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HTMLParser = void 0;\nconst htmlparser2_1 = require(\"htmlparser2\");\nconst tl_1 = require(\"../tl\");\nconst index_1 = require(\"../index\");\nclass HTMLToTelegramParser {\n  constructor() {\n    this.text = \"\";\n    this.entities = [];\n    this._buildingEntities = new Map();\n    this._openTags = [];\n    this._openTagsMeta = [];\n  }\n  onopentag(name, attributes) {\n    /*\n     * This fires when a new tag is opened.\n     *\n     * If you don't need an aggregated `attributes` object,\n     * have a look at the `onopentagname` and `onattribute` events.\n     */\n    this._openTags.unshift(name);\n    this._openTagsMeta.unshift(undefined);\n    let EntityType;\n    const args = {};\n    if (name == \"strong\" || name == \"b\") {\n      EntityType = tl_1.Api.MessageEntityBold;\n    } else if (name == \"spoiler\") {\n      EntityType = tl_1.Api.MessageEntitySpoiler;\n    } else if (name == \"em\" || name == \"i\") {\n      EntityType = tl_1.Api.MessageEntityItalic;\n    } else if (name == \"u\") {\n      EntityType = tl_1.Api.MessageEntityUnderline;\n    } else if (name == \"del\" || name == \"s\") {\n      EntityType = tl_1.Api.MessageEntityStrike;\n    } else if (name == \"blockquote\") {\n      EntityType = tl_1.Api.MessageEntityBlockquote;\n      if (attributes.expandable !== undefined) {\n        args.collapsed = true;\n      }\n    } else if (name == \"code\") {\n      const pre = this._buildingEntities.get(\"pre\");\n      if (pre && pre instanceof tl_1.Api.MessageEntityPre) {\n        try {\n          pre.language = attributes.class.slice(\"language-\".length, attributes.class.length);\n        } catch (e) {\n          // no language block\n        }\n      } else {\n        EntityType = tl_1.Api.MessageEntityCode;\n      }\n    } else if (name == \"pre\") {\n      EntityType = tl_1.Api.MessageEntityPre;\n      args[\"language\"] = \"\";\n    } else if (name == \"a\") {\n      let url = attributes.href;\n      if (!url) {\n        return;\n      }\n      if (url.startsWith(\"mailto:\")) {\n        url = url.slice(\"mailto:\".length, url.length);\n        EntityType = tl_1.Api.MessageEntityEmail;\n      } else {\n        EntityType = tl_1.Api.MessageEntityTextUrl;\n        args[\"url\"] = url;\n        url = undefined;\n      }\n      this._openTagsMeta.shift();\n      this._openTagsMeta.unshift(url);\n    } else if (name == \"tg-emoji\") {\n      EntityType = tl_1.Api.MessageEntityCustomEmoji;\n      args[\"documentId\"] = attributes[\"emoji-id\"];\n    }\n    if (EntityType && !this._buildingEntities.has(name)) {\n      this._buildingEntities.set(name, new EntityType(Object.assign({\n        offset: this.text.length,\n        length: 0\n      }, args)));\n    }\n  }\n  ontext(text) {\n    const previousTag = this._openTags.length > 0 ? this._openTags[0] : \"\";\n    if (previousTag == \"a\") {\n      const url = this._openTagsMeta[0];\n      if (url) {\n        text = url;\n      }\n    }\n    for (let [tag, entity] of this._buildingEntities) {\n      entity.length += text.length;\n    }\n    this.text += text;\n  }\n  onclosetag(tagname) {\n    this._openTagsMeta.shift();\n    this._openTags.shift();\n    const entity = this._buildingEntities.get(tagname);\n    if (entity) {\n      this._buildingEntities.delete(tagname);\n      this.entities.push(entity);\n    }\n  }\n  onattribute(name, value, quote) {}\n  oncdataend() {}\n  oncdatastart() {}\n  oncomment(data) {}\n  oncommentend() {}\n  onend() {}\n  onerror(error) {}\n  onopentagname(name) {}\n  onparserinit(parser) {}\n  onprocessinginstruction(name, data) {}\n  onreset() {}\n}\nclass HTMLParser {\n  static parse(html) {\n    if (!html) {\n      return [html, []];\n    }\n    const handler = new HTMLToTelegramParser();\n    const parser = new htmlparser2_1.Parser(handler);\n    parser.write(html);\n    parser.end();\n    const text = index_1.helpers.stripText(handler.text, handler.entities);\n    return [text, handler.entities];\n  }\n  static unparse(text, entities) {\n    let _offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let _length = arguments.length > 3 ? arguments[3] : undefined;\n    if (!text || !entities || !entities.length) {\n      return text;\n    }\n    if (_length == undefined) {\n      _length = text.length;\n    }\n    const html = [];\n    let lastOffset = 0;\n    for (let i = 0; i < entities.length; i++) {\n      const entity = entities[i];\n      if (entity.offset >= _offset + _length) {\n        break;\n      }\n      let relativeOffset = entity.offset - _offset;\n      if (relativeOffset > lastOffset) {\n        html.push(text.slice(lastOffset, relativeOffset));\n      } else if (relativeOffset < lastOffset) {\n        continue;\n      }\n      let skipEntity = false;\n      let length = entity.length;\n      let entityText = this.unparse(text.slice(relativeOffset, relativeOffset + length), entities.slice(i + 1, entities.length), entity.offset, length);\n      if (entity instanceof tl_1.Api.MessageEntityBold) {\n        html.push(`<strong>${entityText}</strong>`);\n      } else if (entity instanceof tl_1.Api.MessageEntitySpoiler) {\n        html.push(`<spoiler>${entityText}</spoiler>`);\n      } else if (entity instanceof tl_1.Api.MessageEntityItalic) {\n        html.push(`<em>${entityText}</em>`);\n      } else if (entity instanceof tl_1.Api.MessageEntityCode) {\n        html.push(`<code>${entityText}</code>`);\n      } else if (entity instanceof tl_1.Api.MessageEntityUnderline) {\n        html.push(`<u>${entityText}</u>`);\n      } else if (entity instanceof tl_1.Api.MessageEntityStrike) {\n        html.push(`<del>${entityText}</del>`);\n      } else if (entity instanceof tl_1.Api.MessageEntityBlockquote) {\n        html.push(`<blockquote>${entityText}</blockquote>`);\n      } else if (entity instanceof tl_1.Api.MessageEntityPre) {\n        if (entity.language) {\n          html.push(`<pre><code class=\"language-${entity.language}\">${entityText}</code></pre>`);\n        } else {\n          html.push(`<pre>${entityText}</pre>`);\n        }\n      } else if (entity instanceof tl_1.Api.MessageEntityEmail) {\n        html.push(`<a href=\"mailto:${entityText}\">${entityText}</a>`);\n      } else if (entity instanceof tl_1.Api.MessageEntityUrl) {\n        html.push(`<a href=\"${entityText}\">${entityText}</a>`);\n      } else if (entity instanceof tl_1.Api.MessageEntityTextUrl) {\n        html.push(`<a href=\"${entity.url}\">${entityText}</a>`);\n      } else if (entity instanceof tl_1.Api.MessageEntityMentionName) {\n        html.push(`<a href=\"tg://user?id=${entity.userId}\">${entityText}</a>`);\n      } else if (entity instanceof tl_1.Api.MessageEntityCustomEmoji) {\n        html.push(`<tg-emoji emoji-id=\"${entity.documentId}\">${entityText}</tg-emoji>`);\n      } else {\n        skipEntity = true;\n      }\n      lastOffset = relativeOffset + (skipEntity ? 0 : length);\n    }\n    html.push(text.slice(lastOffset, text.length));\n    return html.join(\"\");\n  }\n}\nexports.HTMLParser = HTMLParser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}