{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StopPropagation = void 0;\nexports.on = on;\nexports.addEventHandler = addEventHandler;\nexports.removeEventHandler = removeEventHandler;\nexports.listEventHandlers = listEventHandlers;\nexports.catchUp = catchUp;\nexports._handleUpdate = _handleUpdate;\nexports._processUpdate = _processUpdate;\nexports._dispatchUpdate = _dispatchUpdate;\nexports._updateLoop = _updateLoop;\nconst tl_1 = require(\"../tl\");\nconst network_1 = require(\"../network\");\nconst index_1 = require(\"../index\");\nconst Helpers_1 = require(\"../Helpers\");\nconst Logger_1 = require(\"../extensions/Logger\");\nconst PING_INTERVAL = 9000; // 9 sec\nconst PING_TIMEOUT = 10000; // 10 sec\nconst PING_FAIL_ATTEMPTS = 3;\nconst PING_FAIL_INTERVAL = 100; // ms\nconst PING_DISCONNECT_DELAY = 60000; // 1 min\n// An unusually long interval is a sign of returning from background mode...\nconst PING_INTERVAL_TO_WAKE_UP = 5000; // 5 sec\n// ... so we send a quick \"wake-up\" ping to confirm than connection was dropped ASAP\nconst PING_WAKE_UP_TIMEOUT = 3000; // 3 sec\n// We also send a warning to the user even a bit more quickly\nconst PING_WAKE_UP_WARNING_TIMEOUT = 1000; // 1 sec\n/**\n If this exception is raised in any of the handlers for a given event,\n it will stop the execution of all other registered event handlers.\n It can be seen as the ``StopIteration`` in a for loop but for events.\n */\nclass StopPropagation extends Error {}\nexports.StopPropagation = StopPropagation;\n/** @hidden */\nfunction on(client, event) {\n  return f => {\n    client.addEventHandler(f, event);\n    return f;\n  };\n}\n/** @hidden */\nfunction addEventHandler(client, callback, event) {\n  if (event == undefined) {\n    // recursive imports :(\n    const raw = require(\"../events/Raw\").Raw;\n    event = new raw({});\n  }\n  event.client = client;\n  client._eventBuilders.push([event, callback]);\n}\n/** @hidden */\nfunction removeEventHandler(client, callback, event) {\n  client._eventBuilders = client._eventBuilders.filter(function (item) {\n    return item[0] !== event && item[1] !== callback;\n  });\n}\n/** @hidden */\nfunction listEventHandlers(client) {\n  return client._eventBuilders;\n}\n/** @hidden */\nfunction catchUp() {\n  // TODO\n}\n/** @hidden */\nfunction _handleUpdate(client, update) {\n  if (typeof update === \"number\") {\n    if ([-1, 0, 1].includes(update)) {\n      _dispatchUpdate(client, {\n        update: new network_1.UpdateConnectionState(update)\n      });\n      return;\n    }\n  }\n  //this.session.processEntities(update)\n  client._entityCache.add(update);\n  client.session.processEntities(update);\n  if (update instanceof tl_1.Api.Updates || update instanceof tl_1.Api.UpdatesCombined) {\n    // TODO deal with entities\n    const entities = new Map();\n    for (const x of [...update.users, ...update.chats]) {\n      entities.set(index_1.utils.getPeerId(x), x);\n    }\n    for (const u of update.updates) {\n      _processUpdate(client, u, update.updates, entities);\n    }\n  } else if (update instanceof tl_1.Api.UpdateShort) {\n    _processUpdate(client, update.update, null);\n  } else {\n    _processUpdate(client, update, null);\n  }\n}\n/** @hidden */\nfunction _processUpdate(client, update, others, entities) {\n  update._entities = entities || new Map();\n  const args = {\n    update: update,\n    others: others\n  };\n  _dispatchUpdate(client, args);\n}\n/** @hidden */\nasync function _dispatchUpdate(client, args) {\n  for (const [builder, callback] of client._eventBuilders) {\n    if (!builder || !callback) {\n      continue;\n    }\n    if (!builder.resolved) {\n      await builder.resolve(client);\n    }\n    let event = args.update;\n    if (event) {\n      if (!client._selfInputPeer) {\n        try {\n          await client.getMe(true);\n        } catch (e) {\n          // do nothing\n        }\n      }\n      if (!(event instanceof network_1.UpdateConnectionState)) {\n        // TODO fix me\n      }\n      // TODO fix others not being passed\n      event = builder.build(event, callback, client._selfInputPeer ? (0, Helpers_1.returnBigInt)(client._selfInputPeer.userId) : undefined);\n      if (event) {\n        event._client = client;\n        if (\"_eventName\" in event) {\n          event._setClient(client);\n          event.originalUpdate = args.update;\n          event._entities = args.update._entities;\n        }\n        const filter = await builder.filter(event);\n        if (!filter) {\n          continue;\n        }\n        try {\n          await callback(event);\n        } catch (e) {\n          if (e instanceof StopPropagation) {\n            break;\n          }\n          if (client._errorHandler) {\n            await client._errorHandler(e);\n          }\n          if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\n            console.error(e);\n          }\n        }\n      }\n    }\n  }\n}\n/** @hidden */\nasync function _updateLoop(client) {\n  let lastPongAt;\n  while (!client._destroyed) {\n    await (0, Helpers_1.sleep)(PING_INTERVAL, true);\n    if (client._destroyed) break;\n    if (client._sender.isReconnecting || client._isSwitchingDc) {\n      lastPongAt = undefined;\n      continue;\n    }\n    try {\n      const ping = () => {\n        return client._sender.send(new tl_1.Api.PingDelayDisconnect({\n          pingId: (0, Helpers_1.returnBigInt)((0, Helpers_1.getRandomInt)(Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)),\n          disconnectDelay: PING_DISCONNECT_DELAY\n        }));\n      };\n      const pingAt = Date.now();\n      const lastInterval = lastPongAt ? pingAt - lastPongAt : undefined;\n      if (!lastInterval || lastInterval < PING_INTERVAL_TO_WAKE_UP) {\n        await attempts(() => timeout(ping, PING_TIMEOUT), PING_FAIL_ATTEMPTS, PING_FAIL_INTERVAL);\n      } else {\n        let wakeUpWarningTimeout = setTimeout(() => {\n          _handleUpdate(client, network_1.UpdateConnectionState.disconnected);\n          wakeUpWarningTimeout = undefined;\n        }, PING_WAKE_UP_WARNING_TIMEOUT);\n        await timeout(ping, PING_WAKE_UP_TIMEOUT);\n        if (wakeUpWarningTimeout) {\n          clearTimeout(wakeUpWarningTimeout);\n          wakeUpWarningTimeout = undefined;\n        }\n        _handleUpdate(client, network_1.UpdateConnectionState.connected);\n      }\n      lastPongAt = Date.now();\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      if (client._errorHandler) {\n        await client._errorHandler(err);\n      }\n      if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\n        console.error(err);\n      }\n      lastPongAt = undefined;\n      if (client._sender.isReconnecting || client._isSwitchingDc) {\n        continue;\n      }\n      client._sender.reconnect();\n    }\n    // We need to send some content-related request at least hourly\n    // for Telegram to keep delivering updates, otherwise they will\n    // just stop even if we're connected. Do so every 30 minutes.\n    if (Date.now() - (client._lastRequest || 0) > 30 * 60 * 1000) {\n      try {\n        await client.invoke(new tl_1.Api.updates.GetState());\n      } catch (e) {\n        // we don't care about errors here\n      }\n      lastPongAt = undefined;\n    }\n  }\n  await client.disconnect();\n}\n/** @hidden */\nasync function attempts(cb, times, pause) {\n  for (let i = 0; i < times; i++) {\n    try {\n      // We need to `return await` here so it can be caught locally\n      return await cb();\n    } catch (err) {\n      if (i === times - 1) {\n        throw err;\n      }\n      await (0, Helpers_1.sleep)(pause);\n    }\n  }\n  return undefined;\n}\n/** @hidden */\nfunction timeout(cb, ms) {\n  let isResolved = false;\n  return Promise.race([cb(), (0, Helpers_1.sleep)(ms).then(() => isResolved ? undefined : Promise.reject(new Error(\"TIMEOUT\")))]).finally(() => {\n    isResolved = true;\n  });\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}