{"ast":null,"code":"\"use strict\";\n\nconst {\n  inspect\n} = require(\"../inspect\");\nconst bigInt = require(\"big-integer\");\nconst {\n  generateRandomBytes,\n  readBigIntFromBuffer,\n  isArrayLike,\n  betterConsoleLog\n} = require(\"../Helpers\");\nconst tlContent = require(\"./apiTl.js\");\nconst schemeContent = require(\"./schemaTl.js\");\nfunction generateRandomBigInt() {\n  return readBigIntFromBuffer(generateRandomBytes(8), false, true);\n}\nconst {\n  parseTl,\n  serializeBytes,\n  serializeDate\n} = require(\"./generationHelpers\");\nconst {\n  toSignedLittleBuffer\n} = require(\"../Helpers\");\nconst NAMED_AUTO_CASTS = new Set([\"chatId,int\"]);\nconst NAMED_BLACKLIST = new Set([\"discardEncryption\"]);\nconst AUTO_CASTS = new Set([\"InputPeer\", \"InputChannel\", \"InputUser\", \"InputDialogPeer\", \"InputNotifyPeer\", \"InputMedia\", \"InputPhoto\", \"InputMessage\", \"InputDocument\", \"InputChatPhoto\"]);\nclass CastError extends Error {\n  constructor(objectName, expected, actual, ...params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    const message = \"Found wrong type for \" + objectName + \". expected \" + expected + \" but received \" + actual + \".If you think this is a mistake please report it.\";\n    super(message, ...params);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CastError);\n    }\n    this.name = \"CastError\";\n    // Custom debugging information\n  }\n}\nconst CACHING_SUPPORTED = typeof self !== \"undefined\" && self.localStorage !== undefined;\nconst CACHE_KEY = \"GramJs:apiCache\";\nfunction buildApiFromTlSchema() {\n  let definitions;\n  const fromCache = CACHING_SUPPORTED && loadFromCache();\n  if (fromCache) {\n    definitions = fromCache;\n  } else {\n    definitions = loadFromTlSchemas();\n    if (CACHING_SUPPORTED) {\n      localStorage.setItem(CACHE_KEY, JSON.stringify(definitions));\n    }\n  }\n  return createClasses(\"all\", definitions);\n}\nfunction loadFromCache() {\n  const jsonCache = localStorage.getItem(CACHE_KEY);\n  return jsonCache && JSON.parse(jsonCache);\n}\nfunction loadFromTlSchemas() {\n  const [constructorParamsApi, functionParamsApi] = extractParams(tlContent);\n  const [constructorParamsSchema, functionParamsSchema] = extractParams(schemeContent);\n  const constructors = [].concat(constructorParamsApi, constructorParamsSchema);\n  const requests = [].concat(functionParamsApi, functionParamsSchema);\n  return [].concat(constructors, requests);\n}\nfunction extractParams(fileContent) {\n  const f = parseTl(fileContent, 109);\n  const constructors = [];\n  const functions = [];\n  for (const d of f) {\n    d.isFunction ? functions.push(d) : constructors.push(d);\n  }\n  return [constructors, functions];\n}\nfunction argToBytes(x, type, argName, requestName) {\n  switch (type) {\n    case \"int\":\n      const i = Buffer.alloc(4);\n      i.writeInt32LE(x, 0);\n      return i;\n    case \"long\":\n      return toSignedLittleBuffer(x, 8);\n    case \"int128\":\n      return toSignedLittleBuffer(x, 16);\n    case \"int256\":\n      return toSignedLittleBuffer(x, 32);\n    case \"double\":\n      const d = Buffer.alloc(8);\n      d.writeDoubleLE(x, 0);\n      return d;\n    case \"string\":\n      return serializeBytes(x);\n    case \"Bool\":\n      return x ? Buffer.from(\"b5757299\", \"hex\") : Buffer.from(\"379779bc\", \"hex\");\n    case \"true\":\n      return Buffer.alloc(0);\n    case \"bytes\":\n      return serializeBytes(x);\n    case \"date\":\n      return serializeDate(x);\n    default:\n      if (x === undefined || typeof x.getBytes !== \"function\") {\n        throw new Error(`Required object ${argName} of ${requestName} is undefined`);\n      }\n      return x.getBytes();\n  }\n}\nasync function getInputFromResolve(utils, client, peer, peerType) {\n  switch (peerType) {\n    case \"InputPeer\":\n      return utils.getInputPeer(await client.getInputEntity(peer));\n    case \"InputChannel\":\n      return utils.getInputChannel(await client.getInputEntity(peer));\n    case \"InputUser\":\n      return utils.getInputUser(await client.getInputEntity(peer));\n    case \"InputDialogPeer\":\n      return await client._getInputDialog(peer);\n    case \"InputNotifyPeer\":\n      return await client._getInputNotify(peer);\n    case \"InputMedia\":\n      return utils.getInputMedia(peer);\n    case \"InputPhoto\":\n      return utils.getInputPhoto(peer);\n    case \"InputMessage\":\n      return utils.getInputMessage(peer);\n    case \"InputDocument\":\n      return utils.getInputDocument(peer);\n    case \"InputChatPhoto\":\n      return utils.getInputChatPhoto(peer);\n    case \"chatId,int\":\n      return await client.getPeerId(peer, false);\n    default:\n      throw new Error(\"unsupported peer type : \" + peerType);\n  }\n}\nfunction getArgFromReader(reader, arg) {\n  if (arg.isVector) {\n    if (arg.useVectorId) {\n      reader.readInt();\n    }\n    const temp = [];\n    const len = reader.readInt();\n    arg.isVector = false;\n    for (let i = 0; i < len; i++) {\n      temp.push(getArgFromReader(reader, arg));\n    }\n    arg.isVector = true;\n    return temp;\n  } else if (arg.flagIndicator) {\n    return reader.readInt();\n  } else {\n    switch (arg.type) {\n      case \"int\":\n        return reader.readInt();\n      case \"long\":\n        return reader.readLong();\n      case \"int128\":\n        return reader.readLargeInt(128);\n      case \"int256\":\n        return reader.readLargeInt(256);\n      case \"double\":\n        return reader.readDouble();\n      case \"string\":\n        return reader.tgReadString();\n      case \"Bool\":\n        return reader.tgReadBool();\n      case \"true\":\n        return true;\n      case \"bytes\":\n        return reader.tgReadBytes();\n      case \"date\":\n        return reader.tgReadDate();\n      default:\n        if (!arg.skipConstructorId) {\n          return reader.tgReadObject();\n        } else {\n          return api.constructors[arg.type].fromReader(reader);\n        }\n    }\n  }\n}\nfunction compareType(value, type) {\n  let correct = true;\n  switch (type) {\n    case \"number\":\n      correct = typeof value === \"number\" || value === undefined;\n      break;\n    case \"string\":\n    case \"boolean\":\n      correct = typeof value === type;\n      break;\n    case \"bigInt\":\n      correct = bigInt.isInstance(value) || typeof value === \"bigint\" || typeof value === \"number\" || typeof value === \"string\" || value === undefined;\n      break;\n    case \"true\":\n      // true value is always correct\n      break;\n    case \"buffer\":\n      correct = Buffer.isBuffer(value);\n      break;\n    case \"date\":\n      correct = value && Object.prototype.toString.call(value) === \"[object Date]\" && !isNaN(value) || typeof value === \"number\";\n      break;\n    default:\n      console.error(new Error(\"Unknown type.\" + type));\n  }\n  return correct;\n}\nfunction createClasses(classesType, params) {\n  const classes = {};\n  for (const classParams of params) {\n    const {\n      name,\n      constructorId,\n      subclassOfId,\n      argsConfig,\n      namespace,\n      isFunction,\n      result\n    } = classParams;\n    const fullName = [namespace, name].join(\".\").replace(/^\\./, \"\");\n    class VirtualClass {\n      constructor(args) {\n        this.CONSTRUCTOR_ID = constructorId;\n        this.SUBCLASS_OF_ID = subclassOfId;\n        this.className = fullName;\n        this.classType = isFunction ? \"request\" : \"constructor\";\n        args = args || {};\n        this.originalArgs = args;\n        this.init(args);\n        for (const argName in argsConfig) {\n          if (argName === \"randomId\" && !args[argName]) {\n            if (argsConfig[argName].isVector) {\n              const rands = [];\n              for (let i = 0; i < args[\"id\"].length; i++) {\n                rands.push(generateRandomBigInt());\n              }\n              this[argName] = rands;\n            } else {\n              this[argName] = generateRandomBigInt();\n            }\n          } else {\n            this[argName] = args[argName];\n          }\n        }\n      }\n      init(args) {}\n      static fromReader(reader) {\n        const args = {};\n        for (const argName in argsConfig) {\n          if (argsConfig.hasOwnProperty(argName)) {\n            const arg = argsConfig[argName];\n            if (arg.isFlag) {\n              if (arg.type === \"true\") {\n                args[argName] = Boolean(args[arg.flagName] & 1 << arg.flagIndex);\n                continue;\n              }\n              if (args[arg.flagName] & 1 << arg.flagIndex) {\n                args[argName] = getArgFromReader(reader, arg);\n              } else {\n                args[argName] = null;\n              }\n            } else {\n              if (arg.flagIndicator) {\n                arg.name = argName;\n              }\n              args[argName] = getArgFromReader(reader, arg);\n            }\n          }\n        }\n        return new this(args);\n      }\n      validate() {\n        for (const arg in argsConfig) {\n          if (argsConfig.hasOwnProperty(arg)) {\n            if (argsConfig[arg].flagIndicator || argsConfig[arg].isFlag) {\n              // we don't care about flags\n              continue;\n            }\n            const currentValue = this[arg];\n            this.assertType(arg, argsConfig[arg], currentValue);\n          }\n        }\n      }\n      assertType(objectName, object, value) {\n        let expected;\n        if (object[\"isVector\"]) {\n          if (!isArrayLike(value)) {\n            console.error(new CastError(objectName, \"array\", value));\n          }\n          if (value == undefined) {\n            value = [];\n          }\n          for (const o of value) {\n            this.assertType(objectName, Object.assign(Object.assign({}, object), {\n              isVector: false\n            }), o);\n          }\n        } else {\n          switch (object[\"type\"]) {\n            case \"int\":\n              expected = \"number\";\n              break;\n            case \"long\":\n            case \"int128\":\n            case \"int256\":\n              expected = \"bigInt\";\n              break;\n            case \"double\":\n              expected = \"number\";\n              break;\n            case \"string\":\n              expected = \"string\";\n              break;\n            case \"Bool\":\n              expected = \"boolean\";\n              break;\n            case \"true\":\n              expected = \"true\";\n              break;\n            case \"bytes\":\n              expected = \"buffer\";\n              break;\n            case \"date\":\n              expected = \"date\";\n              break;\n            default:\n              expected = \"object\";\n          }\n          if (expected === \"object\") {\n            // will be validated in get byte();\n          } else {\n            const isCorrectType = compareType(value, expected);\n            if (isCorrectType !== true) {\n              console.error(new CastError(objectName, expected, value));\n            }\n          }\n        }\n      }\n      getBytes() {\n        try {\n          this.validate();\n        } catch (e) {\n          // feature still in alpha so errors are expected.\n        }\n        const idForBytes = this.CONSTRUCTOR_ID;\n        const c = Buffer.alloc(4);\n        c.writeUInt32LE(idForBytes, 0);\n        const buffers = [c];\n        for (const arg in argsConfig) {\n          if (argsConfig.hasOwnProperty(arg)) {\n            if (argsConfig[arg].isFlag) {\n              if (this[arg] === false && argsConfig[arg].type !== \"Bool\" || this[arg] === null || this[arg] === undefined || argsConfig[arg].type === \"true\") {\n                continue;\n              }\n            }\n            if (argsConfig[arg].isVector) {\n              if (argsConfig[arg].useVectorId) {\n                buffers.push(Buffer.from(\"15c4b51c\", \"hex\"));\n              }\n              const l = Buffer.alloc(4);\n              l.writeInt32LE(this[arg].length, 0);\n              buffers.push(l, Buffer.concat(this[arg].map(x => argToBytes(x, argsConfig[arg].type, fullName))));\n            } else if (argsConfig[arg].flagIndicator) {\n              if (!Object.values(argsConfig).some(f => f.isFlag)) {\n                buffers.push(Buffer.alloc(4));\n              } else {\n                let flagCalculate = 0;\n                for (const f in argsConfig) {\n                  if (argsConfig[f].isFlag && arg === argsConfig[f].flagName) {\n                    if (this[f] === false && argsConfig[f].type !== \"Bool\" || this[f] === undefined || this[f] === null) {\n                      flagCalculate |= 0;\n                    } else {\n                      flagCalculate |= 1 << argsConfig[f].flagIndex;\n                    }\n                  }\n                }\n                const f = Buffer.alloc(4);\n                f.writeUInt32LE(flagCalculate, 0);\n                buffers.push(f);\n              }\n            } else {\n              buffers.push(argToBytes(this[arg], argsConfig[arg].type, arg, fullName));\n              if (this[arg] && typeof this[arg].getBytes === \"function\") {\n                let boxed = argsConfig[arg].type.charAt(argsConfig[arg].type.indexOf(\".\") + 1);\n                boxed = boxed === boxed.toUpperCase();\n                if (!boxed) {\n                  buffers.shift();\n                }\n              }\n            }\n          }\n        }\n        return Buffer.concat(buffers);\n      }\n      readResult(reader) {\n        if (!isFunction) {\n          throw new Error(\"`readResult()` called for non-request instance\");\n        }\n        const m = result.match(/Vector<(int|long)>/);\n        if (m) {\n          reader.readInt();\n          const temp = [];\n          const len = reader.readInt();\n          if (m[1] === \"int\") {\n            for (let i = 0; i < len; i++) {\n              temp.push(reader.readInt());\n            }\n          } else {\n            for (let i = 0; i < len; i++) {\n              temp.push(reader.readLong());\n            }\n          }\n          return temp;\n        } else {\n          return reader.tgReadObject();\n        }\n      }\n      async resolve(client, utils) {\n        if (!isFunction) {\n          throw new Error(\"`resolve()` called for non-request instance\");\n        }\n        for (const arg in argsConfig) {\n          if (argsConfig.hasOwnProperty(arg)) {\n            if (!AUTO_CASTS.has(argsConfig[arg].type)) {\n              if (!NAMED_AUTO_CASTS.has(`${argsConfig[arg].name},${argsConfig[arg].type}`)) {\n                continue;\n              }\n            }\n            if (argsConfig[arg].isFlag) {\n              if (!this[arg]) {\n                continue;\n              }\n            }\n            if (argsConfig[arg].isVector) {\n              const temp = [];\n              for (const x of this[arg]) {\n                temp.push(await getInputFromResolve(utils, client, x, argsConfig[arg].type));\n              }\n              this[arg] = temp;\n            } else {\n              this[arg] = await getInputFromResolve(utils, client, this[arg], argsConfig[arg].type);\n            }\n          }\n        }\n      }\n      [inspect.custom]() {\n        return betterConsoleLog(this);\n      }\n      toJSON() {\n        return Object.assign(Object.assign({}, this.originalArgs), {\n          className: fullName\n        });\n      }\n    }\n    VirtualClass.CONSTRUCTOR_ID = constructorId;\n    VirtualClass.SUBCLASS_OF_ID = subclassOfId;\n    VirtualClass.className = fullName;\n    VirtualClass.classType = isFunction ? \"request\" : \"constructor\";\n    if (namespace) {\n      if (!classes[namespace]) {\n        classes[namespace] = {};\n      }\n      classes[namespace][name] = VirtualClass;\n    } else {\n      classes[name] = VirtualClass;\n    }\n  }\n  return classes;\n}\nconst api = buildApiFromTlSchema();\nmodule.exports = {\n  Api: api\n};","map":{"version":3,"names":["inspect","require","bigInt","generateRandomBytes","readBigIntFromBuffer","isArrayLike","betterConsoleLog","tlContent","schemeContent","generateRandomBigInt","parseTl","serializeBytes","serializeDate","toSignedLittleBuffer","NAMED_AUTO_CASTS","Set","NAMED_BLACKLIST","AUTO_CASTS","CastError","Error","constructor","objectName","expected","actual","params","message","captureStackTrace","name","CACHING_SUPPORTED","self","localStorage","undefined","CACHE_KEY","buildApiFromTlSchema","definitions","fromCache","loadFromCache","loadFromTlSchemas","setItem","JSON","stringify","createClasses","jsonCache","getItem","parse","constructorParamsApi","functionParamsApi","extractParams","constructorParamsSchema","functionParamsSchema","constructors","concat","requests","fileContent","f","functions","d","isFunction","push","argToBytes","x","type","argName","requestName","i","Buffer","alloc","writeInt32LE","writeDoubleLE","from","getBytes","getInputFromResolve","utils","client","peer","peerType","getInputPeer","getInputEntity","getInputChannel","getInputUser","_getInputDialog","_getInputNotify","getInputMedia","getInputPhoto","getInputMessage","getInputDocument","getInputChatPhoto","getPeerId","getArgFromReader","reader","arg","isVector","useVectorId","readInt","temp","len","flagIndicator","readLong","readLargeInt","readDouble","tgReadString","tgReadBool","tgReadBytes","tgReadDate","skipConstructorId","tgReadObject","api","fromReader","compareType","value","correct","isInstance","isBuffer","Object","prototype","toString","call","isNaN","console","error","classesType","classes","classParams","constructorId","subclassOfId","argsConfig","namespace","result","fullName","join","replace","VirtualClass","args","CONSTRUCTOR_ID","SUBCLASS_OF_ID","className","classType","originalArgs","init","rands","length","hasOwnProperty","isFlag","Boolean","flagName","flagIndex","validate","currentValue","assertType","object","o","assign","isCorrectType","e","idForBytes","c","writeUInt32LE","buffers","l","map","values","some","flagCalculate","boxed","charAt","indexOf","toUpperCase","shift","readResult","m","match","resolve","has","custom","toJSON","module","exports","Api"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/tl/api.js"],"sourcesContent":["\"use strict\";\nconst { inspect } = require(\"../inspect\");\nconst bigInt = require(\"big-integer\");\nconst { generateRandomBytes, readBigIntFromBuffer, isArrayLike, betterConsoleLog, } = require(\"../Helpers\");\nconst tlContent = require(\"./apiTl.js\");\nconst schemeContent = require(\"./schemaTl.js\");\nfunction generateRandomBigInt() {\n    return readBigIntFromBuffer(generateRandomBytes(8), false, true);\n}\nconst { parseTl, serializeBytes, serializeDate, } = require(\"./generationHelpers\");\nconst { toSignedLittleBuffer } = require(\"../Helpers\");\nconst NAMED_AUTO_CASTS = new Set([\"chatId,int\"]);\nconst NAMED_BLACKLIST = new Set([\"discardEncryption\"]);\nconst AUTO_CASTS = new Set([\n    \"InputPeer\",\n    \"InputChannel\",\n    \"InputUser\",\n    \"InputDialogPeer\",\n    \"InputNotifyPeer\",\n    \"InputMedia\",\n    \"InputPhoto\",\n    \"InputMessage\",\n    \"InputDocument\",\n    \"InputChatPhoto\",\n]);\nclass CastError extends Error {\n    constructor(objectName, expected, actual, ...params) {\n        // Pass remaining arguments (including vendor specific ones) to parent constructor\n        const message = \"Found wrong type for \" +\n            objectName +\n            \". expected \" +\n            expected +\n            \" but received \" +\n            actual +\n            \".If you think this is a mistake please report it.\";\n        super(message, ...params);\n        // Maintains proper stack trace for where our error was thrown (only available on V8)\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, CastError);\n        }\n        this.name = \"CastError\";\n        // Custom debugging information\n    }\n}\nconst CACHING_SUPPORTED = typeof self !== \"undefined\" && self.localStorage !== undefined;\nconst CACHE_KEY = \"GramJs:apiCache\";\nfunction buildApiFromTlSchema() {\n    let definitions;\n    const fromCache = CACHING_SUPPORTED && loadFromCache();\n    if (fromCache) {\n        definitions = fromCache;\n    }\n    else {\n        definitions = loadFromTlSchemas();\n        if (CACHING_SUPPORTED) {\n            localStorage.setItem(CACHE_KEY, JSON.stringify(definitions));\n        }\n    }\n    return createClasses(\"all\", definitions);\n}\nfunction loadFromCache() {\n    const jsonCache = localStorage.getItem(CACHE_KEY);\n    return jsonCache && JSON.parse(jsonCache);\n}\nfunction loadFromTlSchemas() {\n    const [constructorParamsApi, functionParamsApi] = extractParams(tlContent);\n    const [constructorParamsSchema, functionParamsSchema] = extractParams(schemeContent);\n    const constructors = [].concat(constructorParamsApi, constructorParamsSchema);\n    const requests = [].concat(functionParamsApi, functionParamsSchema);\n    return [].concat(constructors, requests);\n}\nfunction extractParams(fileContent) {\n    const f = parseTl(fileContent, 109);\n    const constructors = [];\n    const functions = [];\n    for (const d of f) {\n        d.isFunction ? functions.push(d) : constructors.push(d);\n    }\n    return [constructors, functions];\n}\nfunction argToBytes(x, type, argName, requestName) {\n    switch (type) {\n        case \"int\":\n            const i = Buffer.alloc(4);\n            i.writeInt32LE(x, 0);\n            return i;\n        case \"long\":\n            return toSignedLittleBuffer(x, 8);\n        case \"int128\":\n            return toSignedLittleBuffer(x, 16);\n        case \"int256\":\n            return toSignedLittleBuffer(x, 32);\n        case \"double\":\n            const d = Buffer.alloc(8);\n            d.writeDoubleLE(x, 0);\n            return d;\n        case \"string\":\n            return serializeBytes(x);\n        case \"Bool\":\n            return x\n                ? Buffer.from(\"b5757299\", \"hex\")\n                : Buffer.from(\"379779bc\", \"hex\");\n        case \"true\":\n            return Buffer.alloc(0);\n        case \"bytes\":\n            return serializeBytes(x);\n        case \"date\":\n            return serializeDate(x);\n        default:\n            if (x === undefined || typeof x.getBytes !== \"function\") {\n                throw new Error(`Required object ${argName} of ${requestName} is undefined`);\n            }\n            return x.getBytes();\n    }\n}\nasync function getInputFromResolve(utils, client, peer, peerType) {\n    switch (peerType) {\n        case \"InputPeer\":\n            return utils.getInputPeer(await client.getInputEntity(peer));\n        case \"InputChannel\":\n            return utils.getInputChannel(await client.getInputEntity(peer));\n        case \"InputUser\":\n            return utils.getInputUser(await client.getInputEntity(peer));\n        case \"InputDialogPeer\":\n            return await client._getInputDialog(peer);\n        case \"InputNotifyPeer\":\n            return await client._getInputNotify(peer);\n        case \"InputMedia\":\n            return utils.getInputMedia(peer);\n        case \"InputPhoto\":\n            return utils.getInputPhoto(peer);\n        case \"InputMessage\":\n            return utils.getInputMessage(peer);\n        case \"InputDocument\":\n            return utils.getInputDocument(peer);\n        case \"InputChatPhoto\":\n            return utils.getInputChatPhoto(peer);\n        case \"chatId,int\":\n            return await client.getPeerId(peer, false);\n        default:\n            throw new Error(\"unsupported peer type : \" + peerType);\n    }\n}\nfunction getArgFromReader(reader, arg) {\n    if (arg.isVector) {\n        if (arg.useVectorId) {\n            reader.readInt();\n        }\n        const temp = [];\n        const len = reader.readInt();\n        arg.isVector = false;\n        for (let i = 0; i < len; i++) {\n            temp.push(getArgFromReader(reader, arg));\n        }\n        arg.isVector = true;\n        return temp;\n    }\n    else if (arg.flagIndicator) {\n        return reader.readInt();\n    }\n    else {\n        switch (arg.type) {\n            case \"int\":\n                return reader.readInt();\n            case \"long\":\n                return reader.readLong();\n            case \"int128\":\n                return reader.readLargeInt(128);\n            case \"int256\":\n                return reader.readLargeInt(256);\n            case \"double\":\n                return reader.readDouble();\n            case \"string\":\n                return reader.tgReadString();\n            case \"Bool\":\n                return reader.tgReadBool();\n            case \"true\":\n                return true;\n            case \"bytes\":\n                return reader.tgReadBytes();\n            case \"date\":\n                return reader.tgReadDate();\n            default:\n                if (!arg.skipConstructorId) {\n                    return reader.tgReadObject();\n                }\n                else {\n                    return api.constructors[arg.type].fromReader(reader);\n                }\n        }\n    }\n}\nfunction compareType(value, type) {\n    let correct = true;\n    switch (type) {\n        case \"number\":\n            correct = typeof value === \"number\" || value === undefined;\n            break;\n        case \"string\":\n        case \"boolean\":\n            correct = typeof value === type;\n            break;\n        case \"bigInt\":\n            correct =\n                bigInt.isInstance(value) ||\n                    typeof value === \"bigint\" ||\n                    typeof value === \"number\" ||\n                    typeof value === \"string\" ||\n                    value === undefined;\n            break;\n        case \"true\":\n            // true value is always correct\n            break;\n        case \"buffer\":\n            correct = Buffer.isBuffer(value);\n            break;\n        case \"date\":\n            correct =\n                (value &&\n                    Object.prototype.toString.call(value) === \"[object Date]\" &&\n                    !isNaN(value)) ||\n                    typeof value === \"number\";\n            break;\n        default:\n            console.error(new Error(\"Unknown type.\" + type));\n    }\n    return correct;\n}\nfunction createClasses(classesType, params) {\n    const classes = {};\n    for (const classParams of params) {\n        const { name, constructorId, subclassOfId, argsConfig, namespace, isFunction, result, } = classParams;\n        const fullName = [namespace, name].join(\".\").replace(/^\\./, \"\");\n        class VirtualClass {\n            constructor(args) {\n                this.CONSTRUCTOR_ID = constructorId;\n                this.SUBCLASS_OF_ID = subclassOfId;\n                this.className = fullName;\n                this.classType = isFunction ? \"request\" : \"constructor\";\n                args = args || {};\n                this.originalArgs = args;\n                this.init(args);\n                for (const argName in argsConfig) {\n                    if (argName === \"randomId\" && !args[argName]) {\n                        if (argsConfig[argName].isVector) {\n                            const rands = [];\n                            for (let i = 0; i < args[\"id\"].length; i++) {\n                                rands.push(generateRandomBigInt());\n                            }\n                            this[argName] = rands;\n                        }\n                        else {\n                            this[argName] = generateRandomBigInt();\n                        }\n                    }\n                    else {\n                        this[argName] = args[argName];\n                    }\n                }\n            }\n            init(args) { }\n            static fromReader(reader) {\n                const args = {};\n                for (const argName in argsConfig) {\n                    if (argsConfig.hasOwnProperty(argName)) {\n                        const arg = argsConfig[argName];\n                        if (arg.isFlag) {\n                            if (arg.type === \"true\") {\n                                args[argName] = Boolean(args[arg.flagName] & (1 << arg.flagIndex));\n                                continue;\n                            }\n                            if (args[arg.flagName] & (1 << arg.flagIndex)) {\n                                args[argName] = getArgFromReader(reader, arg);\n                            }\n                            else {\n                                args[argName] = null;\n                            }\n                        }\n                        else {\n                            if (arg.flagIndicator) {\n                                arg.name = argName;\n                            }\n                            args[argName] = getArgFromReader(reader, arg);\n                        }\n                    }\n                }\n                return new this(args);\n            }\n            validate() {\n                for (const arg in argsConfig) {\n                    if (argsConfig.hasOwnProperty(arg)) {\n                        if (argsConfig[arg].flagIndicator ||\n                            argsConfig[arg].isFlag) {\n                            // we don't care about flags\n                            continue;\n                        }\n                        const currentValue = this[arg];\n                        this.assertType(arg, argsConfig[arg], currentValue);\n                    }\n                }\n            }\n            assertType(objectName, object, value) {\n                let expected;\n                if (object[\"isVector\"]) {\n                    if (!isArrayLike(value)) {\n                        console.error(new CastError(objectName, \"array\", value));\n                    }\n                    if (value == undefined) {\n                        value = [];\n                    }\n                    for (const o of value) {\n                        this.assertType(objectName, Object.assign(Object.assign({}, object), { isVector: false }), o);\n                    }\n                }\n                else {\n                    switch (object[\"type\"]) {\n                        case \"int\":\n                            expected = \"number\";\n                            break;\n                        case \"long\":\n                        case \"int128\":\n                        case \"int256\":\n                            expected = \"bigInt\";\n                            break;\n                        case \"double\":\n                            expected = \"number\";\n                            break;\n                        case \"string\":\n                            expected = \"string\";\n                            break;\n                        case \"Bool\":\n                            expected = \"boolean\";\n                            break;\n                        case \"true\":\n                            expected = \"true\";\n                            break;\n                        case \"bytes\":\n                            expected = \"buffer\";\n                            break;\n                        case \"date\":\n                            expected = \"date\";\n                            break;\n                        default:\n                            expected = \"object\";\n                    }\n                    if (expected === \"object\") {\n                        // will be validated in get byte();\n                    }\n                    else {\n                        const isCorrectType = compareType(value, expected);\n                        if (isCorrectType !== true) {\n                            console.error(new CastError(objectName, expected, value));\n                        }\n                    }\n                }\n            }\n            getBytes() {\n                try {\n                    this.validate();\n                }\n                catch (e) {\n                    // feature still in alpha so errors are expected.\n                }\n                const idForBytes = this.CONSTRUCTOR_ID;\n                const c = Buffer.alloc(4);\n                c.writeUInt32LE(idForBytes, 0);\n                const buffers = [c];\n                for (const arg in argsConfig) {\n                    if (argsConfig.hasOwnProperty(arg)) {\n                        if (argsConfig[arg].isFlag) {\n                            if ((this[arg] === false &&\n                                argsConfig[arg].type !== \"Bool\") ||\n                                this[arg] === null ||\n                                this[arg] === undefined ||\n                                argsConfig[arg].type === \"true\") {\n                                continue;\n                            }\n                        }\n                        if (argsConfig[arg].isVector) {\n                            if (argsConfig[arg].useVectorId) {\n                                buffers.push(Buffer.from(\"15c4b51c\", \"hex\"));\n                            }\n                            const l = Buffer.alloc(4);\n                            l.writeInt32LE(this[arg].length, 0);\n                            buffers.push(l, Buffer.concat(this[arg].map((x) => argToBytes(x, argsConfig[arg].type, fullName))));\n                        }\n                        else if (argsConfig[arg].flagIndicator) {\n                            if (!Object.values(argsConfig).some((f) => f.isFlag)) {\n                                buffers.push(Buffer.alloc(4));\n                            }\n                            else {\n                                let flagCalculate = 0;\n                                for (const f in argsConfig) {\n                                    if (argsConfig[f].isFlag &&\n                                        arg === argsConfig[f].flagName) {\n                                        if ((this[f] === false &&\n                                            argsConfig[f].type !==\n                                                \"Bool\") ||\n                                            this[f] === undefined ||\n                                            this[f] === null) {\n                                            flagCalculate |= 0;\n                                        }\n                                        else {\n                                            flagCalculate |=\n                                                1 << argsConfig[f].flagIndex;\n                                        }\n                                    }\n                                }\n                                const f = Buffer.alloc(4);\n                                f.writeUInt32LE(flagCalculate, 0);\n                                buffers.push(f);\n                            }\n                        }\n                        else {\n                            buffers.push(argToBytes(this[arg], argsConfig[arg].type, arg, fullName));\n                            if (this[arg] &&\n                                typeof this[arg].getBytes === \"function\") {\n                                let boxed = argsConfig[arg].type.charAt(argsConfig[arg].type.indexOf(\".\") + 1);\n                                boxed = boxed === boxed.toUpperCase();\n                                if (!boxed) {\n                                    buffers.shift();\n                                }\n                            }\n                        }\n                    }\n                }\n                return Buffer.concat(buffers);\n            }\n            readResult(reader) {\n                if (!isFunction) {\n                    throw new Error(\"`readResult()` called for non-request instance\");\n                }\n                const m = result.match(/Vector<(int|long)>/);\n                if (m) {\n                    reader.readInt();\n                    const temp = [];\n                    const len = reader.readInt();\n                    if (m[1] === \"int\") {\n                        for (let i = 0; i < len; i++) {\n                            temp.push(reader.readInt());\n                        }\n                    }\n                    else {\n                        for (let i = 0; i < len; i++) {\n                            temp.push(reader.readLong());\n                        }\n                    }\n                    return temp;\n                }\n                else {\n                    return reader.tgReadObject();\n                }\n            }\n            async resolve(client, utils) {\n                if (!isFunction) {\n                    throw new Error(\"`resolve()` called for non-request instance\");\n                }\n                for (const arg in argsConfig) {\n                    if (argsConfig.hasOwnProperty(arg)) {\n                        if (!AUTO_CASTS.has(argsConfig[arg].type)) {\n                            if (!NAMED_AUTO_CASTS.has(`${argsConfig[arg].name},${argsConfig[arg].type}`)) {\n                                continue;\n                            }\n                        }\n                        if (argsConfig[arg].isFlag) {\n                            if (!this[arg]) {\n                                continue;\n                            }\n                        }\n                        if (argsConfig[arg].isVector) {\n                            const temp = [];\n                            for (const x of this[arg]) {\n                                temp.push(await getInputFromResolve(utils, client, x, argsConfig[arg].type));\n                            }\n                            this[arg] = temp;\n                        }\n                        else {\n                            this[arg] = await getInputFromResolve(utils, client, this[arg], argsConfig[arg].type);\n                        }\n                    }\n                }\n            }\n            [inspect.custom]() {\n                return betterConsoleLog(this);\n            }\n            toJSON() {\n                return Object.assign(Object.assign({}, this.originalArgs), { className: fullName });\n            }\n        }\n        VirtualClass.CONSTRUCTOR_ID = constructorId;\n        VirtualClass.SUBCLASS_OF_ID = subclassOfId;\n        VirtualClass.className = fullName;\n        VirtualClass.classType = isFunction ? \"request\" : \"constructor\";\n        if (namespace) {\n            if (!classes[namespace]) {\n                classes[namespace] = {};\n            }\n            classes[namespace][name] = VirtualClass;\n        }\n        else {\n            classes[name] = VirtualClass;\n        }\n    }\n    return classes;\n}\nconst api = buildApiFromTlSchema();\nmodule.exports = { Api: api };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}