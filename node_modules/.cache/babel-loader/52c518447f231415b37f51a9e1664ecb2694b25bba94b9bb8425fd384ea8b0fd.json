{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CustomFile = void 0;\nexports.uploadFile = uploadFile;\nexports._fileToMedia = _fileToMedia;\nexports._sendAlbum = _sendAlbum;\nexports.sendFile = sendFile;\nconst tl_1 = require(\"../tl\");\nconst Helpers_1 = require(\"../Helpers\");\nconst Utils_1 = require(\"../Utils\");\nconst path_1 = __importDefault(require(\"./path\"));\nconst fs_1 = require(\"./fs\");\nconst index_1 = require(\"../index\");\nconst messageParse_1 = require(\"./messageParse\");\nconst messages_1 = require(\"./messages\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\n/**\n * A custom file class that mimics the browser's File class.<br/>\n * You should use this whenever you want to upload a file.\n */\nclass CustomFile {\n  constructor(name, size, path, buffer) {\n    this.name = name;\n    this.size = size;\n    this.path = path;\n    this.buffer = buffer;\n  }\n}\nexports.CustomFile = CustomFile;\nclass CustomBuffer {\n  constructor(options) {\n    this.options = options;\n    if (!options.buffer && !options.filePath) {\n      throw new Error(\"Either one of `buffer` or `filePath` should be specified\");\n    }\n  }\n  async slice(begin, end) {\n    const {\n      buffer,\n      filePath\n    } = this.options;\n    if (buffer) {\n      return buffer.slice(begin, end);\n    } else if (filePath) {\n      const buffSize = end - begin;\n      const buff = Buffer.alloc(buffSize);\n      const fHandle = await fs_1.promises.open(filePath, \"r\");\n      await fHandle.read(buff, 0, buffSize, begin);\n      await fHandle.close();\n      return Buffer.from(buff);\n    }\n    return Buffer.alloc(0);\n  }\n}\nconst KB_TO_BYTES = 1024;\nconst LARGE_FILE_THRESHOLD = 10 * 1024 * 1024;\nconst UPLOAD_TIMEOUT = 15 * 1000;\nconst DISCONNECT_SLEEP = 1000;\nconst BUFFER_SIZE_2GB = 2 ** 31;\nconst BUFFER_SIZE_20MB = 20 * 1024 * 1024;\nasync function getFileBuffer(file, fileSize, maxBufferSize) {\n  const options = {};\n  if (fileSize > maxBufferSize && file instanceof CustomFile) {\n    options.filePath = file.path;\n  } else {\n    options.buffer = Buffer.from(await fileToBuffer(file));\n  }\n  return new CustomBuffer(options);\n}\n/** @hidden */\nasync function uploadFile(client, fileParams) {\n  const {\n    file,\n    onProgress\n  } = fileParams;\n  let {\n    workers\n  } = fileParams;\n  const {\n    name,\n    size\n  } = file;\n  const fileId = (0, Helpers_1.readBigIntFromBuffer)((0, Helpers_1.generateRandomBytes)(8), true, true);\n  const isLarge = size > LARGE_FILE_THRESHOLD;\n  const partSize = (0, Utils_1.getAppropriatedPartSize)((0, big_integer_1.default)(size)) * KB_TO_BYTES;\n  const partCount = Math.floor((size + partSize - 1) / partSize);\n  const buffer = await getFileBuffer(file, size, fileParams.maxBufferSize || BUFFER_SIZE_20MB - 1);\n  // Make sure a new sender can be created before starting upload\n  await client.getSender(client.session.dcId);\n  if (!workers || !size) {\n    workers = 1;\n  }\n  if (workers >= partCount) {\n    workers = partCount;\n  }\n  let progress = 0;\n  if (onProgress) {\n    onProgress(progress);\n  }\n  for (let i = 0; i < partCount; i += workers) {\n    const sendingParts = [];\n    let end = i + workers;\n    if (end > partCount) {\n      end = partCount;\n    }\n    for (let j = i; j < end; j++) {\n      let endPart = (j + 1) * partSize;\n      if (endPart > size) {\n        endPart = size;\n      }\n      if (endPart == j * partSize) {\n        break;\n      }\n      const bytes = await buffer.slice(j * partSize, endPart);\n      // eslint-disable-next-line no-loop-func\n      sendingParts.push((async (jMemo, bytesMemo) => {\n        while (true) {\n          let sender;\n          try {\n            // We always upload from the DC we are in\n            sender = await client.getSender(client.session.dcId);\n            await sender.send(isLarge ? new tl_1.Api.upload.SaveBigFilePart({\n              fileId,\n              filePart: jMemo,\n              fileTotalParts: partCount,\n              bytes: bytesMemo\n            }) : new tl_1.Api.upload.SaveFilePart({\n              fileId,\n              filePart: jMemo,\n              bytes: bytesMemo\n            }));\n          } catch (err) {\n            if (sender && !sender.isConnected()) {\n              await (0, Helpers_1.sleep)(DISCONNECT_SLEEP);\n              continue;\n            } else if (err instanceof index_1.errors.FloodWaitError) {\n              await (0, Helpers_1.sleep)(err.seconds * 1000);\n              continue;\n            }\n            throw err;\n          }\n          if (onProgress) {\n            if (onProgress.isCanceled) {\n              throw new Error(\"USER_CANCELED\");\n            }\n            progress += 1 / partCount;\n            onProgress(progress);\n          }\n          break;\n        }\n      })(j, bytes));\n    }\n    await Promise.all(sendingParts);\n  }\n  return isLarge ? new tl_1.Api.InputFileBig({\n    id: fileId,\n    parts: partCount,\n    name\n  }) : new tl_1.Api.InputFile({\n    id: fileId,\n    parts: partCount,\n    name,\n    md5Checksum: \"\" // This is not a \"flag\", so not sure if we can make it optional.\n  });\n}\n/** @hidden */\nasync function _fileToMedia(client, {\n  file,\n  forceDocument,\n  fileSize,\n  progressCallback,\n  attributes,\n  thumb,\n  voiceNote = false,\n  videoNote = false,\n  supportsStreaming = false,\n  mimeType,\n  asImage,\n  workers = 1\n}) {\n  if (!file) {\n    return {\n      fileHandle: undefined,\n      media: undefined,\n      image: undefined\n    };\n  }\n  const isImage = index_1.utils.isImage(file);\n  if (asImage == undefined) {\n    asImage = isImage && !forceDocument;\n  }\n  if (typeof file == \"object\" && !Buffer.isBuffer(file) && !(file instanceof tl_1.Api.InputFile) && !(file instanceof tl_1.Api.InputFileBig) && !(file instanceof CustomFile) && !(\"read\" in file)) {\n    try {\n      return {\n        fileHandle: undefined,\n        media: index_1.utils.getInputMedia(file, {\n          isPhoto: asImage,\n          attributes: attributes,\n          forceDocument: forceDocument,\n          voiceNote: voiceNote,\n          videoNote: videoNote,\n          supportsStreaming: supportsStreaming\n        }),\n        image: asImage\n      };\n    } catch (e) {\n      return {\n        fileHandle: undefined,\n        media: undefined,\n        image: isImage\n      };\n    }\n  }\n  let media;\n  let fileHandle;\n  let createdFile;\n  if (file instanceof tl_1.Api.InputFile || file instanceof tl_1.Api.InputFileBig) {\n    fileHandle = file;\n  } else if (typeof file == \"string\" && (file.startsWith(\"https://\") || file.startsWith(\"http://\"))) {\n    if (asImage) {\n      media = new tl_1.Api.InputMediaPhotoExternal({\n        url: file\n      });\n    } else {\n      media = new tl_1.Api.InputMediaDocumentExternal({\n        url: file\n      });\n    }\n  } else if (!(typeof file == \"string\") || (await fs_1.promises.lstat(file)).isFile()) {\n    if (typeof file == \"string\") {\n      createdFile = new CustomFile(path_1.default.basename(file), (await fs_1.promises.stat(file)).size, file);\n    } else if (typeof File !== \"undefined\" && file instanceof File || file instanceof CustomFile) {\n      createdFile = file;\n    } else {\n      let name;\n      if (\"name\" in file) {\n        // @ts-ignore\n        name = file.name;\n      } else {\n        name = \"unnamed\";\n      }\n      if (Buffer.isBuffer(file)) {\n        createdFile = new CustomFile(name, file.length, \"\", file);\n      }\n    }\n    if (!createdFile) {\n      throw new Error(`Could not create file from ${JSON.stringify(file)}`);\n    }\n    fileHandle = await uploadFile(client, {\n      file: createdFile,\n      onProgress: progressCallback,\n      workers: workers\n    });\n  } else {\n    throw new Error(`\"Not a valid path nor a url ${file}`);\n  }\n  if (media != undefined) {} else if (fileHandle == undefined) {\n    throw new Error(`Failed to convert ${file} to media. Not an existing file or an HTTP URL`);\n  } else if (asImage) {\n    media = new tl_1.Api.InputMediaUploadedPhoto({\n      file: fileHandle\n    });\n  } else {\n    // @ts-ignore\n    let res = index_1.utils.getAttributes(file, {\n      mimeType: mimeType,\n      attributes: attributes,\n      forceDocument: forceDocument && !isImage,\n      voiceNote: voiceNote,\n      videoNote: videoNote,\n      supportsStreaming: supportsStreaming,\n      thumb: thumb\n    });\n    attributes = res.attrs;\n    mimeType = res.mimeType;\n    let uploadedThumb;\n    if (!thumb) {\n      uploadedThumb = undefined;\n    } else {\n      // todo refactor\n      if (typeof thumb == \"string\") {\n        uploadedThumb = new CustomFile(path_1.default.basename(thumb), (await fs_1.promises.stat(thumb)).size, thumb);\n      } else if (typeof File !== \"undefined\" && thumb instanceof File) {\n        uploadedThumb = thumb;\n      } else {\n        let name;\n        if (\"name\" in thumb) {\n          name = thumb.name;\n        } else {\n          name = \"unnamed\";\n        }\n        if (Buffer.isBuffer(thumb)) {\n          uploadedThumb = new CustomFile(name, thumb.length, \"\", thumb);\n        }\n      }\n      if (!uploadedThumb) {\n        throw new Error(`Could not create file from ${file}`);\n      }\n      uploadedThumb = await uploadFile(client, {\n        file: uploadedThumb,\n        workers: 1\n      });\n    }\n    media = new tl_1.Api.InputMediaUploadedDocument({\n      file: fileHandle,\n      mimeType: mimeType,\n      attributes: attributes,\n      thumb: uploadedThumb,\n      forceFile: forceDocument && !isImage\n    });\n  }\n  return {\n    fileHandle: fileHandle,\n    media: media,\n    image: asImage\n  };\n}\n/** @hidden */\nasync function _sendAlbum(client, entity, {\n  file,\n  caption,\n  forceDocument = false,\n  fileSize,\n  clearDraft = false,\n  progressCallback,\n  replyTo,\n  attributes,\n  thumb,\n  parseMode,\n  voiceNote = false,\n  videoNote = false,\n  silent,\n  supportsStreaming = false,\n  scheduleDate,\n  workers = 1,\n  noforwards,\n  commentTo,\n  topMsgId\n}) {\n  entity = await client.getInputEntity(entity);\n  let files = [];\n  if (!Array.isArray(file)) {\n    files = [file];\n  } else {\n    files = file;\n  }\n  if (!Array.isArray(caption)) {\n    if (!caption) {\n      caption = \"\";\n    }\n    caption = [caption];\n  }\n  const captions = [];\n  for (const c of caption) {\n    captions.push(await (0, messageParse_1._parseMessageText)(client, c, parseMode));\n  }\n  if (commentTo != undefined) {\n    const discussionData = await (0, messages_1.getCommentData)(client, entity, commentTo);\n    entity = discussionData.entity;\n    replyTo = discussionData.replyTo;\n  } else {\n    replyTo = index_1.utils.getMessageId(replyTo);\n  }\n  if (!attributes) {\n    attributes = [];\n  }\n  let index = 0;\n  const albumFiles = [];\n  for (const file of files) {\n    let {\n      fileHandle,\n      media,\n      image\n    } = await _fileToMedia(client, {\n      file: file,\n      forceDocument: forceDocument,\n      fileSize: fileSize,\n      progressCallback: progressCallback,\n      // @ts-ignore\n      attributes: attributes[index],\n      thumb: thumb,\n      voiceNote: voiceNote,\n      videoNote: videoNote,\n      supportsStreaming: supportsStreaming,\n      workers: workers\n    });\n    index++;\n    if (media instanceof tl_1.Api.InputMediaUploadedPhoto || media instanceof tl_1.Api.InputMediaPhotoExternal) {\n      const r = await client.invoke(new tl_1.Api.messages.UploadMedia({\n        peer: entity,\n        media\n      }));\n      if (r instanceof tl_1.Api.MessageMediaPhoto) {\n        media = (0, Utils_1.getInputMedia)(r.photo);\n      }\n    } else if (media instanceof tl_1.Api.InputMediaUploadedDocument) {\n      const r = await client.invoke(new tl_1.Api.messages.UploadMedia({\n        peer: entity,\n        media\n      }));\n      if (r instanceof tl_1.Api.MessageMediaDocument) {\n        media = (0, Utils_1.getInputMedia)(r.document);\n      }\n    }\n    let text = \"\";\n    let msgEntities = [];\n    if (captions.length) {\n      [text, msgEntities] = captions.shift();\n    }\n    albumFiles.push(new tl_1.Api.InputSingleMedia({\n      media: media,\n      message: text,\n      entities: msgEntities\n    }));\n  }\n  let replyObject = undefined;\n  if (replyTo != undefined) {\n    replyObject = new tl_1.Api.InputReplyToMessage({\n      replyToMsgId: (0, Utils_1.getMessageId)(replyTo),\n      topMsgId: (0, Utils_1.getMessageId)(topMsgId)\n    });\n  }\n  const result = await client.invoke(new tl_1.Api.messages.SendMultiMedia({\n    peer: entity,\n    replyTo: replyObject,\n    multiMedia: albumFiles,\n    silent: silent,\n    scheduleDate: scheduleDate,\n    clearDraft: clearDraft,\n    noforwards: noforwards\n  }));\n  const randomIds = albumFiles.map(m => m.randomId);\n  return client._getResponseMessage(randomIds, result, entity);\n}\n/** @hidden */\nasync function sendFile(client, entity, {\n  file,\n  caption,\n  forceDocument = false,\n  fileSize,\n  clearDraft = false,\n  progressCallback,\n  replyTo,\n  attributes,\n  thumb,\n  parseMode,\n  formattingEntities,\n  voiceNote = false,\n  videoNote = false,\n  buttons,\n  silent,\n  supportsStreaming = false,\n  scheduleDate,\n  workers = 1,\n  noforwards,\n  commentTo,\n  topMsgId\n}) {\n  if (!file) {\n    throw new Error(\"You need to specify a file\");\n  }\n  if (!caption) {\n    caption = \"\";\n  }\n  entity = await client.getInputEntity(entity);\n  if (commentTo != undefined) {\n    const discussionData = await (0, messages_1.getCommentData)(client, entity, commentTo);\n    entity = discussionData.entity;\n    replyTo = discussionData.replyTo;\n  } else {\n    replyTo = index_1.utils.getMessageId(replyTo);\n  }\n  if (Array.isArray(file)) {\n    return await _sendAlbum(client, entity, {\n      file: file,\n      caption: caption,\n      replyTo: replyTo,\n      parseMode: parseMode,\n      attributes: attributes,\n      silent: silent,\n      scheduleDate: scheduleDate,\n      supportsStreaming: supportsStreaming,\n      clearDraft: clearDraft,\n      forceDocument: forceDocument,\n      noforwards: noforwards,\n      topMsgId: topMsgId\n    });\n  }\n  if (Array.isArray(caption)) {\n    caption = caption[0] || \"\";\n  }\n  let msgEntities;\n  if (formattingEntities != undefined) {\n    msgEntities = formattingEntities;\n  } else {\n    [caption, msgEntities] = await (0, messageParse_1._parseMessageText)(client, caption, parseMode);\n  }\n  const {\n    fileHandle,\n    media,\n    image\n  } = await _fileToMedia(client, {\n    file: file,\n    forceDocument: forceDocument,\n    fileSize: fileSize,\n    progressCallback: progressCallback,\n    // @ts-ignore\n    attributes: attributes,\n    thumb: thumb,\n    voiceNote: voiceNote,\n    videoNote: videoNote,\n    supportsStreaming: supportsStreaming,\n    workers: workers\n  });\n  if (media == undefined) {\n    throw new Error(`Cannot use ${file} as file.`);\n  }\n  const markup = client.buildReplyMarkup(buttons);\n  let replyObject = undefined;\n  if (replyTo != undefined) {\n    replyObject = new tl_1.Api.InputReplyToMessage({\n      replyToMsgId: (0, Utils_1.getMessageId)(replyTo),\n      topMsgId: (0, Utils_1.getMessageId)(topMsgId)\n    });\n  }\n  const request = new tl_1.Api.messages.SendMedia({\n    peer: entity,\n    media: media,\n    replyTo: replyObject,\n    message: caption,\n    entities: msgEntities,\n    replyMarkup: markup,\n    silent: silent,\n    scheduleDate: scheduleDate,\n    clearDraft: clearDraft,\n    noforwards: noforwards\n  });\n  const result = await client.invoke(request);\n  return client._getResponseMessage(request, result, entity);\n}\nfunction fileToBuffer(file) {\n  if (typeof File !== \"undefined\" && file instanceof File) {\n    return new Response(file).arrayBuffer();\n  } else if (file instanceof CustomFile) {\n    if (file.buffer != undefined) {\n      return file.buffer;\n    } else {\n      return fs_1.promises.readFile(file.path);\n    }\n  } else {\n    throw new Error(\"Could not create buffer from file \" + file);\n  }\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","CustomFile","uploadFile","_fileToMedia","_sendAlbum","sendFile","tl_1","require","Helpers_1","Utils_1","path_1","fs_1","index_1","messageParse_1","messages_1","big_integer_1","constructor","name","size","path","buffer","CustomBuffer","options","filePath","Error","slice","begin","end","buffSize","buff","Buffer","alloc","fHandle","promises","open","read","close","from","KB_TO_BYTES","LARGE_FILE_THRESHOLD","UPLOAD_TIMEOUT","DISCONNECT_SLEEP","BUFFER_SIZE_2GB","BUFFER_SIZE_20MB","getFileBuffer","file","fileSize","maxBufferSize","fileToBuffer","client","fileParams","onProgress","workers","fileId","readBigIntFromBuffer","generateRandomBytes","isLarge","partSize","getAppropriatedPartSize","default","partCount","Math","floor","getSender","session","dcId","progress","i","sendingParts","j","endPart","bytes","push","jMemo","bytesMemo","sender","send","Api","upload","SaveBigFilePart","filePart","fileTotalParts","SaveFilePart","err","isConnected","sleep","errors","FloodWaitError","seconds","isCanceled","Promise","all","InputFileBig","id","parts","InputFile","md5Checksum","forceDocument","progressCallback","attributes","thumb","voiceNote","videoNote","supportsStreaming","mimeType","asImage","fileHandle","undefined","media","image","isImage","utils","isBuffer","getInputMedia","isPhoto","e","createdFile","startsWith","InputMediaPhotoExternal","url","InputMediaDocumentExternal","lstat","isFile","basename","stat","File","length","JSON","stringify","InputMediaUploadedPhoto","res","getAttributes","attrs","uploadedThumb","InputMediaUploadedDocument","forceFile","entity","caption","clearDraft","replyTo","parseMode","silent","scheduleDate","noforwards","commentTo","topMsgId","getInputEntity","files","Array","isArray","captions","c","_parseMessageText","discussionData","getCommentData","getMessageId","index","albumFiles","r","invoke","messages","UploadMedia","peer","MessageMediaPhoto","photo","MessageMediaDocument","document","text","msgEntities","shift","InputSingleMedia","message","entities","replyObject","InputReplyToMessage","replyToMsgId","result","SendMultiMedia","multiMedia","randomIds","map","m","randomId","_getResponseMessage","formattingEntities","buttons","markup","buildReplyMarkup","request","SendMedia","replyMarkup","Response","arrayBuffer","readFile"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/client/uploads.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CustomFile = void 0;\nexports.uploadFile = uploadFile;\nexports._fileToMedia = _fileToMedia;\nexports._sendAlbum = _sendAlbum;\nexports.sendFile = sendFile;\nconst tl_1 = require(\"../tl\");\nconst Helpers_1 = require(\"../Helpers\");\nconst Utils_1 = require(\"../Utils\");\nconst path_1 = __importDefault(require(\"./path\"));\nconst fs_1 = require(\"./fs\");\nconst index_1 = require(\"../index\");\nconst messageParse_1 = require(\"./messageParse\");\nconst messages_1 = require(\"./messages\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\n/**\n * A custom file class that mimics the browser's File class.<br/>\n * You should use this whenever you want to upload a file.\n */\nclass CustomFile {\n    constructor(name, size, path, buffer) {\n        this.name = name;\n        this.size = size;\n        this.path = path;\n        this.buffer = buffer;\n    }\n}\nexports.CustomFile = CustomFile;\nclass CustomBuffer {\n    constructor(options) {\n        this.options = options;\n        if (!options.buffer && !options.filePath) {\n            throw new Error(\"Either one of `buffer` or `filePath` should be specified\");\n        }\n    }\n    async slice(begin, end) {\n        const { buffer, filePath } = this.options;\n        if (buffer) {\n            return buffer.slice(begin, end);\n        }\n        else if (filePath) {\n            const buffSize = end - begin;\n            const buff = Buffer.alloc(buffSize);\n            const fHandle = await fs_1.promises.open(filePath, \"r\");\n            await fHandle.read(buff, 0, buffSize, begin);\n            await fHandle.close();\n            return Buffer.from(buff);\n        }\n        return Buffer.alloc(0);\n    }\n}\nconst KB_TO_BYTES = 1024;\nconst LARGE_FILE_THRESHOLD = 10 * 1024 * 1024;\nconst UPLOAD_TIMEOUT = 15 * 1000;\nconst DISCONNECT_SLEEP = 1000;\nconst BUFFER_SIZE_2GB = 2 ** 31;\nconst BUFFER_SIZE_20MB = 20 * 1024 * 1024;\nasync function getFileBuffer(file, fileSize, maxBufferSize) {\n    const options = {};\n    if (fileSize > maxBufferSize && file instanceof CustomFile) {\n        options.filePath = file.path;\n    }\n    else {\n        options.buffer = Buffer.from(await fileToBuffer(file));\n    }\n    return new CustomBuffer(options);\n}\n/** @hidden */\nasync function uploadFile(client, fileParams) {\n    const { file, onProgress } = fileParams;\n    let { workers } = fileParams;\n    const { name, size } = file;\n    const fileId = (0, Helpers_1.readBigIntFromBuffer)((0, Helpers_1.generateRandomBytes)(8), true, true);\n    const isLarge = size > LARGE_FILE_THRESHOLD;\n    const partSize = (0, Utils_1.getAppropriatedPartSize)((0, big_integer_1.default)(size)) * KB_TO_BYTES;\n    const partCount = Math.floor((size + partSize - 1) / partSize);\n    const buffer = await getFileBuffer(file, size, fileParams.maxBufferSize || BUFFER_SIZE_20MB - 1);\n    // Make sure a new sender can be created before starting upload\n    await client.getSender(client.session.dcId);\n    if (!workers || !size) {\n        workers = 1;\n    }\n    if (workers >= partCount) {\n        workers = partCount;\n    }\n    let progress = 0;\n    if (onProgress) {\n        onProgress(progress);\n    }\n    for (let i = 0; i < partCount; i += workers) {\n        const sendingParts = [];\n        let end = i + workers;\n        if (end > partCount) {\n            end = partCount;\n        }\n        for (let j = i; j < end; j++) {\n            let endPart = (j + 1) * partSize;\n            if (endPart > size) {\n                endPart = size;\n            }\n            if (endPart == j * partSize) {\n                break;\n            }\n            const bytes = await buffer.slice(j * partSize, endPart);\n            // eslint-disable-next-line no-loop-func\n            sendingParts.push((async (jMemo, bytesMemo) => {\n                while (true) {\n                    let sender;\n                    try {\n                        // We always upload from the DC we are in\n                        sender = await client.getSender(client.session.dcId);\n                        await sender.send(isLarge\n                            ? new tl_1.Api.upload.SaveBigFilePart({\n                                fileId,\n                                filePart: jMemo,\n                                fileTotalParts: partCount,\n                                bytes: bytesMemo,\n                            })\n                            : new tl_1.Api.upload.SaveFilePart({\n                                fileId,\n                                filePart: jMemo,\n                                bytes: bytesMemo,\n                            }));\n                    }\n                    catch (err) {\n                        if (sender && !sender.isConnected()) {\n                            await (0, Helpers_1.sleep)(DISCONNECT_SLEEP);\n                            continue;\n                        }\n                        else if (err instanceof index_1.errors.FloodWaitError) {\n                            await (0, Helpers_1.sleep)(err.seconds * 1000);\n                            continue;\n                        }\n                        throw err;\n                    }\n                    if (onProgress) {\n                        if (onProgress.isCanceled) {\n                            throw new Error(\"USER_CANCELED\");\n                        }\n                        progress += 1 / partCount;\n                        onProgress(progress);\n                    }\n                    break;\n                }\n            })(j, bytes));\n        }\n        await Promise.all(sendingParts);\n    }\n    return isLarge\n        ? new tl_1.Api.InputFileBig({\n            id: fileId,\n            parts: partCount,\n            name,\n        })\n        : new tl_1.Api.InputFile({\n            id: fileId,\n            parts: partCount,\n            name,\n            md5Checksum: \"\", // This is not a \"flag\", so not sure if we can make it optional.\n        });\n}\n/** @hidden */\nasync function _fileToMedia(client, { file, forceDocument, fileSize, progressCallback, attributes, thumb, voiceNote = false, videoNote = false, supportsStreaming = false, mimeType, asImage, workers = 1, }) {\n    if (!file) {\n        return { fileHandle: undefined, media: undefined, image: undefined };\n    }\n    const isImage = index_1.utils.isImage(file);\n    if (asImage == undefined) {\n        asImage = isImage && !forceDocument;\n    }\n    if (typeof file == \"object\" &&\n        !Buffer.isBuffer(file) &&\n        !(file instanceof tl_1.Api.InputFile) &&\n        !(file instanceof tl_1.Api.InputFileBig) &&\n        !(file instanceof CustomFile) &&\n        !(\"read\" in file)) {\n        try {\n            return {\n                fileHandle: undefined,\n                media: index_1.utils.getInputMedia(file, {\n                    isPhoto: asImage,\n                    attributes: attributes,\n                    forceDocument: forceDocument,\n                    voiceNote: voiceNote,\n                    videoNote: videoNote,\n                    supportsStreaming: supportsStreaming,\n                }),\n                image: asImage,\n            };\n        }\n        catch (e) {\n            return {\n                fileHandle: undefined,\n                media: undefined,\n                image: isImage,\n            };\n        }\n    }\n    let media;\n    let fileHandle;\n    let createdFile;\n    if (file instanceof tl_1.Api.InputFile || file instanceof tl_1.Api.InputFileBig) {\n        fileHandle = file;\n    }\n    else if (typeof file == \"string\" &&\n        (file.startsWith(\"https://\") || file.startsWith(\"http://\"))) {\n        if (asImage) {\n            media = new tl_1.Api.InputMediaPhotoExternal({ url: file });\n        }\n        else {\n            media = new tl_1.Api.InputMediaDocumentExternal({ url: file });\n        }\n    }\n    else if (!(typeof file == \"string\") || (await fs_1.promises.lstat(file)).isFile()) {\n        if (typeof file == \"string\") {\n            createdFile = new CustomFile(path_1.default.basename(file), (await fs_1.promises.stat(file)).size, file);\n        }\n        else if ((typeof File !== \"undefined\" && file instanceof File) ||\n            file instanceof CustomFile) {\n            createdFile = file;\n        }\n        else {\n            let name;\n            if (\"name\" in file) {\n                // @ts-ignore\n                name = file.name;\n            }\n            else {\n                name = \"unnamed\";\n            }\n            if (Buffer.isBuffer(file)) {\n                createdFile = new CustomFile(name, file.length, \"\", file);\n            }\n        }\n        if (!createdFile) {\n            throw new Error(`Could not create file from ${JSON.stringify(file)}`);\n        }\n        fileHandle = await uploadFile(client, {\n            file: createdFile,\n            onProgress: progressCallback,\n            workers: workers,\n        });\n    }\n    else {\n        throw new Error(`\"Not a valid path nor a url ${file}`);\n    }\n    if (media != undefined) {\n    }\n    else if (fileHandle == undefined) {\n        throw new Error(`Failed to convert ${file} to media. Not an existing file or an HTTP URL`);\n    }\n    else if (asImage) {\n        media = new tl_1.Api.InputMediaUploadedPhoto({\n            file: fileHandle,\n        });\n    }\n    else {\n        // @ts-ignore\n        let res = index_1.utils.getAttributes(file, {\n            mimeType: mimeType,\n            attributes: attributes,\n            forceDocument: forceDocument && !isImage,\n            voiceNote: voiceNote,\n            videoNote: videoNote,\n            supportsStreaming: supportsStreaming,\n            thumb: thumb,\n        });\n        attributes = res.attrs;\n        mimeType = res.mimeType;\n        let uploadedThumb;\n        if (!thumb) {\n            uploadedThumb = undefined;\n        }\n        else {\n            // todo refactor\n            if (typeof thumb == \"string\") {\n                uploadedThumb = new CustomFile(path_1.default.basename(thumb), (await fs_1.promises.stat(thumb)).size, thumb);\n            }\n            else if (typeof File !== \"undefined\" && thumb instanceof File) {\n                uploadedThumb = thumb;\n            }\n            else {\n                let name;\n                if (\"name\" in thumb) {\n                    name = thumb.name;\n                }\n                else {\n                    name = \"unnamed\";\n                }\n                if (Buffer.isBuffer(thumb)) {\n                    uploadedThumb = new CustomFile(name, thumb.length, \"\", thumb);\n                }\n            }\n            if (!uploadedThumb) {\n                throw new Error(`Could not create file from ${file}`);\n            }\n            uploadedThumb = await uploadFile(client, {\n                file: uploadedThumb,\n                workers: 1,\n            });\n        }\n        media = new tl_1.Api.InputMediaUploadedDocument({\n            file: fileHandle,\n            mimeType: mimeType,\n            attributes: attributes,\n            thumb: uploadedThumb,\n            forceFile: forceDocument && !isImage,\n        });\n    }\n    return {\n        fileHandle: fileHandle,\n        media: media,\n        image: asImage,\n    };\n}\n/** @hidden */\nasync function _sendAlbum(client, entity, { file, caption, forceDocument = false, fileSize, clearDraft = false, progressCallback, replyTo, attributes, thumb, parseMode, voiceNote = false, videoNote = false, silent, supportsStreaming = false, scheduleDate, workers = 1, noforwards, commentTo, topMsgId, }) {\n    entity = await client.getInputEntity(entity);\n    let files = [];\n    if (!Array.isArray(file)) {\n        files = [file];\n    }\n    else {\n        files = file;\n    }\n    if (!Array.isArray(caption)) {\n        if (!caption) {\n            caption = \"\";\n        }\n        caption = [caption];\n    }\n    const captions = [];\n    for (const c of caption) {\n        captions.push(await (0, messageParse_1._parseMessageText)(client, c, parseMode));\n    }\n    if (commentTo != undefined) {\n        const discussionData = await (0, messages_1.getCommentData)(client, entity, commentTo);\n        entity = discussionData.entity;\n        replyTo = discussionData.replyTo;\n    }\n    else {\n        replyTo = index_1.utils.getMessageId(replyTo);\n    }\n    if (!attributes) {\n        attributes = [];\n    }\n    let index = 0;\n    const albumFiles = [];\n    for (const file of files) {\n        let { fileHandle, media, image } = await _fileToMedia(client, {\n            file: file,\n            forceDocument: forceDocument,\n            fileSize: fileSize,\n            progressCallback: progressCallback,\n            // @ts-ignore\n            attributes: attributes[index],\n            thumb: thumb,\n            voiceNote: voiceNote,\n            videoNote: videoNote,\n            supportsStreaming: supportsStreaming,\n            workers: workers,\n        });\n        index++;\n        if (media instanceof tl_1.Api.InputMediaUploadedPhoto ||\n            media instanceof tl_1.Api.InputMediaPhotoExternal) {\n            const r = await client.invoke(new tl_1.Api.messages.UploadMedia({\n                peer: entity,\n                media,\n            }));\n            if (r instanceof tl_1.Api.MessageMediaPhoto) {\n                media = (0, Utils_1.getInputMedia)(r.photo);\n            }\n        }\n        else if (media instanceof tl_1.Api.InputMediaUploadedDocument) {\n            const r = await client.invoke(new tl_1.Api.messages.UploadMedia({\n                peer: entity,\n                media,\n            }));\n            if (r instanceof tl_1.Api.MessageMediaDocument) {\n                media = (0, Utils_1.getInputMedia)(r.document);\n            }\n        }\n        let text = \"\";\n        let msgEntities = [];\n        if (captions.length) {\n            [text, msgEntities] = captions.shift();\n        }\n        albumFiles.push(new tl_1.Api.InputSingleMedia({\n            media: media,\n            message: text,\n            entities: msgEntities,\n        }));\n    }\n    let replyObject = undefined;\n    if (replyTo != undefined) {\n        replyObject = new tl_1.Api.InputReplyToMessage({\n            replyToMsgId: (0, Utils_1.getMessageId)(replyTo),\n            topMsgId: (0, Utils_1.getMessageId)(topMsgId),\n        });\n    }\n    const result = await client.invoke(new tl_1.Api.messages.SendMultiMedia({\n        peer: entity,\n        replyTo: replyObject,\n        multiMedia: albumFiles,\n        silent: silent,\n        scheduleDate: scheduleDate,\n        clearDraft: clearDraft,\n        noforwards: noforwards,\n    }));\n    const randomIds = albumFiles.map((m) => m.randomId);\n    return client._getResponseMessage(randomIds, result, entity);\n}\n/** @hidden */\nasync function sendFile(client, entity, { file, caption, forceDocument = false, fileSize, clearDraft = false, progressCallback, replyTo, attributes, thumb, parseMode, formattingEntities, voiceNote = false, videoNote = false, buttons, silent, supportsStreaming = false, scheduleDate, workers = 1, noforwards, commentTo, topMsgId, }) {\n    if (!file) {\n        throw new Error(\"You need to specify a file\");\n    }\n    if (!caption) {\n        caption = \"\";\n    }\n    entity = await client.getInputEntity(entity);\n    if (commentTo != undefined) {\n        const discussionData = await (0, messages_1.getCommentData)(client, entity, commentTo);\n        entity = discussionData.entity;\n        replyTo = discussionData.replyTo;\n    }\n    else {\n        replyTo = index_1.utils.getMessageId(replyTo);\n    }\n    if (Array.isArray(file)) {\n        return await _sendAlbum(client, entity, {\n            file: file,\n            caption: caption,\n            replyTo: replyTo,\n            parseMode: parseMode,\n            attributes: attributes,\n            silent: silent,\n            scheduleDate: scheduleDate,\n            supportsStreaming: supportsStreaming,\n            clearDraft: clearDraft,\n            forceDocument: forceDocument,\n            noforwards: noforwards,\n            topMsgId: topMsgId,\n        });\n    }\n    if (Array.isArray(caption)) {\n        caption = caption[0] || \"\";\n    }\n    let msgEntities;\n    if (formattingEntities != undefined) {\n        msgEntities = formattingEntities;\n    }\n    else {\n        [caption, msgEntities] = await (0, messageParse_1._parseMessageText)(client, caption, parseMode);\n    }\n    const { fileHandle, media, image } = await _fileToMedia(client, {\n        file: file,\n        forceDocument: forceDocument,\n        fileSize: fileSize,\n        progressCallback: progressCallback,\n        // @ts-ignore\n        attributes: attributes,\n        thumb: thumb,\n        voiceNote: voiceNote,\n        videoNote: videoNote,\n        supportsStreaming: supportsStreaming,\n        workers: workers,\n    });\n    if (media == undefined) {\n        throw new Error(`Cannot use ${file} as file.`);\n    }\n    const markup = client.buildReplyMarkup(buttons);\n    let replyObject = undefined;\n    if (replyTo != undefined) {\n        replyObject = new tl_1.Api.InputReplyToMessage({\n            replyToMsgId: (0, Utils_1.getMessageId)(replyTo),\n            topMsgId: (0, Utils_1.getMessageId)(topMsgId),\n        });\n    }\n    const request = new tl_1.Api.messages.SendMedia({\n        peer: entity,\n        media: media,\n        replyTo: replyObject,\n        message: caption,\n        entities: msgEntities,\n        replyMarkup: markup,\n        silent: silent,\n        scheduleDate: scheduleDate,\n        clearDraft: clearDraft,\n        noforwards: noforwards,\n    });\n    const result = await client.invoke(request);\n    return client._getResponseMessage(request, result, entity);\n}\nfunction fileToBuffer(file) {\n    if (typeof File !== \"undefined\" && file instanceof File) {\n        return new Response(file).arrayBuffer();\n    }\n    else if (file instanceof CustomFile) {\n        if (file.buffer != undefined) {\n            return file.buffer;\n        }\n        else {\n            return fs_1.promises.readFile(file.path);\n        }\n    }\n    else {\n        throw new Error(\"Could not create buffer from file \" + file);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}