{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StringSession = void 0;\nconst Memory_1 = require(\"./Memory\");\nconst extensions_1 = require(\"../extensions\");\nconst AuthKey_1 = require(\"../crypto/AuthKey\");\nconst CURRENT_VERSION = \"1\";\nclass StringSession extends Memory_1.MemorySession {\n  /**\n   * This session file can be easily saved and loaded as a string. According\n   * to the initial design, it contains only the data that is necessary for\n   * successful connection and authentication, so takeout ID is not stored.\n    * It is thought to be used where you don't want to create any on-disk\n   * files but would still like to be able to save and load existing sessions\n   * by other means.\n    * You can use custom `encode` and `decode` functions, if present:\n    * `encode` definition must be ``function encode(value: Buffer) -> string:``.\n   * `decode` definition must be ``function decode(value: string) -> Buffer:``.\n   * @param session {string|null}\n   */\n  constructor(session) {\n    super();\n    if (session) {\n      if (session[0] !== CURRENT_VERSION) {\n        throw new Error(\"Not a valid string\");\n      }\n      session = session.slice(1);\n      const r = StringSession.decode(session);\n      const reader = new extensions_1.BinaryReader(r);\n      this._dcId = reader.read(1).readUInt8(0);\n      if (session.length == 352) {\n        // Telethon session\n        const ip_v4 = reader.read(4);\n        // TODO looks ugly smh\n        this._serverAddress = ip_v4[0].toString() + \".\" + ip_v4[1].toString() + \".\" + ip_v4[2].toString() + \".\" + ip_v4[3].toString();\n      } else {\n        // TODO find a better of doing this\n        const serverAddressLen = reader.read(2).readInt16BE(0);\n        if (serverAddressLen > 100) {\n          reader.offset -= 2;\n          this._serverAddress = reader.read(16).toString(\"hex\").match(/.{1,4}/g).map(val => val.replace(/^0+/, \"\")).join(\":\").replace(/0000\\:/g, \":\").replace(/:{2,}/g, \"::\");\n        } else {\n          this._serverAddress = reader.read(serverAddressLen).toString();\n        }\n      }\n      this._port = reader.read(2).readInt16BE(0);\n      this._key = reader.read(-1);\n    }\n  }\n  /**\n   * @param x {Buffer}\n   * @returns {string}\n   */\n  static encode(x) {\n    return x.toString(\"base64\");\n  }\n  /**\n   * @param x {string}\n   * @returns {Buffer}\n   */\n  static decode(x) {\n    return Buffer.from(x, \"base64\");\n  }\n  async load() {\n    if (this._key) {\n      this._authKey = new AuthKey_1.AuthKey();\n      await this._authKey.setKey(this._key);\n    }\n  }\n  save() {\n    if (!this.authKey || !this.serverAddress || !this.port) {\n      return \"\";\n    }\n    // TS is weird\n    const key = this.authKey.getKey();\n    if (!key) {\n      return \"\";\n    }\n    const dcBuffer = Buffer.from([this.dcId]);\n    const addressBuffer = Buffer.from(this.serverAddress);\n    const addressLengthBuffer = Buffer.alloc(2);\n    addressLengthBuffer.writeInt16BE(addressBuffer.length, 0);\n    const portBuffer = Buffer.alloc(2);\n    portBuffer.writeInt16BE(this.port, 0);\n    return CURRENT_VERSION + StringSession.encode(Buffer.concat([dcBuffer, addressLengthBuffer, addressBuffer, portBuffer, key]));\n  }\n}\nexports.StringSession = StringSession;","map":{"version":3,"names":["Object","defineProperty","exports","value","StringSession","Memory_1","require","extensions_1","AuthKey_1","CURRENT_VERSION","MemorySession","constructor","session","Error","slice","r","decode","reader","BinaryReader","_dcId","read","readUInt8","length","ip_v4","_serverAddress","toString","serverAddressLen","readInt16BE","offset","match","map","val","replace","join","_port","_key","encode","x","Buffer","from","load","_authKey","AuthKey","setKey","save","authKey","serverAddress","port","key","getKey","dcBuffer","dcId","addressBuffer","addressLengthBuffer","alloc","writeInt16BE","portBuffer","concat"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/sessions/StringSession.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StringSession = void 0;\nconst Memory_1 = require(\"./Memory\");\nconst extensions_1 = require(\"../extensions\");\nconst AuthKey_1 = require(\"../crypto/AuthKey\");\nconst CURRENT_VERSION = \"1\";\nclass StringSession extends Memory_1.MemorySession {\n    /**\n     * This session file can be easily saved and loaded as a string. According\n     * to the initial design, it contains only the data that is necessary for\n     * successful connection and authentication, so takeout ID is not stored.\n\n     * It is thought to be used where you don't want to create any on-disk\n     * files but would still like to be able to save and load existing sessions\n     * by other means.\n\n     * You can use custom `encode` and `decode` functions, if present:\n\n     * `encode` definition must be ``function encode(value: Buffer) -> string:``.\n     * `decode` definition must be ``function decode(value: string) -> Buffer:``.\n     * @param session {string|null}\n     */\n    constructor(session) {\n        super();\n        if (session) {\n            if (session[0] !== CURRENT_VERSION) {\n                throw new Error(\"Not a valid string\");\n            }\n            session = session.slice(1);\n            const r = StringSession.decode(session);\n            const reader = new extensions_1.BinaryReader(r);\n            this._dcId = reader.read(1).readUInt8(0);\n            if (session.length == 352) {\n                // Telethon session\n                const ip_v4 = reader.read(4);\n                // TODO looks ugly smh\n                this._serverAddress =\n                    ip_v4[0].toString() +\n                        \".\" +\n                        ip_v4[1].toString() +\n                        \".\" +\n                        ip_v4[2].toString() +\n                        \".\" +\n                        ip_v4[3].toString();\n            }\n            else {\n                // TODO find a better of doing this\n                const serverAddressLen = reader.read(2).readInt16BE(0);\n                if (serverAddressLen > 100) {\n                    reader.offset -= 2;\n                    this._serverAddress = reader\n                        .read(16)\n                        .toString(\"hex\")\n                        .match(/.{1,4}/g)\n                        .map((val) => val.replace(/^0+/, \"\"))\n                        .join(\":\")\n                        .replace(/0000\\:/g, \":\")\n                        .replace(/:{2,}/g, \"::\");\n                }\n                else {\n                    this._serverAddress = reader\n                        .read(serverAddressLen)\n                        .toString();\n                }\n            }\n            this._port = reader.read(2).readInt16BE(0);\n            this._key = reader.read(-1);\n        }\n    }\n    /**\n     * @param x {Buffer}\n     * @returns {string}\n     */\n    static encode(x) {\n        return x.toString(\"base64\");\n    }\n    /**\n     * @param x {string}\n     * @returns {Buffer}\n     */\n    static decode(x) {\n        return Buffer.from(x, \"base64\");\n    }\n    async load() {\n        if (this._key) {\n            this._authKey = new AuthKey_1.AuthKey();\n            await this._authKey.setKey(this._key);\n        }\n    }\n    save() {\n        if (!this.authKey || !this.serverAddress || !this.port) {\n            return \"\";\n        }\n        // TS is weird\n        const key = this.authKey.getKey();\n        if (!key) {\n            return \"\";\n        }\n        const dcBuffer = Buffer.from([this.dcId]);\n        const addressBuffer = Buffer.from(this.serverAddress);\n        const addressLengthBuffer = Buffer.alloc(2);\n        addressLengthBuffer.writeInt16BE(addressBuffer.length, 0);\n        const portBuffer = Buffer.alloc(2);\n        portBuffer.writeInt16BE(this.port, 0);\n        return (CURRENT_VERSION +\n            StringSession.encode(Buffer.concat([\n                dcBuffer,\n                addressLengthBuffer,\n                addressBuffer,\n                portBuffer,\n                key,\n            ])));\n    }\n}\nexports.StringSession = StringSession;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}