{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.variableSnakeToCamelCase = exports.snakeToCamelCase = exports.CORE_TYPES = exports.fromLine = exports.parseTl = exports.findAll = void 0;\nexports.serializeBytes = serializeBytes;\nexports.serializeDate = serializeDate;\nexports.buildArgConfig = buildArgConfig;\nconst Helpers_1 = require(\"../Helpers\");\nconst snakeToCamelCase = name => {\n  const result = name.replace(/(?:^|_)([a-z])/g, (_, g) => g.toUpperCase());\n  return result.replace(/_/g, \"\");\n};\nexports.snakeToCamelCase = snakeToCamelCase;\nconst variableSnakeToCamelCase = str => str.replace(/([-_][a-z])/g, group => group.toUpperCase().replace(\"-\", \"\").replace(\"_\", \"\"));\nexports.variableSnakeToCamelCase = variableSnakeToCamelCase;\nconst CORE_TYPES = new Set([0xbc799737,\n// boolFalse#bc799737 = Bool;\n0x997275b5,\n// boolTrue#997275b5 = Bool;\n0x3fedd339,\n// true#3fedd339 = True;\n0xc4b9f9bb,\n// error#c4b9f9bb code:int text:string = Error;\n0x56730bcc // null#56730bcc = Null;\n]);\nexports.CORE_TYPES = CORE_TYPES;\nconst AUTH_KEY_TYPES = new Set([0x05162463,\n// resPQ,\n0x83c95aec,\n// p_q_inner_data\n0xa9f55f95,\n// p_q_inner_data_dc\n0x3c6a84d4,\n// p_q_inner_data_temp\n0x56fddf88,\n// p_q_inner_data_temp_dc\n0xd0e8075c,\n// server_DH_params_ok\n0xb5890dba,\n// server_DH_inner_data\n0x6643b654,\n// client_DH_inner_data\n0xd712e4be,\n// req_DH_params\n0xf5045f1f,\n// set_client_DH_params\n0x3072cfa1 // gzip_packed\n]);\nconst fromLine = (line, isFunction) => {\n  const match = line.match(/([\\w.]+)(?:#([0-9a-fA-F]+))?(?:\\s{?\\w+:[\\w\\d<>#.?!]+}?)*\\s=\\s([\\w\\d<>#.?]+);$/);\n  if (!match) {\n    // Probably \"vector#1cb5c415 {t:Type} # [ t ] = Vector t;\"\n    throw new Error(`Cannot parse TLObject ${line}`);\n  }\n  const argsMatch = findAll(/({)?(\\w+):([\\w\\d<>#.?!]+)}?/, line);\n  const currentConfig = {\n    name: match[1],\n    constructorId: parseInt(match[2], 16),\n    argsConfig: {},\n    subclassOfId: (0, Helpers_1.crc32)(match[3]),\n    result: match[3],\n    isFunction: isFunction,\n    namespace: undefined\n  };\n  if (!currentConfig.constructorId) {\n    const hexId = \"\";\n    let args;\n    if (Object.values(currentConfig.argsConfig).length) {\n      args = ` ${Object.keys(currentConfig.argsConfig).map(arg => arg.toString()).join(\" \")}`;\n    } else {\n      args = \"\";\n    }\n    const representation = `${currentConfig.name}${hexId}${args} = ${currentConfig.result}`.replace(/(:|\\?)bytes /g, \"$1string \").replace(/</g, \" \").replace(/>|{|}/g, \"\").replace(/ \\w+:flags(\\d+)?\\.\\d+\\?true/g, \"\");\n    if (currentConfig.name === \"inputMediaInvoice\") {\n      // eslint-disable-next-line no-empty\n      if (currentConfig.name === \"inputMediaInvoice\") {}\n    }\n    currentConfig.constructorId = (0, Helpers_1.crc32)(Buffer.from(representation, \"utf8\"));\n  }\n  for (const [brace, name, argType] of argsMatch) {\n    if (brace === undefined) {\n      // @ts-ignore\n      currentConfig.argsConfig[variableSnakeToCamelCase(name)] = buildArgConfig(name, argType);\n    }\n  }\n  if (currentConfig.name.includes(\".\")) {\n    [currentConfig.namespace, currentConfig.name] = currentConfig.name.split(/\\.(.+)/);\n  }\n  currentConfig.name = snakeToCamelCase(currentConfig.name);\n  /*\n  for (const arg in currentConfig.argsConfig){\n    if (currentConfig.argsConfig.hasOwnProperty(arg)){\n      if (currentConfig.argsConfig[arg].flagIndicator){\n        delete  currentConfig.argsConfig[arg]\n      }\n    }\n  }*/\n  return currentConfig;\n};\nexports.fromLine = fromLine;\nfunction buildArgConfig(name, argType) {\n  name = name === \"self\" ? \"is_self\" : name;\n  // Default values\n  const currentConfig = {\n    isVector: false,\n    isFlag: false,\n    skipConstructorId: false,\n    flagName: null,\n    flagIndex: -1,\n    flagIndicator: true,\n    type: null,\n    useVectorId: null\n  };\n  // Special case: some types can be inferred, which makes it\n  // less annoying to type. Currently the only type that can\n  // be inferred is if the name is 'random_id', to which a\n  // random ID will be assigned if left as None (the default)\n  const canBeInferred = name === \"random_id\";\n  // The type can be an indicator that other arguments will be flags\n  if (argType !== \"#\") {\n    currentConfig.flagIndicator = false;\n    // Strip the exclamation mark always to have only the name\n    currentConfig.type = argType.replace(/^!+/, \"\");\n    // The type may be a flag (flags.IDX?REAL_TYPE)\n    // Note that 'flags' is NOT the flags name; this\n    // is determined by a previous argument\n    // However, we assume that the argument will always be starts with 'flags'\n    // @ts-ignore\n    const flagMatch = currentConfig.type.match(/(flags(?:\\d+)?).(\\d+)\\?([\\w<>.]+)/);\n    if (flagMatch) {\n      currentConfig.isFlag = true;\n      // As of layer 140, flagName can be \"flags\" or \"flags2\"\n      currentConfig.flagName = flagMatch[1];\n      currentConfig.flagIndex = Number(flagMatch[2]);\n      // Update the type to match the exact type, not the \"flagged\" one\n      currentConfig.type = flagMatch[3];\n    }\n    // Then check if the type is a Vector<REAL_TYPE>\n    // @ts-ignore\n    const vectorMatch = currentConfig.type.match(/[Vv]ector<([\\w\\d.]+)>/);\n    if (vectorMatch) {\n      currentConfig.isVector = true;\n      // If the type's first letter is not uppercase, then\n      // it is a constructor and we use (read/write) its ID.\n      // @ts-ignore\n      currentConfig.useVectorId = currentConfig.type.charAt(0) === \"V\";\n      // Update the type to match the one inside the vector\n      [, currentConfig.type] = vectorMatch;\n    }\n    // See use_vector_id. An example of such case is ipPort in\n    // help.configSpecial\n    // @ts-ignore\n    if (/^[a-z]$/.test(currentConfig.type.split(\".\").pop().charAt(0))) {\n      currentConfig.skipConstructorId = true;\n    }\n    // The name may contain \"date\" in it, if this is the case and\n    // the type is \"int\", we can safely assume that this should be\n    // treated as a \"date\" object. Note that this is not a valid\n    // Telegram object, but it's easier to work with\n    // if (\n    //     this.type === 'int' &&\n    //     (/(\\b|_)([dr]ate|until|since)(\\b|_)/.test(name) ||\n    //         ['expires', 'expires_at', 'was_online'].includes(name))\n    // ) {\n    //     this.type = 'date';\n    // }\n  }\n  // workaround\n  if (currentConfig.type == \"future_salt\") {\n    currentConfig.type = \"FutureSalt\";\n  }\n  return currentConfig;\n}\nconst parseTl = function (content, layer) {\n  let methods = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let ignoreIds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : CORE_TYPES;\n  return function* () {\n    const methodInfo = (methods || []).reduce((o, m) => Object.assign(Object.assign({}, o), {\n      [m.name]: m\n    }), {});\n    const objAll = [];\n    const objByName = {};\n    const objByType = {};\n    const file = content;\n    let isFunction = false;\n    for (let line of file.split(\"\\n\")) {\n      const commentIndex = line.indexOf(\"//\");\n      if (commentIndex !== -1) {\n        line = line.slice(0, commentIndex);\n      }\n      line = line.trim();\n      if (!line) {\n        continue;\n      }\n      const match = line.match(/---(\\w+)---/);\n      if (match) {\n        const [, followingTypes] = match;\n        isFunction = followingTypes === \"functions\";\n        continue;\n      }\n      try {\n        const result = fromLine(line, isFunction);\n        if (ignoreIds.has(result.constructorId)) {\n          continue;\n        }\n        objAll.push(result);\n        if (!result.isFunction) {\n          if (!objByType[result.result]) {\n            objByType[result.result] = [];\n          }\n          objByName[result.name] = result;\n          objByType[result.result].push(result);\n        }\n      } catch (e) {\n        if (!e.toString().includes(\"vector#1cb5c415\")) {\n          throw e;\n        }\n      }\n    }\n    // Once all objects have been parsed, replace the\n    // string type from the arguments with references\n    for (const obj of objAll) {\n      if (AUTH_KEY_TYPES.has(obj.constructorId)) {\n        for (const arg in obj.argsConfig) {\n          if (obj.argsConfig[arg].type === \"string\") {\n            obj.argsConfig[arg].type = \"bytes\";\n          }\n        }\n      }\n    }\n    for (const obj of objAll) {\n      yield obj;\n    }\n  }();\n};\nexports.parseTl = parseTl;\nconst findAll = function (regex, str) {\n  let matches = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  if (!regex.flags.includes(\"g\")) {\n    regex = new RegExp(regex.source, \"g\");\n  }\n  const res = regex.exec(str);\n  if (res) {\n    matches.push(res.slice(1));\n    findAll(regex, str, matches);\n  }\n  return matches;\n};\nexports.findAll = findAll;\nfunction serializeBytes(data) {\n  if (!(data instanceof Buffer)) {\n    if (typeof data == \"string\") {\n      data = Buffer.from(data);\n    } else {\n      throw Error(`Bytes or str expected, not ${data.constructor.name}`);\n    }\n  }\n  const r = [];\n  let padding;\n  if (data.length < 254) {\n    padding = (data.length + 1) % 4;\n    if (padding !== 0) {\n      padding = 4 - padding;\n    }\n    r.push(Buffer.from([data.length]));\n    r.push(data);\n  } else {\n    padding = data.length % 4;\n    if (padding !== 0) {\n      padding = 4 - padding;\n    }\n    r.push(Buffer.from([254, data.length % 256, (data.length >> 8) % 256, (data.length >> 16) % 256]));\n    r.push(data);\n  }\n  r.push(Buffer.alloc(padding).fill(0));\n  return Buffer.concat(r);\n}\nfunction serializeDate(dt) {\n  if (!dt) {\n    return Buffer.alloc(4).fill(0);\n  }\n  if (dt instanceof Date) {\n    dt = Math.floor((Date.now() - dt.getTime()) / 1000);\n  }\n  if (typeof dt == \"number\") {\n    const t = Buffer.alloc(4);\n    t.writeInt32LE(dt, 0);\n    return t;\n  }\n  throw Error(`Cannot interpret \"${dt}\" as a date`);\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}