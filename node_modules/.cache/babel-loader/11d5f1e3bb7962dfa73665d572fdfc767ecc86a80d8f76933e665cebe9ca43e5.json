{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeCheck = computeCheck;\nexports.computeDigest = computeDigest;\nconst tl_1 = require(\"./tl\");\nconst Helpers_1 = require(\"./Helpers\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst CryptoFile_1 = __importDefault(require(\"./CryptoFile\"));\nconst SIZE_FOR_HASH = 256;\n/**\n *\n *\n * @param prime{BigInteger}\n * @param g{BigInteger}\n */\n/*\nWe don't support changing passwords yet\nfunction checkPrimeAndGoodCheck(prime, g) {\n    console.error('Unsupported function `checkPrimeAndGoodCheck` call. Arguments:', prime, g)\n\n    const goodPrimeBitsCount = 2048\n    if (prime < 0 || prime.bitLength() !== goodPrimeBitsCount) {\n        throw new Error(`bad prime count ${prime.bitLength()},expected ${goodPrimeBitsCount}`)\n    }\n    // TODO this is kinda slow\n    if (Factorizator.factorize(prime)[0] !== 1) {\n        throw new Error('give \"prime\" is not prime')\n    }\n    if (g.eq(bigInt(2))) {\n        if ((prime.remainder(bigInt(8))).neq(bigInt(7))) {\n            throw new Error(`bad g ${g}, mod8 ${prime % 8}`)\n        }\n    } else if (g.eq(bigInt(3))) {\n        if ((prime.remainder(bigInt(3))).neq(bigInt(2))) {\n            throw new Error(`bad g ${g}, mod3 ${prime % 3}`)\n        }\n        // eslint-disable-next-line no-empty\n    } else if (g.eq(bigInt(4))) {\n\n    } else if (g.eq(bigInt(5))) {\n        if (!([ bigInt(1), bigInt(4) ].includes(prime.remainder(bigInt(5))))) {\n            throw new Error(`bad g ${g}, mod8 ${prime % 5}`)\n        }\n    } else if (g.eq(bigInt(6))) {\n        if (!([ bigInt(19), bigInt(23) ].includes(prime.remainder(bigInt(24))))) {\n            throw new Error(`bad g ${g}, mod8 ${prime % 24}`)\n        }\n    } else if (g.eq(bigInt(7))) {\n        if (!([ bigInt(3), bigInt(5), bigInt(6) ].includes(prime.remainder(bigInt(7))))) {\n            throw new Error(`bad g ${g}, mod8 ${prime % 7}`)\n        }\n    } else {\n        throw new Error(`bad g ${g}`)\n    }\n    const primeSub1Div2 = (prime.subtract(bigInt(1))).divide(bigInt(2))\n    if (Factorizator.factorize(primeSub1Div2)[0] !== 1) {\n        throw new Error('(prime - 1) // 2 is not prime')\n    }\n}\n*/\n/**\n *\n * @param primeBytes{Buffer}\n * @param g{number}\n */\nfunction checkPrimeAndGood(primeBytes, g) {\n  const goodPrime = Buffer.from([0xc7, 0x1c, 0xae, 0xb9, 0xc6, 0xb1, 0xc9, 0x04, 0x8e, 0x6c, 0x52, 0x2f, 0x70, 0xf1, 0x3f, 0x73, 0x98, 0x0d, 0x40, 0x23, 0x8e, 0x3e, 0x21, 0xc1, 0x49, 0x34, 0xd0, 0x37, 0x56, 0x3d, 0x93, 0x0f, 0x48, 0x19, 0x8a, 0x0a, 0xa7, 0xc1, 0x40, 0x58, 0x22, 0x94, 0x93, 0xd2, 0x25, 0x30, 0xf4, 0xdb, 0xfa, 0x33, 0x6f, 0x6e, 0x0a, 0xc9, 0x25, 0x13, 0x95, 0x43, 0xae, 0xd4, 0x4c, 0xce, 0x7c, 0x37, 0x20, 0xfd, 0x51, 0xf6, 0x94, 0x58, 0x70, 0x5a, 0xc6, 0x8c, 0xd4, 0xfe, 0x6b, 0x6b, 0x13, 0xab, 0xdc, 0x97, 0x46, 0x51, 0x29, 0x69, 0x32, 0x84, 0x54, 0xf1, 0x8f, 0xaf, 0x8c, 0x59, 0x5f, 0x64, 0x24, 0x77, 0xfe, 0x96, 0xbb, 0x2a, 0x94, 0x1d, 0x5b, 0xcd, 0x1d, 0x4a, 0xc8, 0xcc, 0x49, 0x88, 0x07, 0x08, 0xfa, 0x9b, 0x37, 0x8e, 0x3c, 0x4f, 0x3a, 0x90, 0x60, 0xbe, 0xe6, 0x7c, 0xf9, 0xa4, 0xa4, 0xa6, 0x95, 0x81, 0x10, 0x51, 0x90, 0x7e, 0x16, 0x27, 0x53, 0xb5, 0x6b, 0x0f, 0x6b, 0x41, 0x0d, 0xba, 0x74, 0xd8, 0xa8, 0x4b, 0x2a, 0x14, 0xb3, 0x14, 0x4e, 0x0e, 0xf1, 0x28, 0x47, 0x54, 0xfd, 0x17, 0xed, 0x95, 0x0d, 0x59, 0x65, 0xb4, 0xb9, 0xdd, 0x46, 0x58, 0x2d, 0xb1, 0x17, 0x8d, 0x16, 0x9c, 0x6b, 0xc4, 0x65, 0xb0, 0xd6, 0xff, 0x9c, 0xa3, 0x92, 0x8f, 0xef, 0x5b, 0x9a, 0xe4, 0xe4, 0x18, 0xfc, 0x15, 0xe8, 0x3e, 0xbe, 0xa0, 0xf8, 0x7f, 0xa9, 0xff, 0x5e, 0xed, 0x70, 0x05, 0x0d, 0xed, 0x28, 0x49, 0xf4, 0x7b, 0xf9, 0x59, 0xd9, 0x56, 0x85, 0x0c, 0xe9, 0x29, 0x85, 0x1f, 0x0d, 0x81, 0x15, 0xf6, 0x35, 0xb1, 0x05, 0xee, 0x2e, 0x4e, 0x15, 0xd0, 0x4b, 0x24, 0x54, 0xbf, 0x6f, 0x4f, 0xad, 0xf0, 0x34, 0xb1, 0x04, 0x03, 0x11, 0x9c, 0xd8, 0xe3, 0xb9, 0x2f, 0xcc, 0x5b]);\n  if (goodPrime.equals(primeBytes)) {\n    if ([3, 4, 5, 7].includes(g)) {\n      return; // It's good\n    }\n  }\n  throw new Error(\"Changing passwords unsupported\");\n  //checkPrimeAndGoodCheck(readBigIntFromBuffer(primeBytes, false), g)\n}\n/**\n *\n * @param number{BigInteger}\n * @param p{BigInteger}\n * @returns {boolean}\n */\nfunction isGoodLarge(number, p) {\n  return number.greater((0, big_integer_1.default)(0)) && p.subtract(number).greater((0, big_integer_1.default)(0));\n}\n/**\n *\n * @param number {Buffer}\n * @returns {Buffer}\n */\nfunction numBytesForHash(number) {\n  return Buffer.concat([Buffer.alloc(SIZE_FOR_HASH - number.length), number]);\n}\n/**\n *\n * @param g {bigInt}\n * @returns {Buffer}\n */\nfunction bigNumForHash(g) {\n  return (0, Helpers_1.readBufferFromBigInt)(g, SIZE_FOR_HASH, false);\n}\n/**\n *\n * @param modexp {BigInteger}\n * @param prime {BigInteger}\n * @returns {Boolean}\n */\nfunction isGoodModExpFirst(modexp, prime) {\n  const diff = prime.subtract(modexp);\n  const minDiffBitsCount = 2048 - 64;\n  const maxModExpSize = 256;\n  return !(diff.lesser((0, big_integer_1.default)(0)) || diff.bitLength().toJSNumber() < minDiffBitsCount || modexp.bitLength().toJSNumber() < minDiffBitsCount || Math.floor((modexp.bitLength().toJSNumber() + 7) / 8) > maxModExpSize);\n}\nfunction xor(a, b) {\n  const length = Math.min(a.length, b.length);\n  for (let i = 0; i < length; i++) {\n    a[i] = a[i] ^ b[i];\n  }\n  return a;\n}\n/**\n *\n * @param password{Buffer}\n * @param salt{Buffer}\n * @param iterations{number}\n * @returns {*}\n */\nfunction pbkdf2sha512(password, salt, iterations) {\n  return CryptoFile_1.default.pbkdf2Sync(password, salt, iterations, 64, \"sha512\");\n}\n/**\n *\n * @param algo {constructors.PasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow}\n * @param password\n * @returns {Buffer|*}\n */\nasync function computeHash(algo, password) {\n  const hash1 = await (0, Helpers_1.sha256)(Buffer.concat([algo.salt1, Buffer.from(password, \"utf-8\"), algo.salt1]));\n  const hash2 = await (0, Helpers_1.sha256)(Buffer.concat([algo.salt2, hash1, algo.salt2]));\n  const hash3 = await pbkdf2sha512(hash2, algo.salt1, 100000);\n  return (0, Helpers_1.sha256)(Buffer.concat([algo.salt2, hash3, algo.salt2]));\n}\n/**\n *\n * @param algo {constructors.PasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow}\n * @param password\n */\nasync function computeDigest(algo, password) {\n  try {\n    checkPrimeAndGood(algo.p, algo.g);\n  } catch (e) {\n    throw new Error(\"bad p/g in password\");\n  }\n  const value = (0, Helpers_1.modExp)((0, big_integer_1.default)(algo.g), (0, Helpers_1.readBigIntFromBuffer)(await computeHash(algo, password), false), (0, Helpers_1.readBigIntFromBuffer)(algo.p, false));\n  return bigNumForHash(value);\n}\n/**\n *\n * @param request {constructors.account.Password}\n * @param password {string}\n */\nasync function computeCheck(request, password) {\n  const algo = request.currentAlgo;\n  if (!(algo instanceof tl_1.Api.PasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow)) {\n    throw new Error(`Unsupported password algorithm ${algo === null || algo === void 0 ? void 0 : algo.className}`);\n  }\n  const srp_B = request.srp_B;\n  const srpId = request.srpId;\n  if (!srp_B || !srpId) {\n    throw new Error(`Undefined srp_b  ${request}`);\n  }\n  const pwHash = await computeHash(algo, password);\n  const p = (0, Helpers_1.readBigIntFromBuffer)(algo.p, false);\n  const g = algo.g;\n  const B = (0, Helpers_1.readBigIntFromBuffer)(srp_B, false);\n  try {\n    checkPrimeAndGood(algo.p, g);\n  } catch (e) {\n    throw new Error(\"bad /g in password\");\n  }\n  if (!isGoodLarge(B, p)) {\n    throw new Error(\"bad b in check\");\n  }\n  const x = (0, Helpers_1.readBigIntFromBuffer)(pwHash, false);\n  const pForHash = numBytesForHash(algo.p);\n  const gForHash = bigNumForHash((0, big_integer_1.default)(g));\n  const bForHash = numBytesForHash(srp_B);\n  const gX = (0, Helpers_1.modExp)((0, big_integer_1.default)(g), x, p);\n  const k = (0, Helpers_1.readBigIntFromBuffer)(await (0, Helpers_1.sha256)(Buffer.concat([pForHash, gForHash])), false);\n  const kgX = (0, Helpers_1.bigIntMod)(k.multiply(gX), p);\n  const generateAndCheckRandom = async () => {\n    const randomSize = 256;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const random = (0, Helpers_1.generateRandomBytes)(randomSize);\n      const a = (0, Helpers_1.readBigIntFromBuffer)(random, false);\n      const A = (0, Helpers_1.modExp)((0, big_integer_1.default)(g), a, p);\n      if (isGoodModExpFirst(A, p)) {\n        const aForHash = bigNumForHash(A);\n        const u = (0, Helpers_1.readBigIntFromBuffer)(await (0, Helpers_1.sha256)(Buffer.concat([aForHash, bForHash])), false);\n        if (u.greater((0, big_integer_1.default)(0))) {\n          return {\n            a: a,\n            aForHash: aForHash,\n            u: u\n          };\n        }\n      }\n    }\n  };\n  const {\n    a,\n    aForHash,\n    u\n  } = await generateAndCheckRandom();\n  const gB = (0, Helpers_1.bigIntMod)(B.subtract(kgX), p);\n  if (!isGoodModExpFirst(gB, p)) {\n    throw new Error(\"bad gB\");\n  }\n  const ux = u.multiply(x);\n  const aUx = a.add(ux);\n  const S = (0, Helpers_1.modExp)(gB, aUx, p);\n  const [K, pSha, gSha, salt1Sha, salt2Sha] = await Promise.all([(0, Helpers_1.sha256)(bigNumForHash(S)), (0, Helpers_1.sha256)(pForHash), (0, Helpers_1.sha256)(gForHash), (0, Helpers_1.sha256)(algo.salt1), (0, Helpers_1.sha256)(algo.salt2)]);\n  const M1 = await (0, Helpers_1.sha256)(Buffer.concat([xor(pSha, gSha), salt1Sha, salt2Sha, aForHash, bForHash, K]));\n  return new tl_1.Api.InputCheckPasswordSRP({\n    srpId: srpId,\n    A: Buffer.from(aForHash),\n    M1: M1\n  });\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}