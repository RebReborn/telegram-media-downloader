{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConnectionTCPMTProxyAbridged = exports.TCPMTProxy = void 0;\nconst Connection_1 = require(\"./Connection\");\nconst TCPAbridged_1 = require(\"./TCPAbridged\");\nconst Helpers_1 = require(\"../../Helpers\");\nconst CTR_1 = require(\"../../crypto/CTR\");\nclass MTProxyIO {\n  constructor(connection) {\n    this.header = undefined;\n    this.connection = connection.socket;\n    this._packetClass = connection.PacketCodecClass;\n    this._secret = connection._secret;\n    this._dcId = connection._dcId;\n  }\n  async initHeader() {\n    let secret = this._secret;\n    const isDD = secret.length == 17 && secret[0] == 0xdd;\n    secret = isDD ? secret.slice(1) : secret;\n    if (secret.length != 16) {\n      throw new Error(\"MTProxy secret must be a hex-string representing 16 bytes\");\n    }\n    const keywords = [Buffer.from(\"50567247\", \"hex\"), Buffer.from(\"474554\", \"hex\"), Buffer.from(\"504f5354\", \"hex\"), Buffer.from(\"eeeeeeee\", \"hex\")];\n    let random;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      random = (0, Helpers_1.generateRandomBytes)(64);\n      if (random[0] !== 0xef && !random.slice(4, 8).equals(Buffer.alloc(4))) {\n        let ok = true;\n        for (const key of keywords) {\n          if (key.equals(random.slice(0, 4))) {\n            ok = false;\n            break;\n          }\n        }\n        if (ok) {\n          break;\n        }\n      }\n    }\n    random = random.toJSON().data;\n    const randomReversed = Buffer.from(random.slice(8, 56)).reverse();\n    // Encryption has \"continuous buffer\" enabled\n    const encryptKey = await (0, Helpers_1.sha256)(Buffer.concat([Buffer.from(random.slice(8, 40)), secret]));\n    const encryptIv = Buffer.from(random.slice(40, 56));\n    const decryptKey = await (0, Helpers_1.sha256)(Buffer.concat([Buffer.from(randomReversed.slice(0, 32)), secret]));\n    const decryptIv = Buffer.from(randomReversed.slice(32, 48));\n    const encryptor = new CTR_1.CTR(encryptKey, encryptIv);\n    const decryptor = new CTR_1.CTR(decryptKey, decryptIv);\n    random = Buffer.concat([Buffer.from(random.slice(0, 56)), this._packetClass.obfuscateTag, Buffer.from(random.slice(60))]);\n    const dcIdBytes = Buffer.alloc(2);\n    dcIdBytes.writeInt8(this._dcId, 0);\n    random = Buffer.concat([Buffer.from(random.slice(0, 60)), dcIdBytes, Buffer.from(random.slice(62))]);\n    random = Buffer.concat([Buffer.from(random.slice(0, 56)), Buffer.from(encryptor.encrypt(random).slice(56, 64)), Buffer.from(random.slice(64))]);\n    this.header = random;\n    this._encrypt = encryptor;\n    this._decrypt = decryptor;\n  }\n  async read(n) {\n    const data = await this.connection.readExactly(n);\n    return this._decrypt.encrypt(data);\n  }\n  write(data) {\n    this.connection.write(this._encrypt.encrypt(data));\n  }\n}\nclass TCPMTProxy extends Connection_1.ObfuscatedConnection {\n  constructor(_ref) {\n    let {\n      ip,\n      port,\n      dcId,\n      loggers,\n      proxy,\n      socket,\n      testServers\n    } = _ref;\n    super({\n      ip: proxy.ip,\n      port: proxy.port,\n      dcId: dcId,\n      loggers: loggers,\n      socket: socket,\n      proxy: proxy,\n      testServers: testServers\n    });\n    this.ObfuscatedIO = MTProxyIO;\n    if (!(\"MTProxy\" in proxy)) {\n      throw new Error(\"This connection only supports MPTProxies\");\n    }\n    if (!proxy.secret) {\n      throw new Error(\"You need to provide the secret for the MTProxy\");\n    }\n    if (proxy.secret && proxy.secret.match(/^[0-9a-f]+$/i)) {\n      // probably hex\n      this._secret = Buffer.from(proxy.secret, \"hex\");\n    } else {\n      // probably b64\n      this._secret = Buffer.from(proxy.secret, \"base64\");\n    }\n  }\n}\nexports.TCPMTProxy = TCPMTProxy;\nclass ConnectionTCPMTProxyAbridged extends TCPMTProxy {\n  constructor() {\n    super(...arguments);\n    this.PacketCodecClass = TCPAbridged_1.AbridgedPacketCodec;\n  }\n}\nexports.ConnectionTCPMTProxyAbridged = ConnectionTCPMTProxyAbridged;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}