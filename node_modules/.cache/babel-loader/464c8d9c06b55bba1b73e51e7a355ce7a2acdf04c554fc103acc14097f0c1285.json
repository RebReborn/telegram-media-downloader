{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObfuscatedConnection = exports.PacketCodec = exports.Connection = void 0;\nconst extensions_1 = require(\"../../extensions\");\n/**\n * The `Connection` class is a wrapper around ``asyncio.open_connection``.\n *\n * Subclasses will implement different transport modes as atomic operations,\n * which this class eases doing since the exposed interface simply puts and\n * gets complete data payloads to and from queues.\n *\n * The only error that will raise from send and receive methods is\n * ``ConnectionError``, which will raise when attempting to send if\n * the client is disconnected (includes remote disconnections).\n */\nclass Connection {\n  constructor({\n    ip,\n    port,\n    dcId,\n    loggers,\n    proxy,\n    socket,\n    testServers\n  }) {\n    this._ip = ip;\n    this._port = port;\n    this._dcId = dcId;\n    this._log = loggers;\n    this._proxy = proxy;\n    this._connected = false;\n    this._sendTask = undefined;\n    this._recvTask = undefined;\n    this._codec = undefined;\n    this._obfuscation = undefined; // TcpObfuscated and MTProxy\n    this._sendArray = new extensions_1.AsyncQueue();\n    this._recvArray = new extensions_1.AsyncQueue();\n    this.socket = new socket(proxy);\n    this._testServers = testServers;\n  }\n  async _connect() {\n    this._log.debug(\"Connecting\");\n    this._codec = new this.PacketCodecClass(this);\n    await this.socket.connect(this._port, this._ip, this._testServers);\n    this._log.debug(\"Finished connecting\");\n    // await this.socket.connect({host: this._ip, port: this._port});\n    await this._initConn();\n  }\n  async connect() {\n    await this._connect();\n    this._connected = true;\n    if (!this._sendTask) {\n      this._sendTask = this._sendLoop();\n    }\n    this._recvTask = this._recvLoop();\n  }\n  async disconnect() {\n    if (!this._connected) {\n      return;\n    }\n    this._connected = false;\n    void this._recvArray.push(undefined);\n    await this.socket.close();\n  }\n  async send(data) {\n    if (!this._connected) {\n      throw new Error(\"Not connected\");\n    }\n    await this._sendArray.push(data);\n  }\n  async recv() {\n    while (this._connected) {\n      const result = await this._recvArray.pop();\n      // null = sentinel value = keep trying\n      if (result) {\n        return result;\n      }\n    }\n    throw new Error(\"Not connected\");\n  }\n  async _sendLoop() {\n    try {\n      while (this._connected) {\n        const data = await this._sendArray.pop();\n        if (!data) {\n          this._sendTask = undefined;\n          return;\n        }\n        await this._send(data);\n      }\n    } catch (e) {\n      this._log.info(\"The server closed the connection while sending\");\n    }\n  }\n  isConnected() {\n    return this._connected;\n  }\n  async _recvLoop() {\n    let data;\n    while (this._connected) {\n      try {\n        data = await this._recv();\n        if (!data) {\n          throw new Error(\"no data received\");\n        }\n      } catch (e) {\n        this._log.info(\"connection closed\");\n        // await this._recvArray.push()\n        this.disconnect();\n        return;\n      }\n      await this._recvArray.push(data);\n    }\n  }\n  async _initConn() {\n    if (this._codec.tag) {\n      await this.socket.write(this._codec.tag);\n    }\n  }\n  async _send(data) {\n    const encodedPacket = this._codec.encodePacket(data);\n    this.socket.write(encodedPacket);\n  }\n  async _recv() {\n    return await this._codec.readPacket(this.socket);\n  }\n  toString() {\n    return `${this._ip}:${this._port}/${this.constructor.name.replace(\"Connection\", \"\")}`;\n  }\n}\nexports.Connection = Connection;\nclass ObfuscatedConnection extends Connection {\n  constructor() {\n    super(...arguments);\n    this.ObfuscatedIO = undefined;\n  }\n  async _initConn() {\n    this._obfuscation = new this.ObfuscatedIO(this);\n    await this._obfuscation.initHeader();\n    this.socket.write(this._obfuscation.header);\n  }\n  async _send(data) {\n    this._obfuscation.write(this._codec.encodePacket(data));\n  }\n  async _recv() {\n    return await this._codec.readPacket(this._obfuscation);\n  }\n}\nexports.ObfuscatedConnection = ObfuscatedConnection;\nclass PacketCodec {\n  constructor(connection) {\n    this._conn = connection;\n  }\n  encodePacket(data) {\n    throw new Error(\"Not Implemented\");\n    // Override\n  }\n  async readPacket(reader) {\n    // override\n    throw new Error(\"Not Implemented\");\n  }\n}\nexports.PacketCodec = PacketCodec;","map":{"version":3,"names":["Object","defineProperty","exports","value","ObfuscatedConnection","PacketCodec","Connection","extensions_1","require","constructor","ip","port","dcId","loggers","proxy","socket","testServers","_ip","_port","_dcId","_log","_proxy","_connected","_sendTask","undefined","_recvTask","_codec","_obfuscation","_sendArray","AsyncQueue","_recvArray","_testServers","_connect","debug","PacketCodecClass","connect","_initConn","_sendLoop","_recvLoop","disconnect","push","close","send","data","Error","recv","result","pop","_send","e","info","isConnected","_recv","tag","write","encodedPacket","encodePacket","readPacket","toString","name","replace","arguments","ObfuscatedIO","initHeader","header","connection","_conn","reader"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/network/connection/Connection.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObfuscatedConnection = exports.PacketCodec = exports.Connection = void 0;\nconst extensions_1 = require(\"../../extensions\");\n/**\n * The `Connection` class is a wrapper around ``asyncio.open_connection``.\n *\n * Subclasses will implement different transport modes as atomic operations,\n * which this class eases doing since the exposed interface simply puts and\n * gets complete data payloads to and from queues.\n *\n * The only error that will raise from send and receive methods is\n * ``ConnectionError``, which will raise when attempting to send if\n * the client is disconnected (includes remote disconnections).\n */\nclass Connection {\n    constructor({ ip, port, dcId, loggers, proxy, socket, testServers, }) {\n        this._ip = ip;\n        this._port = port;\n        this._dcId = dcId;\n        this._log = loggers;\n        this._proxy = proxy;\n        this._connected = false;\n        this._sendTask = undefined;\n        this._recvTask = undefined;\n        this._codec = undefined;\n        this._obfuscation = undefined; // TcpObfuscated and MTProxy\n        this._sendArray = new extensions_1.AsyncQueue();\n        this._recvArray = new extensions_1.AsyncQueue();\n        this.socket = new socket(proxy);\n        this._testServers = testServers;\n    }\n    async _connect() {\n        this._log.debug(\"Connecting\");\n        this._codec = new this.PacketCodecClass(this);\n        await this.socket.connect(this._port, this._ip, this._testServers);\n        this._log.debug(\"Finished connecting\");\n        // await this.socket.connect({host: this._ip, port: this._port});\n        await this._initConn();\n    }\n    async connect() {\n        await this._connect();\n        this._connected = true;\n        if (!this._sendTask) {\n            this._sendTask = this._sendLoop();\n        }\n        this._recvTask = this._recvLoop();\n    }\n    async disconnect() {\n        if (!this._connected) {\n            return;\n        }\n        this._connected = false;\n        void this._recvArray.push(undefined);\n        await this.socket.close();\n    }\n    async send(data) {\n        if (!this._connected) {\n            throw new Error(\"Not connected\");\n        }\n        await this._sendArray.push(data);\n    }\n    async recv() {\n        while (this._connected) {\n            const result = await this._recvArray.pop();\n            // null = sentinel value = keep trying\n            if (result) {\n                return result;\n            }\n        }\n        throw new Error(\"Not connected\");\n    }\n    async _sendLoop() {\n        try {\n            while (this._connected) {\n                const data = await this._sendArray.pop();\n                if (!data) {\n                    this._sendTask = undefined;\n                    return;\n                }\n                await this._send(data);\n            }\n        }\n        catch (e) {\n            this._log.info(\"The server closed the connection while sending\");\n        }\n    }\n    isConnected() {\n        return this._connected;\n    }\n    async _recvLoop() {\n        let data;\n        while (this._connected) {\n            try {\n                data = await this._recv();\n                if (!data) {\n                    throw new Error(\"no data received\");\n                }\n            }\n            catch (e) {\n                this._log.info(\"connection closed\");\n                // await this._recvArray.push()\n                this.disconnect();\n                return;\n            }\n            await this._recvArray.push(data);\n        }\n    }\n    async _initConn() {\n        if (this._codec.tag) {\n            await this.socket.write(this._codec.tag);\n        }\n    }\n    async _send(data) {\n        const encodedPacket = this._codec.encodePacket(data);\n        this.socket.write(encodedPacket);\n    }\n    async _recv() {\n        return await this._codec.readPacket(this.socket);\n    }\n    toString() {\n        return `${this._ip}:${this._port}/${this.constructor.name.replace(\"Connection\", \"\")}`;\n    }\n}\nexports.Connection = Connection;\nclass ObfuscatedConnection extends Connection {\n    constructor() {\n        super(...arguments);\n        this.ObfuscatedIO = undefined;\n    }\n    async _initConn() {\n        this._obfuscation = new this.ObfuscatedIO(this);\n        await this._obfuscation.initHeader();\n        this.socket.write(this._obfuscation.header);\n    }\n    async _send(data) {\n        this._obfuscation.write(this._codec.encodePacket(data));\n    }\n    async _recv() {\n        return await this._codec.readPacket(this._obfuscation);\n    }\n}\nexports.ObfuscatedConnection = ObfuscatedConnection;\nclass PacketCodec {\n    constructor(connection) {\n        this._conn = connection;\n    }\n    encodePacket(data) {\n        throw new Error(\"Not Implemented\");\n        // Override\n    }\n    async readPacket(reader) {\n        // override\n        throw new Error(\"Not Implemented\");\n    }\n}\nexports.PacketCodec = PacketCodec;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}