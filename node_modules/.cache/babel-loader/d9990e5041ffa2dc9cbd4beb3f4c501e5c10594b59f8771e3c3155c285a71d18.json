{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MTProtoPlainSender = void 0;\n/**\n *  This module contains the class used to communicate with Telegram's servers\n *  in plain text, when no authorization key has been created yet.\n */\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst MTProtoState_1 = require(\"./MTProtoState\");\nconst Helpers_1 = require(\"../Helpers\");\nconst errors_1 = require(\"../errors\");\nconst extensions_1 = require(\"../extensions\");\n/**\n * MTProto Mobile Protocol plain sender (https://core.telegram.org/mtproto/description#unencrypted-messages)\n */\nclass MTProtoPlainSender {\n  /**\n   * Initializes the MTProto plain sender.\n   * @param connection connection: the Connection to be used.\n   * @param loggers\n   */\n  constructor(connection, loggers) {\n    this._state = new MTProtoState_1.MTProtoState(undefined, loggers);\n    this._connection = connection;\n  }\n  /**\n   * Sends and receives the result for the given request.\n   * @param request\n   */\n  async send(request) {\n    let body = request.getBytes();\n    let msgId = this._state._getNewMsgId();\n    const m = (0, Helpers_1.toSignedLittleBuffer)(msgId, 8);\n    const b = Buffer.alloc(4);\n    b.writeInt32LE(body.length, 0);\n    const res = Buffer.concat([Buffer.concat([Buffer.alloc(8), m, b]), body]);\n    await this._connection.send(res);\n    body = await this._connection.recv();\n    if (body.length < 8) {\n      throw new errors_1.InvalidBufferError(body);\n    }\n    const reader = new extensions_1.BinaryReader(body);\n    const authKeyId = reader.readLong();\n    if (authKeyId.neq((0, big_integer_1.default)(0))) {\n      throw new Error(\"Bad authKeyId\");\n    }\n    msgId = reader.readLong();\n    if (msgId.eq((0, big_integer_1.default)(0))) {\n      throw new Error(\"Bad msgId\");\n    }\n    /** ^ We should make sure that the read ``msg_id`` is greater\n     * than our own ``msg_id``. However, under some circumstances\n     * (bad system clock/working behind proxies) this seems to not\n     * be the case, which would cause endless assertion errors.\n     */\n    const length = reader.readInt();\n    if (length <= 0) {\n      throw new Error(\"Bad length\");\n    }\n    /**\n     * We could read length bytes and use those in a new reader to read\n     * the next TLObject without including the padding, but since the\n     * reader isn't used for anything else after this, it's unnecessary.\n     */\n    return reader.tgReadObject();\n  }\n}\nexports.MTProtoPlainSender = MTProtoPlainSender;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}