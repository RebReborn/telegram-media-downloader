{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PromisedWebSockets = void 0;\nconst websocket_1 = require(\"websocket\");\nconst async_mutex_1 = require(\"async-mutex\");\nconst platform_1 = require(\"../platform\");\nconst mutex = new async_mutex_1.Mutex();\nconst closeError = new Error(\"WebSocket was closed\");\nclass PromisedWebSockets {\n  constructor() {\n    this.client = undefined;\n    this.stream = Buffer.alloc(0);\n    this.closed = true;\n  }\n  async readExactly(number) {\n    let readData = Buffer.alloc(0);\n    while (true) {\n      const thisTime = await this.read(number);\n      readData = Buffer.concat([readData, thisTime]);\n      number = number - thisTime.length;\n      if (!number) {\n        return readData;\n      }\n    }\n  }\n  async read(number) {\n    if (this.closed) {\n      throw closeError;\n    }\n    await this.canRead;\n    if (this.closed) {\n      throw closeError;\n    }\n    const toReturn = this.stream.slice(0, number);\n    this.stream = this.stream.slice(number);\n    if (this.stream.length === 0) {\n      this.canRead = new Promise(resolve => {\n        this.resolveRead = resolve;\n      });\n    }\n    return toReturn;\n  }\n  async readAll() {\n    if (this.closed || !(await this.canRead)) {\n      throw closeError;\n    }\n    const toReturn = this.stream;\n    this.stream = Buffer.alloc(0);\n    this.canRead = new Promise(resolve => {\n      this.resolveRead = resolve;\n    });\n    return toReturn;\n  }\n  getWebSocketLink(ip, port, testServers) {\n    if (port === 443) {\n      return `wss://${ip}:${port}/apiws${testServers ? \"_test\" : \"\"}`;\n    } else {\n      return `ws://${ip}:${port}/apiws${testServers ? \"_test\" : \"\"}`;\n    }\n  }\n  async connect(port, ip, testServers = false) {\n    this.stream = Buffer.alloc(0);\n    this.canRead = new Promise(resolve => {\n      this.resolveRead = resolve;\n    });\n    this.closed = false;\n    this.website = this.getWebSocketLink(ip, port, testServers);\n    this.client = new websocket_1.w3cwebsocket(this.website, \"binary\");\n    return new Promise((resolve, reject) => {\n      if (this.client) {\n        this.client.onopen = () => {\n          this.receive();\n          resolve(this);\n        };\n        this.client.onerror = error => {\n          reject(error);\n        };\n        this.client.onclose = () => {\n          if (this.resolveRead) {\n            this.resolveRead(false);\n          }\n          this.closed = true;\n        };\n        //CONTEST\n        if (platform_1.isBrowser) {\n          window.addEventListener(\"offline\", async () => {\n            await this.close();\n            if (this.resolveRead) {\n              this.resolveRead(false);\n            }\n          });\n        }\n      }\n    });\n  }\n  write(data) {\n    if (this.closed) {\n      throw closeError;\n    }\n    if (this.client) {\n      this.client.send(data);\n    }\n  }\n  async close() {\n    if (this.client) {\n      await this.client.close();\n    }\n    this.closed = true;\n  }\n  async receive() {\n    if (this.client) {\n      this.client.onmessage = async message => {\n        const release = await mutex.acquire();\n        try {\n          let data;\n          //CONTEST BROWSER\n          data = Buffer.from(await new Response(message.data).arrayBuffer());\n          this.stream = Buffer.concat([this.stream, data]);\n          if (this.resolveRead) {\n            this.resolveRead(true);\n          }\n        } finally {\n          release();\n        }\n      };\n    }\n  }\n  toString() {\n    return \"PromisedWebSocket\";\n  }\n}\nexports.PromisedWebSockets = PromisedWebSockets;","map":{"version":3,"names":["Object","defineProperty","exports","value","PromisedWebSockets","websocket_1","require","async_mutex_1","platform_1","mutex","Mutex","closeError","Error","constructor","client","undefined","stream","Buffer","alloc","closed","readExactly","number","readData","thisTime","read","concat","length","canRead","toReturn","slice","Promise","resolve","resolveRead","readAll","getWebSocketLink","ip","port","testServers","connect","website","w3cwebsocket","reject","onopen","receive","onerror","error","onclose","isBrowser","window","addEventListener","close","write","data","send","onmessage","message","release","acquire","from","Response","arrayBuffer","toString"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/extensions/PromisedWebSockets.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PromisedWebSockets = void 0;\nconst websocket_1 = require(\"websocket\");\nconst async_mutex_1 = require(\"async-mutex\");\nconst platform_1 = require(\"../platform\");\nconst mutex = new async_mutex_1.Mutex();\nconst closeError = new Error(\"WebSocket was closed\");\nclass PromisedWebSockets {\n    constructor() {\n        this.client = undefined;\n        this.stream = Buffer.alloc(0);\n        this.closed = true;\n    }\n    async readExactly(number) {\n        let readData = Buffer.alloc(0);\n        while (true) {\n            const thisTime = await this.read(number);\n            readData = Buffer.concat([readData, thisTime]);\n            number = number - thisTime.length;\n            if (!number) {\n                return readData;\n            }\n        }\n    }\n    async read(number) {\n        if (this.closed) {\n            throw closeError;\n        }\n        await this.canRead;\n        if (this.closed) {\n            throw closeError;\n        }\n        const toReturn = this.stream.slice(0, number);\n        this.stream = this.stream.slice(number);\n        if (this.stream.length === 0) {\n            this.canRead = new Promise((resolve) => {\n                this.resolveRead = resolve;\n            });\n        }\n        return toReturn;\n    }\n    async readAll() {\n        if (this.closed || !(await this.canRead)) {\n            throw closeError;\n        }\n        const toReturn = this.stream;\n        this.stream = Buffer.alloc(0);\n        this.canRead = new Promise((resolve) => {\n            this.resolveRead = resolve;\n        });\n        return toReturn;\n    }\n    getWebSocketLink(ip, port, testServers) {\n        if (port === 443) {\n            return `wss://${ip}:${port}/apiws${testServers ? \"_test\" : \"\"}`;\n        }\n        else {\n            return `ws://${ip}:${port}/apiws${testServers ? \"_test\" : \"\"}`;\n        }\n    }\n    async connect(port, ip, testServers = false) {\n        this.stream = Buffer.alloc(0);\n        this.canRead = new Promise((resolve) => {\n            this.resolveRead = resolve;\n        });\n        this.closed = false;\n        this.website = this.getWebSocketLink(ip, port, testServers);\n        this.client = new websocket_1.w3cwebsocket(this.website, \"binary\");\n        return new Promise((resolve, reject) => {\n            if (this.client) {\n                this.client.onopen = () => {\n                    this.receive();\n                    resolve(this);\n                };\n                this.client.onerror = (error) => {\n                    reject(error);\n                };\n                this.client.onclose = () => {\n                    if (this.resolveRead) {\n                        this.resolveRead(false);\n                    }\n                    this.closed = true;\n                };\n                //CONTEST\n                if (platform_1.isBrowser) {\n                    window.addEventListener(\"offline\", async () => {\n                        await this.close();\n                        if (this.resolveRead) {\n                            this.resolveRead(false);\n                        }\n                    });\n                }\n            }\n        });\n    }\n    write(data) {\n        if (this.closed) {\n            throw closeError;\n        }\n        if (this.client) {\n            this.client.send(data);\n        }\n    }\n    async close() {\n        if (this.client) {\n            await this.client.close();\n        }\n        this.closed = true;\n    }\n    async receive() {\n        if (this.client) {\n            this.client.onmessage = async (message) => {\n                const release = await mutex.acquire();\n                try {\n                    let data;\n                    //CONTEST BROWSER\n                    data = Buffer.from(await new Response(message.data).arrayBuffer());\n                    this.stream = Buffer.concat([this.stream, data]);\n                    if (this.resolveRead) {\n                        this.resolveRead(true);\n                    }\n                }\n                finally {\n                    release();\n                }\n            };\n        }\n    }\n    toString() {\n        return \"PromisedWebSocket\";\n    }\n}\nexports.PromisedWebSockets = PromisedWebSockets;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}