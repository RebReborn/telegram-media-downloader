{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.doAuthentication = doAuthentication;\nconst Helpers_1 = require(\"../Helpers\");\nconst tl_1 = require(\"../tl\");\nconst errors_1 = require(\"../errors\");\nconst Factorizator_1 = require(\"../crypto/Factorizator\");\nconst RSA_1 = require(\"../crypto/RSA\");\nconst IGE_1 = require(\"../crypto/IGE\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst extensions_1 = require(\"../extensions\");\nconst AuthKey_1 = require(\"../crypto/AuthKey\");\nconst RETRIES = 20;\nasync function doAuthentication(sender, log) {\n  // Step 1 sending: PQ Request, endianness doesn't matter since it's random\n  let bytes = (0, Helpers_1.generateRandomBytes)(16);\n  const nonce = (0, Helpers_1.readBigIntFromBuffer)(bytes, false, true);\n  const resPQ = await sender.send(new tl_1.Api.ReqPqMulti({\n    nonce\n  }));\n  log.debug(\"Starting authKey generation step 1\");\n  if (!(resPQ instanceof tl_1.Api.ResPQ)) {\n    throw new errors_1.SecurityError(`Step 1 answer was ${resPQ}`);\n  }\n  if (resPQ.nonce.neq(nonce)) {\n    throw new errors_1.SecurityError(\"Step 1 invalid nonce from server\");\n  }\n  const pq = (0, Helpers_1.readBigIntFromBuffer)(resPQ.pq, false, true);\n  log.debug(\"Finished authKey generation step 1\");\n  // Step 2 sending: DH Exchange\n  const {\n    p,\n    q\n  } = Factorizator_1.Factorizator.factorize(pq);\n  const pBuffer = (0, Helpers_1.getByteArray)(p);\n  const qBuffer = (0, Helpers_1.getByteArray)(q);\n  bytes = (0, Helpers_1.generateRandomBytes)(32);\n  const newNonce = (0, Helpers_1.readBigIntFromBuffer)(bytes, true, true);\n  const pqInnerData = new tl_1.Api.PQInnerData({\n    pq: (0, Helpers_1.getByteArray)(pq),\n    // unsigned\n    p: pBuffer,\n    q: qBuffer,\n    nonce: resPQ.nonce,\n    serverNonce: resPQ.serverNonce,\n    newNonce\n  }).getBytes();\n  if (pqInnerData.length > 144) {\n    throw new errors_1.SecurityError(\"Step 1 invalid nonce from server\");\n  }\n  let targetFingerprint;\n  let targetKey;\n  for (const fingerprint of resPQ.serverPublicKeyFingerprints) {\n    targetKey = RSA_1._serverKeys.get(fingerprint.toString());\n    if (targetKey !== undefined) {\n      targetFingerprint = fingerprint;\n      break;\n    }\n  }\n  if (targetFingerprint === undefined || targetKey === undefined) {\n    throw new errors_1.SecurityError(\"Step 2 could not find a valid key for fingerprints\");\n  }\n  // Value should be padded to be made 192 exactly\n  const padding = (0, Helpers_1.generateRandomBytes)(192 - pqInnerData.length);\n  const dataWithPadding = Buffer.concat([pqInnerData, padding]);\n  const dataPadReversed = Buffer.from(dataWithPadding).reverse();\n  let encryptedData;\n  for (let i = 0; i < RETRIES; i++) {\n    const tempKey = (0, Helpers_1.generateRandomBytes)(32);\n    const shaDigestKeyWithData = await (0, Helpers_1.sha256)(Buffer.concat([tempKey, dataWithPadding]));\n    const dataWithHash = Buffer.concat([dataPadReversed, shaDigestKeyWithData]);\n    const ige = new IGE_1.IGE(tempKey, Buffer.alloc(32));\n    const aesEncrypted = ige.encryptIge(dataWithHash);\n    const tempKeyXor = (0, Helpers_1.bufferXor)(tempKey, await (0, Helpers_1.sha256)(aesEncrypted));\n    const keyAesEncrypted = Buffer.concat([tempKeyXor, aesEncrypted]);\n    const keyAesEncryptedInt = (0, Helpers_1.readBigIntFromBuffer)(keyAesEncrypted, false, false);\n    if (keyAesEncryptedInt.greaterOrEquals(targetKey.n)) {\n      log.debug(\"Aes key greater than RSA. retrying\");\n      continue;\n    }\n    const encryptedDataBuffer = (0, Helpers_1.modExp)(keyAesEncryptedInt, (0, big_integer_1.default)(targetKey.e), targetKey.n);\n    encryptedData = (0, Helpers_1.readBufferFromBigInt)(encryptedDataBuffer, 256, false, false);\n    break;\n  }\n  if (encryptedData === undefined) {\n    throw new errors_1.SecurityError(\"Step 2 could create a secure encrypted key\");\n  }\n  log.debug(\"Step 2 : Generated a secure aes encrypted data\");\n  const serverDhParams = await sender.send(new tl_1.Api.ReqDHParams({\n    nonce: resPQ.nonce,\n    serverNonce: resPQ.serverNonce,\n    p: pBuffer,\n    q: qBuffer,\n    publicKeyFingerprint: targetFingerprint,\n    encryptedData\n  }));\n  if (!(serverDhParams instanceof tl_1.Api.ServerDHParamsOk || serverDhParams instanceof tl_1.Api.ServerDHParamsFail)) {\n    throw new Error(`Step 2.1 answer was ${serverDhParams}`);\n  }\n  if (serverDhParams.nonce.neq(resPQ.nonce)) {\n    throw new errors_1.SecurityError(\"Step 2 invalid nonce from server\");\n  }\n  if (serverDhParams.serverNonce.neq(resPQ.serverNonce)) {\n    throw new errors_1.SecurityError(\"Step 2 invalid server nonce from server\");\n  }\n  if (serverDhParams instanceof tl_1.Api.ServerDHParamsFail) {\n    const sh = await (0, Helpers_1.sha1)((0, Helpers_1.toSignedLittleBuffer)(newNonce, 32).slice(4, 20));\n    const nnh = (0, Helpers_1.readBigIntFromBuffer)(sh, true, true);\n    if (serverDhParams.newNonceHash.neq(nnh)) {\n      throw new errors_1.SecurityError(\"Step 2 invalid DH fail nonce from server\");\n    }\n  }\n  if (!(serverDhParams instanceof tl_1.Api.ServerDHParamsOk)) {\n    throw new Error(`Step 2.2 answer was ${serverDhParams}`);\n  }\n  log.debug(\"Finished authKey generation step 2\");\n  log.debug(\"Starting authKey generation step 3\");\n  // Step 3 sending: Complete DH Exchange\n  const {\n    key,\n    iv\n  } = await (0, Helpers_1.generateKeyDataFromNonce)(resPQ.serverNonce, newNonce);\n  if (serverDhParams.encryptedAnswer.length % 16 !== 0) {\n    // See PR#453\n    throw new errors_1.SecurityError(\"Step 3 AES block size mismatch\");\n  }\n  const ige = new IGE_1.IGE(key, iv);\n  const plainTextAnswer = ige.decryptIge(serverDhParams.encryptedAnswer);\n  const reader = new extensions_1.BinaryReader(plainTextAnswer);\n  reader.read(20); // hash sum\n  const serverDhInner = reader.tgReadObject();\n  if (!(serverDhInner instanceof tl_1.Api.ServerDHInnerData)) {\n    throw new Error(`Step 3 answer was ${serverDhInner}`);\n  }\n  if (serverDhInner.nonce.neq(resPQ.nonce)) {\n    throw new errors_1.SecurityError(\"Step 3 Invalid nonce in encrypted answer\");\n  }\n  if (serverDhInner.serverNonce.neq(resPQ.serverNonce)) {\n    throw new errors_1.SecurityError(\"Step 3 Invalid server nonce in encrypted answer\");\n  }\n  const dhPrime = (0, Helpers_1.readBigIntFromBuffer)(serverDhInner.dhPrime, false, false);\n  const ga = (0, Helpers_1.readBigIntFromBuffer)(serverDhInner.gA, false, false);\n  const timeOffset = serverDhInner.serverTime - Math.floor(new Date().getTime() / 1000);\n  const b = (0, Helpers_1.readBigIntFromBuffer)((0, Helpers_1.generateRandomBytes)(256), false, false);\n  const gb = (0, Helpers_1.modExp)((0, big_integer_1.default)(serverDhInner.g), b, dhPrime);\n  const gab = (0, Helpers_1.modExp)(ga, b, dhPrime);\n  // Prepare client DH Inner Data\n  const clientDhInner = new tl_1.Api.ClientDHInnerData({\n    nonce: resPQ.nonce,\n    serverNonce: resPQ.serverNonce,\n    retryId: big_integer_1.default.zero,\n    // TODO Actual retry ID\n    gB: (0, Helpers_1.getByteArray)(gb, false)\n  }).getBytes();\n  const clientDdhInnerHashed = Buffer.concat([await (0, Helpers_1.sha1)(clientDhInner), clientDhInner]);\n  // Encryption\n  const clientDhEncrypted = ige.encryptIge(clientDdhInnerHashed);\n  const dhGen = await sender.send(new tl_1.Api.SetClientDHParams({\n    nonce: resPQ.nonce,\n    serverNonce: resPQ.serverNonce,\n    encryptedData: clientDhEncrypted\n  }));\n  const nonceTypes = [tl_1.Api.DhGenOk, tl_1.Api.DhGenRetry, tl_1.Api.DhGenFail];\n  // TS being weird again.\n  const nonceTypesString = [\"DhGenOk\", \"DhGenRetry\", \"DhGenFail\"];\n  if (!(dhGen instanceof nonceTypes[0] || dhGen instanceof nonceTypes[1] || dhGen instanceof nonceTypes[2])) {\n    throw new Error(`Step 3.1 answer was ${dhGen}`);\n  }\n  const {\n    name\n  } = dhGen.constructor;\n  if (dhGen.nonce.neq(resPQ.nonce)) {\n    throw new errors_1.SecurityError(`Step 3 invalid ${name} nonce from server`);\n  }\n  if (dhGen.serverNonce.neq(resPQ.serverNonce)) {\n    throw new errors_1.SecurityError(`Step 3 invalid ${name} server nonce from server`);\n  }\n  const authKey = new AuthKey_1.AuthKey();\n  await authKey.setKey((0, Helpers_1.getByteArray)(gab));\n  const nonceNumber = 1 + nonceTypesString.indexOf(dhGen.className);\n  const newNonceHash = await authKey.calcNewNonceHash(newNonce, nonceNumber);\n  // @ts-ignore\n  const dhHash = dhGen[`newNonceHash${nonceNumber}`];\n  if (dhHash.neq(newNonceHash)) {\n    throw new errors_1.SecurityError(\"Step 3 invalid new nonce hash\");\n  }\n  if (!(dhGen instanceof tl_1.Api.DhGenOk)) {\n    throw new Error(`Step 3.2 answer was ${dhGen}`);\n  }\n  log.debug(\"Finished authKey generation step 3\");\n  return {\n    authKey,\n    timeOffset\n  };\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","doAuthentication","Helpers_1","require","tl_1","errors_1","Factorizator_1","RSA_1","IGE_1","big_integer_1","extensions_1","AuthKey_1","RETRIES","sender","log","bytes","generateRandomBytes","nonce","readBigIntFromBuffer","resPQ","send","Api","ReqPqMulti","debug","ResPQ","SecurityError","neq","pq","p","q","Factorizator","factorize","pBuffer","getByteArray","qBuffer","newNonce","pqInnerData","PQInnerData","serverNonce","getBytes","length","targetFingerprint","targetKey","fingerprint","serverPublicKeyFingerprints","_serverKeys","get","toString","undefined","padding","dataWithPadding","Buffer","concat","dataPadReversed","from","reverse","encryptedData","i","tempKey","shaDigestKeyWithData","sha256","dataWithHash","ige","IGE","alloc","aesEncrypted","encryptIge","tempKeyXor","bufferXor","keyAesEncrypted","keyAesEncryptedInt","greaterOrEquals","n","encryptedDataBuffer","modExp","default","e","readBufferFromBigInt","serverDhParams","ReqDHParams","publicKeyFingerprint","ServerDHParamsOk","ServerDHParamsFail","Error","sh","sha1","toSignedLittleBuffer","slice","nnh","newNonceHash","key","iv","generateKeyDataFromNonce","encryptedAnswer","plainTextAnswer","decryptIge","reader","BinaryReader","read","serverDhInner","tgReadObject","ServerDHInnerData","dhPrime","ga","gA","timeOffset","serverTime","Math","floor","Date","getTime","b","gb","g","gab","clientDhInner","ClientDHInnerData","retryId","zero","gB","clientDdhInnerHashed","clientDhEncrypted","dhGen","SetClientDHParams","nonceTypes","DhGenOk","DhGenRetry","DhGenFail","nonceTypesString","name","constructor","authKey","AuthKey","setKey","nonceNumber","indexOf","className","calcNewNonceHash","dhHash"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/network/Authenticator.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.doAuthentication = doAuthentication;\nconst Helpers_1 = require(\"../Helpers\");\nconst tl_1 = require(\"../tl\");\nconst errors_1 = require(\"../errors\");\nconst Factorizator_1 = require(\"../crypto/Factorizator\");\nconst RSA_1 = require(\"../crypto/RSA\");\nconst IGE_1 = require(\"../crypto/IGE\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst extensions_1 = require(\"../extensions\");\nconst AuthKey_1 = require(\"../crypto/AuthKey\");\nconst RETRIES = 20;\nasync function doAuthentication(sender, log) {\n    // Step 1 sending: PQ Request, endianness doesn't matter since it's random\n    let bytes = (0, Helpers_1.generateRandomBytes)(16);\n    const nonce = (0, Helpers_1.readBigIntFromBuffer)(bytes, false, true);\n    const resPQ = await sender.send(new tl_1.Api.ReqPqMulti({ nonce }));\n    log.debug(\"Starting authKey generation step 1\");\n    if (!(resPQ instanceof tl_1.Api.ResPQ)) {\n        throw new errors_1.SecurityError(`Step 1 answer was ${resPQ}`);\n    }\n    if (resPQ.nonce.neq(nonce)) {\n        throw new errors_1.SecurityError(\"Step 1 invalid nonce from server\");\n    }\n    const pq = (0, Helpers_1.readBigIntFromBuffer)(resPQ.pq, false, true);\n    log.debug(\"Finished authKey generation step 1\");\n    // Step 2 sending: DH Exchange\n    const { p, q } = Factorizator_1.Factorizator.factorize(pq);\n    const pBuffer = (0, Helpers_1.getByteArray)(p);\n    const qBuffer = (0, Helpers_1.getByteArray)(q);\n    bytes = (0, Helpers_1.generateRandomBytes)(32);\n    const newNonce = (0, Helpers_1.readBigIntFromBuffer)(bytes, true, true);\n    const pqInnerData = new tl_1.Api.PQInnerData({\n        pq: (0, Helpers_1.getByteArray)(pq), // unsigned\n        p: pBuffer,\n        q: qBuffer,\n        nonce: resPQ.nonce,\n        serverNonce: resPQ.serverNonce,\n        newNonce,\n    }).getBytes();\n    if (pqInnerData.length > 144) {\n        throw new errors_1.SecurityError(\"Step 1 invalid nonce from server\");\n    }\n    let targetFingerprint;\n    let targetKey;\n    for (const fingerprint of resPQ.serverPublicKeyFingerprints) {\n        targetKey = RSA_1._serverKeys.get(fingerprint.toString());\n        if (targetKey !== undefined) {\n            targetFingerprint = fingerprint;\n            break;\n        }\n    }\n    if (targetFingerprint === undefined || targetKey === undefined) {\n        throw new errors_1.SecurityError(\"Step 2 could not find a valid key for fingerprints\");\n    }\n    // Value should be padded to be made 192 exactly\n    const padding = (0, Helpers_1.generateRandomBytes)(192 - pqInnerData.length);\n    const dataWithPadding = Buffer.concat([pqInnerData, padding]);\n    const dataPadReversed = Buffer.from(dataWithPadding).reverse();\n    let encryptedData;\n    for (let i = 0; i < RETRIES; i++) {\n        const tempKey = (0, Helpers_1.generateRandomBytes)(32);\n        const shaDigestKeyWithData = await (0, Helpers_1.sha256)(Buffer.concat([tempKey, dataWithPadding]));\n        const dataWithHash = Buffer.concat([\n            dataPadReversed,\n            shaDigestKeyWithData,\n        ]);\n        const ige = new IGE_1.IGE(tempKey, Buffer.alloc(32));\n        const aesEncrypted = ige.encryptIge(dataWithHash);\n        const tempKeyXor = (0, Helpers_1.bufferXor)(tempKey, await (0, Helpers_1.sha256)(aesEncrypted));\n        const keyAesEncrypted = Buffer.concat([tempKeyXor, aesEncrypted]);\n        const keyAesEncryptedInt = (0, Helpers_1.readBigIntFromBuffer)(keyAesEncrypted, false, false);\n        if (keyAesEncryptedInt.greaterOrEquals(targetKey.n)) {\n            log.debug(\"Aes key greater than RSA. retrying\");\n            continue;\n        }\n        const encryptedDataBuffer = (0, Helpers_1.modExp)(keyAesEncryptedInt, (0, big_integer_1.default)(targetKey.e), targetKey.n);\n        encryptedData = (0, Helpers_1.readBufferFromBigInt)(encryptedDataBuffer, 256, false, false);\n        break;\n    }\n    if (encryptedData === undefined) {\n        throw new errors_1.SecurityError(\"Step 2 could create a secure encrypted key\");\n    }\n    log.debug(\"Step 2 : Generated a secure aes encrypted data\");\n    const serverDhParams = await sender.send(new tl_1.Api.ReqDHParams({\n        nonce: resPQ.nonce,\n        serverNonce: resPQ.serverNonce,\n        p: pBuffer,\n        q: qBuffer,\n        publicKeyFingerprint: targetFingerprint,\n        encryptedData,\n    }));\n    if (!(serverDhParams instanceof tl_1.Api.ServerDHParamsOk ||\n        serverDhParams instanceof tl_1.Api.ServerDHParamsFail)) {\n        throw new Error(`Step 2.1 answer was ${serverDhParams}`);\n    }\n    if (serverDhParams.nonce.neq(resPQ.nonce)) {\n        throw new errors_1.SecurityError(\"Step 2 invalid nonce from server\");\n    }\n    if (serverDhParams.serverNonce.neq(resPQ.serverNonce)) {\n        throw new errors_1.SecurityError(\"Step 2 invalid server nonce from server\");\n    }\n    if (serverDhParams instanceof tl_1.Api.ServerDHParamsFail) {\n        const sh = await (0, Helpers_1.sha1)((0, Helpers_1.toSignedLittleBuffer)(newNonce, 32).slice(4, 20));\n        const nnh = (0, Helpers_1.readBigIntFromBuffer)(sh, true, true);\n        if (serverDhParams.newNonceHash.neq(nnh)) {\n            throw new errors_1.SecurityError(\"Step 2 invalid DH fail nonce from server\");\n        }\n    }\n    if (!(serverDhParams instanceof tl_1.Api.ServerDHParamsOk)) {\n        throw new Error(`Step 2.2 answer was ${serverDhParams}`);\n    }\n    log.debug(\"Finished authKey generation step 2\");\n    log.debug(\"Starting authKey generation step 3\");\n    // Step 3 sending: Complete DH Exchange\n    const { key, iv } = await (0, Helpers_1.generateKeyDataFromNonce)(resPQ.serverNonce, newNonce);\n    if (serverDhParams.encryptedAnswer.length % 16 !== 0) {\n        // See PR#453\n        throw new errors_1.SecurityError(\"Step 3 AES block size mismatch\");\n    }\n    const ige = new IGE_1.IGE(key, iv);\n    const plainTextAnswer = ige.decryptIge(serverDhParams.encryptedAnswer);\n    const reader = new extensions_1.BinaryReader(plainTextAnswer);\n    reader.read(20); // hash sum\n    const serverDhInner = reader.tgReadObject();\n    if (!(serverDhInner instanceof tl_1.Api.ServerDHInnerData)) {\n        throw new Error(`Step 3 answer was ${serverDhInner}`);\n    }\n    if (serverDhInner.nonce.neq(resPQ.nonce)) {\n        throw new errors_1.SecurityError(\"Step 3 Invalid nonce in encrypted answer\");\n    }\n    if (serverDhInner.serverNonce.neq(resPQ.serverNonce)) {\n        throw new errors_1.SecurityError(\"Step 3 Invalid server nonce in encrypted answer\");\n    }\n    const dhPrime = (0, Helpers_1.readBigIntFromBuffer)(serverDhInner.dhPrime, false, false);\n    const ga = (0, Helpers_1.readBigIntFromBuffer)(serverDhInner.gA, false, false);\n    const timeOffset = serverDhInner.serverTime - Math.floor(new Date().getTime() / 1000);\n    const b = (0, Helpers_1.readBigIntFromBuffer)((0, Helpers_1.generateRandomBytes)(256), false, false);\n    const gb = (0, Helpers_1.modExp)((0, big_integer_1.default)(serverDhInner.g), b, dhPrime);\n    const gab = (0, Helpers_1.modExp)(ga, b, dhPrime);\n    // Prepare client DH Inner Data\n    const clientDhInner = new tl_1.Api.ClientDHInnerData({\n        nonce: resPQ.nonce,\n        serverNonce: resPQ.serverNonce,\n        retryId: big_integer_1.default.zero, // TODO Actual retry ID\n        gB: (0, Helpers_1.getByteArray)(gb, false),\n    }).getBytes();\n    const clientDdhInnerHashed = Buffer.concat([\n        await (0, Helpers_1.sha1)(clientDhInner),\n        clientDhInner,\n    ]);\n    // Encryption\n    const clientDhEncrypted = ige.encryptIge(clientDdhInnerHashed);\n    const dhGen = await sender.send(new tl_1.Api.SetClientDHParams({\n        nonce: resPQ.nonce,\n        serverNonce: resPQ.serverNonce,\n        encryptedData: clientDhEncrypted,\n    }));\n    const nonceTypes = [tl_1.Api.DhGenOk, tl_1.Api.DhGenRetry, tl_1.Api.DhGenFail];\n    // TS being weird again.\n    const nonceTypesString = [\"DhGenOk\", \"DhGenRetry\", \"DhGenFail\"];\n    if (!(dhGen instanceof nonceTypes[0] ||\n        dhGen instanceof nonceTypes[1] ||\n        dhGen instanceof nonceTypes[2])) {\n        throw new Error(`Step 3.1 answer was ${dhGen}`);\n    }\n    const { name } = dhGen.constructor;\n    if (dhGen.nonce.neq(resPQ.nonce)) {\n        throw new errors_1.SecurityError(`Step 3 invalid ${name} nonce from server`);\n    }\n    if (dhGen.serverNonce.neq(resPQ.serverNonce)) {\n        throw new errors_1.SecurityError(`Step 3 invalid ${name} server nonce from server`);\n    }\n    const authKey = new AuthKey_1.AuthKey();\n    await authKey.setKey((0, Helpers_1.getByteArray)(gab));\n    const nonceNumber = 1 + nonceTypesString.indexOf(dhGen.className);\n    const newNonceHash = await authKey.calcNewNonceHash(newNonce, nonceNumber);\n    // @ts-ignore\n    const dhHash = dhGen[`newNonceHash${nonceNumber}`];\n    if (dhHash.neq(newNonceHash)) {\n        throw new errors_1.SecurityError(\"Step 3 invalid new nonce hash\");\n    }\n    if (!(dhGen instanceof tl_1.Api.DhGenOk)) {\n        throw new Error(`Step 3.2 answer was ${dhGen}`);\n    }\n    log.debug(\"Finished authKey generation step 3\");\n    return { authKey, timeOffset };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}