{"ast":null,"code":"var S = new Uint8Array(256);\nvar Si = new Uint8Array(256);\nvar T1 = new Uint32Array(256);\nvar T2 = new Uint32Array(256);\nvar T3 = new Uint32Array(256);\nvar T4 = new Uint32Array(256);\nvar T5 = new Uint32Array(256);\nvar T6 = new Uint32Array(256);\nvar T7 = new Uint32Array(256);\nvar T8 = new Uint32Array(256);\nfunction computeTables() {\n  var d = new Uint8Array(256);\n  var t = new Uint8Array(256);\n  var x2;\n  var x4;\n  var x8;\n  var s;\n  var tEnc;\n  var tDec;\n  var x = 0;\n  var xInv = 0;\n  // Compute double and third tables\n  for (var i = 0; i < 256; i++) {\n    d[i] = i << 1 ^ (i >> 7) * 283;\n    t[d[i] ^ i] = i;\n  }\n  for (; !S[x]; x ^= x2 || 1) {\n    // Compute sbox\n    s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\n    s = s >> 8 ^ s & 255 ^ 99;\n    S[x] = s;\n    Si[s] = x;\n    // Compute MixColumns\n    x8 = d[x4 = d[x2 = d[x]]];\n    tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n    tEnc = d[s] * 0x101 ^ s * 0x1010100;\n    T1[x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n    T2[x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n    T3[x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n    T4[x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n    T5[s] = tDec = tDec << 24 ^ tDec >>> 8;\n    T6[s] = tDec = tDec << 24 ^ tDec >>> 8;\n    T7[s] = tDec = tDec << 24 ^ tDec >>> 8;\n    T8[s] = tDec = tDec << 24 ^ tDec >>> 8;\n    xInv = t[xInv] || 1;\n  }\n}\n\n/**\n * Gets a uint32 from string in big-endian order order\n */\nfunction s2i(str, pos) {\n  return str.charCodeAt(pos) << 24 ^ str.charCodeAt(pos + 1) << 16 ^ str.charCodeAt(pos + 2) << 8 ^ str.charCodeAt(pos + 3);\n}\n\n/* eslint-disable import/prefer-default-export */\n/**\n * Helper function for transforming string key to Uint32Array\n */\nfunction getWords(key) {\n  if (key instanceof Uint32Array) {\n    return key;\n  }\n  if (typeof key === 'string') {\n    if (key.length % 4 !== 0) for (var i = key.length % 4; i <= 4; i++) key += '\\0x00';\n    var buf = new Uint32Array(key.length / 4);\n    for (var i = 0; i < key.length; i += 4) buf[i / 4] = s2i(key, i);\n    return buf;\n  }\n  if (key instanceof Uint8Array) {\n    var buf = new Uint32Array(key.length / 4);\n    for (var i = 0; i < key.length; i += 4) {\n      buf[i / 4] = key[i] << 24 ^ key[i + 1] << 16 ^ key[i + 2] << 8 ^ key[i + 3];\n    }\n    return buf;\n  }\n  throw new Error('Unable to create 32-bit words');\n}\nfunction xor(left, right, to) {\n  if (to === void 0) {\n    to = left;\n  }\n  for (var i = 0; i < left.length; i++) to[i] = left[i] ^ right[i];\n}\ncomputeTables();\n/**\n * Low-level AES Cipher\n */\nvar AES = /** @class */function () {\n  function AES(_key) {\n    var key = getWords(_key);\n    if (key.length !== 4 && key.length !== 6 && key.length !== 8) {\n      throw new Error('Invalid key size');\n    }\n    this.encKey = new Uint32Array(4 * key.length + 28);\n    this.decKey = new Uint32Array(4 * key.length + 28);\n    this.encKey.set(key);\n    var rcon = 1;\n    var i = key.length;\n    var tmp;\n    // schedule encryption keys\n    for (; i < 4 * key.length + 28; i++) {\n      tmp = this.encKey[i - 1];\n      // apply sbox\n      if (i % key.length === 0 || key.length === 8 && i % key.length === 4) {\n        tmp = S[tmp >>> 24] << 24 ^ S[tmp >> 16 & 255] << 16 ^ S[tmp >> 8 & 255] << 8 ^ S[tmp & 255];\n        // shift rows and add rcon\n        if (i % key.length === 0) {\n          tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\n          rcon = rcon << 1 ^ (rcon >> 7) * 283;\n        }\n      }\n      this.encKey[i] = this.encKey[i - key.length] ^ tmp;\n    }\n    // schedule decryption keys\n    for (var j = 0; i; j++, i--) {\n      tmp = this.encKey[j & 3 ? i : i - 4];\n      if (i <= 4 || j < 4) {\n        this.decKey[j] = tmp;\n      } else {\n        this.decKey[j] = T5[S[tmp >>> 24]] ^ T6[S[tmp >> 16 & 255]] ^ T7[S[tmp >> 8 & 255]] ^ T8[S[tmp & 255]];\n      }\n    }\n  }\n  AES.prototype.encrypt = function (_message) {\n    var message = getWords(_message);\n    var out = new Uint32Array(4);\n    var a = message[0] ^ this.encKey[0];\n    var b = message[1] ^ this.encKey[1];\n    var c = message[2] ^ this.encKey[2];\n    var d = message[3] ^ this.encKey[3];\n    var rounds = this.encKey.length / 4 - 2;\n    var k = 4;\n    var a2;\n    var b2;\n    var c2;\n    // Inner rounds.  Cribbed from OpenSSL.\n    for (var i = 0; i < rounds; i++) {\n      a2 = T1[a >>> 24] ^ T2[b >> 16 & 255] ^ T3[c >> 8 & 255] ^ T4[d & 255] ^ this.encKey[k];\n      b2 = T1[b >>> 24] ^ T2[c >> 16 & 255] ^ T3[d >> 8 & 255] ^ T4[a & 255] ^ this.encKey[k + 1];\n      c2 = T1[c >>> 24] ^ T2[d >> 16 & 255] ^ T3[a >> 8 & 255] ^ T4[b & 255] ^ this.encKey[k + 2];\n      d = T1[d >>> 24] ^ T2[a >> 16 & 255] ^ T3[b >> 8 & 255] ^ T4[c & 255] ^ this.encKey[k + 3];\n      a = a2;\n      b = b2;\n      c = c2;\n      k += 4;\n      // console.log(a, b, c, d);\n    }\n    // Last round.\n    for (var i = 0; i < 4; i++) {\n      out[i] = S[a >>> 24] << 24 ^ S[b >> 16 & 255] << 16 ^ S[c >> 8 & 255] << 8 ^ S[d & 255] ^ this.encKey[k++];\n      a2 = a;\n      a = b;\n      b = c;\n      c = d;\n      d = a2;\n    }\n    return out;\n  };\n  AES.prototype.decrypt = function (_message) {\n    var message = getWords(_message);\n    var out = new Uint32Array(4);\n    var a = message[0] ^ this.decKey[0];\n    var b = message[3] ^ this.decKey[1];\n    var c = message[2] ^ this.decKey[2];\n    var d = message[1] ^ this.decKey[3];\n    var rounds = this.decKey.length / 4 - 2;\n    var a2;\n    var b2;\n    var c2;\n    var k = 4;\n    // Inner rounds.  Cribbed from OpenSSL.\n    for (var i = 0; i < rounds; i++) {\n      a2 = T5[a >>> 24] ^ T6[b >> 16 & 255] ^ T7[c >> 8 & 255] ^ T8[d & 255] ^ this.decKey[k];\n      b2 = T5[b >>> 24] ^ T6[c >> 16 & 255] ^ T7[d >> 8 & 255] ^ T8[a & 255] ^ this.decKey[k + 1];\n      c2 = T5[c >>> 24] ^ T6[d >> 16 & 255] ^ T7[a >> 8 & 255] ^ T8[b & 255] ^ this.decKey[k + 2];\n      d = T5[d >>> 24] ^ T6[a >> 16 & 255] ^ T7[b >> 8 & 255] ^ T8[c & 255] ^ this.decKey[k + 3];\n      a = a2;\n      b = b2;\n      c = c2;\n      k += 4;\n    }\n    // Last round.\n    for (var i = 0; i < 4; i++) {\n      out[3 & -i] = Si[a >>> 24] << 24 ^ Si[b >> 16 & 255] << 16 ^ Si[c >> 8 & 255] << 8 ^ Si[d & 255] ^ this.decKey[k++];\n      a2 = a;\n      a = b;\n      b = c;\n      c = d;\n      d = a2;\n    }\n    return out;\n  };\n  return AES;\n}();\n\n/**\n * AES-IGE mode.\n */\nvar AES_IGE = /** @class */function () {\n  function AES_IGE(key, iv, blockSize) {\n    if (blockSize === void 0) {\n      blockSize = 16;\n    }\n    this.key = getWords(key);\n    this.iv = getWords(iv);\n    this.cipher = new AES(key);\n    this.blockSize = blockSize / 4;\n  }\n  /**\n   * Encrypts plain text with AES-IGE mode.\n   */\n  AES_IGE.prototype.encrypt = function (message, buf) {\n    var text = getWords(message);\n    var cipherText = buf || new Uint32Array(text.length);\n    var prevX = this.iv.subarray(this.blockSize, this.iv.length);\n    var prevY = this.iv.subarray(0, this.blockSize);\n    var yXOR = new Uint32Array(this.blockSize);\n    for (var i = 0; i < text.length; i += this.blockSize) {\n      var x = text.subarray(i, i + this.blockSize);\n      xor(x, prevY, yXOR);\n      var y = this.cipher.encrypt(yXOR);\n      xor(y, prevX);\n      prevX = x;\n      prevY = y;\n      for (var j = i, k = 0; j < text.length && k < 4; j++, k++) cipherText[j] = y[k];\n    }\n    return cipherText;\n  };\n  /**\n   * Decrypts cipher text with AES-IGE mode.\n   */\n  AES_IGE.prototype.decrypt = function (message, buf) {\n    var cipherText = getWords(message);\n    var text = buf || new Uint32Array(cipherText.length);\n    var prevY = this.iv.subarray(this.blockSize, this.iv.length);\n    var prevX = this.iv.subarray(0, this.blockSize);\n    var yXOR = new Uint32Array(this.blockSize);\n    for (var i = 0; i < text.length; i += this.blockSize) {\n      var x = cipherText.subarray(i, i + this.blockSize);\n      xor(x, prevY, yXOR);\n      var y = this.cipher.decrypt(yXOR);\n      xor(y, prevX);\n      prevX = x;\n      prevY = y;\n      for (var j = i, k = 0; j < text.length && k < 4; j++, k++) text[j] = y[k];\n    }\n    return text;\n  };\n  return AES_IGE;\n}();\n\n/**\n * AES-IGE mode.\n */\nvar AES_IGE$1 = /** @class */function () {\n  function AES_IGE(key, counter, blockSize) {\n    if (blockSize === void 0) {\n      blockSize = 16;\n    }\n    this.offset = 0;\n    this.key = getWords(key);\n    this.counter = getWords(counter);\n    this.cipher = new AES(key);\n    this.blockSize = blockSize / 4;\n    if (this.counter.length !== 4) {\n      throw new Error('AES-CTR mode counter must be 16 bytes length');\n    }\n  }\n  /**\n   * Encrypts plain text with AES-IGE mode.\n   */\n  AES_IGE.prototype.encrypt = function (message, buf) {\n    var text = getWords(message);\n    var cipherText = buf || new Uint32Array(text.length);\n    var offset = this.offset;\n    for (var i = 0; i < text.length; i += this.blockSize) {\n      var x = this.cipher.encrypt(this.counter);\n      for (var j = i, k = offset; j < text.length && k < this.blockSize; j++, k++) cipherText[j] = x[k] ^ text[j];\n      if (text.length - i >= this.blockSize) this.incrementCounter();\n      if (offset) {\n        i -= offset;\n        offset = 0;\n      }\n    }\n    this.offset = (this.offset + text.length % 4) % 4;\n    return cipherText;\n  };\n  /**\n   * Decrypts cipher text with AES-IGE mode.\n   */\n  AES_IGE.prototype.decrypt = function (message, buf) {\n    return this.encrypt(message, buf);\n  };\n  AES_IGE.prototype.incrementCounter = function () {\n    // increment counter\n    for (var carry = this.counter.length - 1; carry >= 0; carry--) {\n      if (++this.counter[carry] < 0xFFFFFFFF) break; // If overflowing, it'll be 0 and we'll have to continue propagating the carry\n    }\n  };\n  return AES_IGE;\n}();\nexport default AES;\nexport { AES_IGE$1 as CTR, AES_IGE as IGE };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}