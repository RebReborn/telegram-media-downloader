{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GenericDownloadIter = exports.DirectDownloadIter = void 0;\nexports.iterDownload = iterDownload;\nexports.downloadFileV2 = downloadFileV2;\nexports.downloadMedia = downloadMedia;\nexports._downloadDocument = _downloadDocument;\nexports._downloadContact = _downloadContact;\nexports._downloadWebDocument = _downloadWebDocument;\nexports._downloadCachedPhotoSize = _downloadCachedPhotoSize;\nexports._downloadPhoto = _downloadPhoto;\nexports.downloadProfilePhoto = downloadProfilePhoto;\nconst tl_1 = require(\"../tl\");\nconst Utils_1 = require(\"../Utils\");\nconst Helpers_1 = require(\"../Helpers\");\nconst __1 = require(\"../\");\nconst requestIter_1 = require(\"../requestIter\");\nconst errors_1 = require(\"../errors\");\nconst fs_1 = require(\"./fs\");\nconst extensions_1 = require(\"../extensions\");\nconst fs = __importStar(require(\"./fs\"));\nconst path_1 = __importDefault(require(\"./path\"));\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\n// All types\nconst sizeTypes = [\"w\", \"y\", \"d\", \"x\", \"c\", \"m\", \"b\", \"a\", \"s\"];\n// Chunk sizes for `upload.getFile` must be multiple of the smallest size\nconst MIN_CHUNK_SIZE = 4096;\nconst DEFAULT_CHUNK_SIZE = 64; // kb\nconst ONE_MB = 1024 * 1024;\nconst REQUEST_TIMEOUT = 15000;\nconst DISCONNECT_SLEEP = 1000;\nconst TIMED_OUT_SLEEP = 1000;\nconst MAX_CHUNK_SIZE = 512 * 1024;\nclass DirectDownloadIter extends requestIter_1.RequestIter {\n  constructor() {\n    super(...arguments);\n    this._timedOut = false;\n  }\n  async _init(_ref) {\n    let {\n      fileLocation,\n      dcId,\n      offset,\n      stride,\n      chunkSize,\n      requestSize,\n      fileSize,\n      msgData\n    } = _ref;\n    this.request = new tl_1.Api.upload.GetFile({\n      location: fileLocation,\n      offset,\n      limit: requestSize\n    });\n    this.total = fileSize;\n    this._stride = stride;\n    this._chunkSize = chunkSize;\n    this._lastPart = undefined;\n    //this._msgData = msgData;\n    this._timedOut = false;\n    this._sender = await this.client.getSender(dcId);\n  }\n  async _loadNextChunk() {\n    const current = await this._request();\n    this.buffer.push(current);\n    if (current.length < this.request.limit) {\n      // we finished downloading\n      this.left = this.buffer.length;\n      await this.close();\n      return true;\n    } else {\n      this.request.offset = this.request.offset.add(this._stride);\n    }\n  }\n  async _request() {\n    try {\n      this._sender = await this.client.getSender(this._sender.dcId);\n      const result = await this.client.invokeWithSender(this.request, this._sender);\n      this._timedOut = false;\n      if (result instanceof tl_1.Api.upload.FileCdnRedirect) {\n        throw new Error(\"CDN Not supported. Please Add an issue in github\");\n      }\n      return result.bytes;\n    } catch (e) {\n      if (e.errorMessage == \"TIMEOUT\") {\n        if (this._timedOut) {\n          this.client._log.warn(\"Got two timeouts in a row while downloading file\");\n          throw e;\n        }\n        this._timedOut = true;\n        this.client._log.info(\"Got timeout while downloading file, retrying once\");\n        await (0, Helpers_1.sleep)(TIMED_OUT_SLEEP);\n        return await this._request();\n      } else if (e instanceof errors_1.FileMigrateError) {\n        this.client._log.info(\"File lives in another DC\");\n        this._sender = await this.client.getSender(e.newDc);\n        return await this._request();\n      } else if (e.errorMessage == \"FILEREF_UPGRADE_NEEDED\") {\n        // TODO later\n        throw e;\n      } else {\n        throw e;\n      }\n    }\n  }\n  async close() {\n    this.client._log.debug(\"Finished downloading file ...\");\n  }\n  [Symbol.asyncIterator]() {\n    return super[Symbol.asyncIterator]();\n  }\n}\nexports.DirectDownloadIter = DirectDownloadIter;\nclass GenericDownloadIter extends DirectDownloadIter {\n  async _loadNextChunk() {\n    // 1. Fetch enough for one chunk\n    let data = Buffer.alloc(0);\n    //  1.1. ``bad`` is how much into the data we have we need to offset\n    const bad = this.request.offset.mod(this.request.limit).toJSNumber();\n    const before = this.request.offset;\n    // 1.2. We have to fetch from a valid offset, so remove that bad part\n    this.request.offset = this.request.offset.subtract(bad);\n    let done = false;\n    while (!done && data.length - bad < this._chunkSize) {\n      const current = await this._request();\n      this.request.offset = this.request.offset.add(this.request.limit);\n      data = Buffer.concat([data, current]);\n      done = current.length < this.request.limit;\n    }\n    // 1.3 Restore our last desired offset\n    this.request.offset = before;\n    // 2. Fill the buffer with the data we have\n    // 2.1. The current chunk starts at ``bad`` offset into the data,\n    //  and each new chunk is ``stride`` bytes apart of the other\n    for (let i = bad; i < data.length; i += this._stride) {\n      this.buffer.push(data.slice(i, i + this._chunkSize));\n      // 2.2. We will yield this offset, so move to the next one\n      this.request.offset = this.request.offset.add(this._stride);\n    }\n    // 2.3. If we are in the last chunk, we will return the last partial data\n    if (done) {\n      this.left = this.buffer.length;\n      await this.close();\n      return;\n    }\n    // 2.4 If we are not done, we can't return incomplete chunks.\n    if (this.buffer[this.buffer.length - 1].length != this._chunkSize) {\n      this._lastPart = this.buffer.pop();\n      //   3. Be careful with the offsets. Re-fetching a bit of data\n      //   is fine, since it greatly simplifies things.\n      // TODO Try to not re-fetch data\n      this.request.offset = this.request.offset.subtract(this._stride);\n    }\n  }\n}\nexports.GenericDownloadIter = GenericDownloadIter;\n/** @hidden */\nfunction iterDownload(client, _ref2) {\n  let {\n    file,\n    offset = big_integer_1.default.zero,\n    stride,\n    limit,\n    chunkSize,\n    requestSize = MAX_CHUNK_SIZE,\n    fileSize,\n    dcId,\n    msgData\n  } = _ref2;\n  // we're ignoring here to make it more flexible (which is probably a bad idea)\n  // @ts-ignore\n  const info = __1.utils.getFileInfo(file);\n  if (info.dcId != undefined) {\n    dcId = info.dcId;\n  }\n  if (fileSize == undefined) {\n    fileSize = info.size;\n  }\n  file = info.location;\n  if (chunkSize == undefined) {\n    chunkSize = requestSize;\n  }\n  if (limit == undefined && fileSize != undefined) {\n    limit = Math.floor(fileSize.add(chunkSize).subtract(1).divide(chunkSize).toJSNumber());\n  }\n  if (stride == undefined) {\n    stride = chunkSize;\n  } else if (stride < chunkSize) {\n    throw new Error(\"Stride must be >= chunkSize\");\n  }\n  requestSize -= requestSize % MIN_CHUNK_SIZE;\n  if (requestSize < MIN_CHUNK_SIZE) {\n    requestSize = MIN_CHUNK_SIZE;\n  } else if (requestSize > MAX_CHUNK_SIZE) {\n    requestSize = MAX_CHUNK_SIZE;\n  }\n  let cls;\n  if (chunkSize == requestSize && offset.divide(MAX_CHUNK_SIZE).eq(big_integer_1.default.zero) && stride % MIN_CHUNK_SIZE == 0 && (limit == undefined || offset.divide(limit).eq(big_integer_1.default.zero))) {\n    cls = DirectDownloadIter;\n    client._log.info(`Starting direct file download in chunks of ${requestSize} at ${offset}, stride ${stride}`);\n  } else {\n    cls = GenericDownloadIter;\n    client._log.info(`Starting indirect file download in chunks of ${requestSize} at ${offset}, stride ${stride}`);\n  }\n  return new cls(client, limit, {}, {\n    fileLocation: file,\n    dcId,\n    offset,\n    stride,\n    chunkSize,\n    requestSize,\n    fileSize,\n    msgData\n  });\n}\nfunction getWriter(outputFile) {\n  if (!outputFile || Buffer.isBuffer(outputFile)) {\n    return new extensions_1.BinaryWriter(Buffer.alloc(0));\n  } else if (typeof outputFile == \"string\") {\n    // We want to make sure that the path exists.\n    return (0, fs_1.createWriteStream)(outputFile);\n  } else {\n    return outputFile;\n  }\n}\nfunction closeWriter(writer) {\n  if (\"close\" in writer && writer.close) {\n    writer.close();\n  }\n}\nfunction returnWriterValue(writer) {\n  if (writer instanceof extensions_1.BinaryWriter) {\n    return writer.getValue();\n  }\n  if (writer instanceof fs.WriteStream) {\n    if (typeof writer.path == \"string\") {\n      return path_1.default.resolve(writer.path);\n    } else {\n      return Buffer.from(writer.path);\n    }\n  }\n}\n/** @hidden */\nasync function downloadFileV2(client, inputLocation, _ref3) {\n  let {\n    outputFile = undefined,\n    partSizeKb = undefined,\n    fileSize = undefined,\n    progressCallback = undefined,\n    dcId = undefined,\n    msgData = undefined\n  } = _ref3;\n  var _a, e_1, _b, _c;\n  if (!partSizeKb) {\n    if (!fileSize) {\n      partSizeKb = 64;\n    } else {\n      partSizeKb = __1.utils.getAppropriatedPartSize(fileSize);\n    }\n  }\n  const partSize = Math.floor(partSizeKb * 1024);\n  if (partSize % MIN_CHUNK_SIZE != 0) {\n    throw new Error(\"The part size must be evenly divisible by 4096\");\n  }\n  const writer = getWriter(outputFile);\n  let downloaded = big_integer_1.default.zero;\n  try {\n    try {\n      for (var _d = true, _e = __asyncValues(iterDownload(client, {\n          file: inputLocation,\n          requestSize: partSize,\n          dcId: dcId,\n          msgData: msgData\n        })), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {\n        _c = _f.value;\n        _d = false;\n        const chunk = _c;\n        await writer.write(chunk);\n        downloaded = downloaded.add(chunk.length);\n        if (progressCallback) {\n          await progressCallback(downloaded, (0, big_integer_1.default)(fileSize || big_integer_1.default.zero));\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return returnWriterValue(writer);\n  } finally {\n    closeWriter(writer);\n  }\n}\nclass Foreman {\n  constructor(maxWorkers) {\n    this.maxWorkers = maxWorkers;\n    this.activeWorkers = 0;\n  }\n  requestWorker() {\n    this.activeWorkers++;\n    if (this.activeWorkers > this.maxWorkers) {\n      this.deferred = createDeferred();\n      return this.deferred.promise;\n    }\n    return Promise.resolve();\n  }\n  releaseWorker() {\n    this.activeWorkers--;\n    if (this.deferred && this.activeWorkers <= this.maxWorkers) {\n      this.deferred.resolve();\n    }\n  }\n}\nfunction createDeferred() {\n  let resolve;\n  const promise = new Promise(_resolve => {\n    resolve = _resolve;\n  });\n  return {\n    promise,\n    resolve: resolve\n  };\n}\n/** @hidden */\nasync function downloadMedia(client, messageOrMedia, outputFile, thumb, progressCallback) {\n  /*\n    Downloading large documents may be slow enough to require a new file reference\n    to be obtained mid-download. Store (input chat, message id) so that the message\n    can be re-fetched.\n   */\n  let msgData;\n  let date;\n  let media;\n  if (messageOrMedia instanceof tl_1.Api.Message) {\n    media = messageOrMedia.media;\n    date = messageOrMedia.date;\n    msgData = messageOrMedia.inputChat ? [messageOrMedia.inputChat, messageOrMedia.id] : undefined;\n  } else {\n    media = messageOrMedia;\n    date = Date.now();\n  }\n  if (typeof media == \"string\") {\n    throw new Error(\"not implemented\");\n  }\n  if (media instanceof tl_1.Api.MessageMediaWebPage) {\n    if (media.webpage instanceof tl_1.Api.WebPage) {\n      media = media.webpage.document || media.webpage.photo;\n    }\n  }\n  if (media instanceof tl_1.Api.MessageMediaPhoto || media instanceof tl_1.Api.Photo) {\n    return _downloadPhoto(client, media, outputFile, date, thumb, progressCallback);\n  } else if (media instanceof tl_1.Api.MessageMediaDocument || media instanceof tl_1.Api.Document) {\n    return _downloadDocument(client, media, outputFile, date, thumb, progressCallback, msgData);\n  } else if (media instanceof tl_1.Api.MessageMediaContact) {\n    return _downloadContact(client, media, {});\n  } else if (media instanceof tl_1.Api.WebDocument || media instanceof tl_1.Api.WebDocumentNoProxy) {\n    return _downloadWebDocument(client, media, {});\n  } else {\n    return Buffer.alloc(0);\n  }\n}\n/** @hidden */\nasync function _downloadDocument(client, doc, outputFile, date, thumb, progressCallback, msgData) {\n  if (doc instanceof tl_1.Api.MessageMediaDocument) {\n    if (!doc.document) {\n      return Buffer.alloc(0);\n    }\n    doc = doc.document;\n  }\n  if (!(doc instanceof tl_1.Api.Document)) {\n    return Buffer.alloc(0);\n  }\n  let size;\n  if (thumb == undefined) {\n    outputFile = getProperFilename(outputFile, \"document\", \".\" + (__1.utils.getExtension(doc) || \"bin\"), date);\n  } else {\n    outputFile = getProperFilename(outputFile, \"photo\", \".jpg\", date);\n    size = getThumb(doc.thumbs || [], thumb);\n    if (size instanceof tl_1.Api.PhotoCachedSize || size instanceof tl_1.Api.PhotoStrippedSize) {\n      return _downloadCachedPhotoSize(size, outputFile);\n    }\n  }\n  return await downloadFileV2(client, new tl_1.Api.InputDocumentFileLocation({\n    id: doc.id,\n    accessHash: doc.accessHash,\n    fileReference: doc.fileReference,\n    thumbSize: size && \"type\" in size ? size.type : \"\"\n  }), {\n    outputFile: outputFile,\n    fileSize: size && \"size\" in size ? (0, big_integer_1.default)(size.size) : doc.size,\n    progressCallback: progressCallback,\n    msgData: msgData\n  });\n}\n/** @hidden */\nasync function _downloadContact(client, media, args) {\n  throw new Error(\"not implemented\");\n}\n/** @hidden */\nasync function _downloadWebDocument(client, media, args) {\n  throw new Error(\"not implemented\");\n}\nfunction pickFileSize(sizes, sizeType) {\n  if (!sizeType || !sizes || !sizes.length) {\n    return undefined;\n  }\n  const indexOfSize = sizeTypes.indexOf(sizeType);\n  let size;\n  for (let i = indexOfSize; i < sizeTypes.length; i++) {\n    size = sizes.find(s => s.type === sizeTypes[i]);\n    if (size && !(size instanceof tl_1.Api.PhotoPathSize)) {\n      return size;\n    }\n  }\n  return undefined;\n}\n/** @hidden */\nfunction getThumb(thumbs, thumb) {\n  function sortThumb(thumb) {\n    if (thumb instanceof tl_1.Api.PhotoStrippedSize) {\n      return thumb.bytes.length;\n    }\n    if (thumb instanceof tl_1.Api.PhotoCachedSize) {\n      return thumb.bytes.length;\n    }\n    if (thumb instanceof tl_1.Api.PhotoSize) {\n      return thumb.size;\n    }\n    if (thumb instanceof tl_1.Api.PhotoSizeProgressive) {\n      return Math.max(...thumb.sizes);\n    }\n    if (thumb instanceof tl_1.Api.VideoSize) {\n      return thumb.size;\n    }\n    return 0;\n  }\n  thumbs = thumbs.sort((a, b) => sortThumb(a) - sortThumb(b));\n  const correctThumbs = [];\n  for (const t of thumbs) {\n    if (!(t instanceof tl_1.Api.PhotoPathSize)) {\n      correctThumbs.push(t);\n    }\n  }\n  if (thumb == undefined) {\n    return correctThumbs.pop();\n  } else if (typeof thumb == \"number\") {\n    return correctThumbs[thumb];\n  } else if (typeof thumb == \"string\") {\n    for (const t of correctThumbs) {\n      if (\"type\" in t && t.type == thumb) {\n        return t;\n      }\n    }\n  } else if (thumb instanceof tl_1.Api.PhotoSize || thumb instanceof tl_1.Api.PhotoCachedSize || thumb instanceof tl_1.Api.PhotoStrippedSize || thumb instanceof tl_1.Api.VideoSize) {\n    return thumb;\n  }\n}\n/** @hidden */\nasync function _downloadCachedPhotoSize(size, outputFile) {\n  // No need to download anything, simply write the bytes\n  let data;\n  if (size instanceof tl_1.Api.PhotoStrippedSize) {\n    data = (0, Utils_1.strippedPhotoToJpg)(size.bytes);\n  } else {\n    data = size.bytes;\n  }\n  const writer = getWriter(outputFile);\n  try {\n    await writer.write(data);\n  } finally {\n    closeWriter(writer);\n  }\n  return returnWriterValue(writer);\n}\n/** @hidden */\nfunction getProperFilename(file, fileType, extension, date) {\n  if (!file || typeof file != \"string\") {\n    return file;\n  }\n  if (fs.existsSync(file) && fs.lstatSync(file).isDirectory()) {\n    let fullName = fileType + date + extension;\n    return path_1.default.join(file, fullName);\n  }\n  return file;\n}\n/** @hidden */\nasync function _downloadPhoto(client, photo, file, date, thumb, progressCallback) {\n  if (photo instanceof tl_1.Api.MessageMediaPhoto) {\n    if (photo.photo instanceof tl_1.Api.PhotoEmpty || !photo.photo) {\n      return Buffer.alloc(0);\n    }\n    photo = photo.photo;\n  }\n  if (!(photo instanceof tl_1.Api.Photo)) {\n    return Buffer.alloc(0);\n  }\n  const photoSizes = [...(photo.sizes || []), ...(photo.videoSizes || [])];\n  const size = getThumb(photoSizes, thumb);\n  if (!size || size instanceof tl_1.Api.PhotoSizeEmpty) {\n    return Buffer.alloc(0);\n  }\n  if (!date) {\n    date = Date.now();\n  }\n  file = getProperFilename(file, \"photo\", \".jpg\", date);\n  if (size instanceof tl_1.Api.PhotoCachedSize || size instanceof tl_1.Api.PhotoStrippedSize) {\n    return _downloadCachedPhotoSize(size, file);\n  }\n  let fileSize;\n  if (size instanceof tl_1.Api.PhotoSizeProgressive) {\n    fileSize = Math.max(...size.sizes);\n  } else {\n    fileSize = \"size\" in size ? size.size : 512;\n  }\n  return downloadFileV2(client, new tl_1.Api.InputPhotoFileLocation({\n    id: photo.id,\n    accessHash: photo.accessHash,\n    fileReference: photo.fileReference,\n    thumbSize: \"type\" in size ? size.type : \"\"\n  }), {\n    outputFile: file,\n    fileSize: (0, big_integer_1.default)(fileSize),\n    progressCallback: progressCallback,\n    dcId: photo.dcId\n  });\n}\n/** @hidden */\nasync function downloadProfilePhoto(client, entity, fileParams) {\n  let photo;\n  if (typeof entity == \"object\" && \"photo\" in entity) {\n    photo = entity.photo;\n  } else {\n    entity = await client.getEntity(entity);\n    if (\"photo\" in entity) {\n      photo = entity.photo;\n    } else {\n      throw new Error(`Could not get photo from ${entity ? entity.className : undefined}`);\n    }\n  }\n  let dcId;\n  let loc;\n  if (photo instanceof tl_1.Api.UserProfilePhoto || photo instanceof tl_1.Api.ChatPhoto) {\n    dcId = photo.dcId;\n    loc = new tl_1.Api.InputPeerPhotoFileLocation({\n      peer: __1.utils.getInputPeer(entity),\n      photoId: photo.photoId,\n      big: fileParams.isBig\n    });\n  } else {\n    return Buffer.alloc(0);\n  }\n  return client.downloadFile(loc, {\n    outputFile: fileParams.outputFile,\n    dcId\n  });\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}