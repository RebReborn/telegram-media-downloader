{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StopPropagation = void 0;\nexports.on = on;\nexports.addEventHandler = addEventHandler;\nexports.removeEventHandler = removeEventHandler;\nexports.listEventHandlers = listEventHandlers;\nexports.catchUp = catchUp;\nexports._handleUpdate = _handleUpdate;\nexports._processUpdate = _processUpdate;\nexports._dispatchUpdate = _dispatchUpdate;\nexports._updateLoop = _updateLoop;\nconst tl_1 = require(\"../tl\");\nconst network_1 = require(\"../network\");\nconst index_1 = require(\"../index\");\nconst Helpers_1 = require(\"../Helpers\");\nconst Logger_1 = require(\"../extensions/Logger\");\nconst PING_INTERVAL = 9000; // 9 sec\nconst PING_TIMEOUT = 10000; // 10 sec\nconst PING_FAIL_ATTEMPTS = 3;\nconst PING_FAIL_INTERVAL = 100; // ms\nconst PING_DISCONNECT_DELAY = 60000; // 1 min\n// An unusually long interval is a sign of returning from background mode...\nconst PING_INTERVAL_TO_WAKE_UP = 5000; // 5 sec\n// ... so we send a quick \"wake-up\" ping to confirm than connection was dropped ASAP\nconst PING_WAKE_UP_TIMEOUT = 3000; // 3 sec\n// We also send a warning to the user even a bit more quickly\nconst PING_WAKE_UP_WARNING_TIMEOUT = 1000; // 1 sec\n/**\n If this exception is raised in any of the handlers for a given event,\n it will stop the execution of all other registered event handlers.\n It can be seen as the ``StopIteration`` in a for loop but for events.\n */\nclass StopPropagation extends Error {}\nexports.StopPropagation = StopPropagation;\n/** @hidden */\nfunction on(client, event) {\n  return f => {\n    client.addEventHandler(f, event);\n    return f;\n  };\n}\n/** @hidden */\nfunction addEventHandler(client, callback, event) {\n  if (event == undefined) {\n    // recursive imports :(\n    const raw = require(\"../events/Raw\").Raw;\n    event = new raw({});\n  }\n  event.client = client;\n  client._eventBuilders.push([event, callback]);\n}\n/** @hidden */\nfunction removeEventHandler(client, callback, event) {\n  client._eventBuilders = client._eventBuilders.filter(function (item) {\n    return item[0] !== event && item[1] !== callback;\n  });\n}\n/** @hidden */\nfunction listEventHandlers(client) {\n  return client._eventBuilders;\n}\n/** @hidden */\nfunction catchUp() {\n  // TODO\n}\n/** @hidden */\nfunction _handleUpdate(client, update) {\n  if (typeof update === \"number\") {\n    if ([-1, 0, 1].includes(update)) {\n      _dispatchUpdate(client, {\n        update: new network_1.UpdateConnectionState(update)\n      });\n      return;\n    }\n  }\n  //this.session.processEntities(update)\n  client._entityCache.add(update);\n  client.session.processEntities(update);\n  if (update instanceof tl_1.Api.Updates || update instanceof tl_1.Api.UpdatesCombined) {\n    // TODO deal with entities\n    const entities = new Map();\n    for (const x of [...update.users, ...update.chats]) {\n      entities.set(index_1.utils.getPeerId(x), x);\n    }\n    for (const u of update.updates) {\n      _processUpdate(client, u, update.updates, entities);\n    }\n  } else if (update instanceof tl_1.Api.UpdateShort) {\n    _processUpdate(client, update.update, null);\n  } else {\n    _processUpdate(client, update, null);\n  }\n}\n/** @hidden */\nfunction _processUpdate(client, update, others, entities) {\n  update._entities = entities || new Map();\n  const args = {\n    update: update,\n    others: others\n  };\n  _dispatchUpdate(client, args);\n}\n/** @hidden */\nasync function _dispatchUpdate(client, args) {\n  for (const [builder, callback] of client._eventBuilders) {\n    if (!builder || !callback) {\n      continue;\n    }\n    if (!builder.resolved) {\n      await builder.resolve(client);\n    }\n    let event = args.update;\n    if (event) {\n      if (!client._selfInputPeer) {\n        try {\n          await client.getMe(true);\n        } catch (e) {\n          // do nothing\n        }\n      }\n      if (!(event instanceof network_1.UpdateConnectionState)) {\n        // TODO fix me\n      }\n      // TODO fix others not being passed\n      event = builder.build(event, callback, client._selfInputPeer ? (0, Helpers_1.returnBigInt)(client._selfInputPeer.userId) : undefined);\n      if (event) {\n        event._client = client;\n        if (\"_eventName\" in event) {\n          event._setClient(client);\n          event.originalUpdate = args.update;\n          event._entities = args.update._entities;\n        }\n        const filter = await builder.filter(event);\n        if (!filter) {\n          continue;\n        }\n        try {\n          await callback(event);\n        } catch (e) {\n          if (e instanceof StopPropagation) {\n            break;\n          }\n          if (client._errorHandler) {\n            await client._errorHandler(e);\n          }\n          if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\n            console.error(e);\n          }\n        }\n      }\n    }\n  }\n}\n/** @hidden */\nasync function _updateLoop(client) {\n  let lastPongAt;\n  while (!client._destroyed) {\n    await (0, Helpers_1.sleep)(PING_INTERVAL, true);\n    if (client._destroyed) break;\n    if (client._sender.isReconnecting || client._isSwitchingDc) {\n      lastPongAt = undefined;\n      continue;\n    }\n    try {\n      const ping = () => {\n        return client._sender.send(new tl_1.Api.PingDelayDisconnect({\n          pingId: (0, Helpers_1.returnBigInt)((0, Helpers_1.getRandomInt)(Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)),\n          disconnectDelay: PING_DISCONNECT_DELAY\n        }));\n      };\n      const pingAt = Date.now();\n      const lastInterval = lastPongAt ? pingAt - lastPongAt : undefined;\n      if (!lastInterval || lastInterval < PING_INTERVAL_TO_WAKE_UP) {\n        await attempts(() => timeout(ping, PING_TIMEOUT), PING_FAIL_ATTEMPTS, PING_FAIL_INTERVAL);\n      } else {\n        let wakeUpWarningTimeout = setTimeout(() => {\n          _handleUpdate(client, network_1.UpdateConnectionState.disconnected);\n          wakeUpWarningTimeout = undefined;\n        }, PING_WAKE_UP_WARNING_TIMEOUT);\n        await timeout(ping, PING_WAKE_UP_TIMEOUT);\n        if (wakeUpWarningTimeout) {\n          clearTimeout(wakeUpWarningTimeout);\n          wakeUpWarningTimeout = undefined;\n        }\n        _handleUpdate(client, network_1.UpdateConnectionState.connected);\n      }\n      lastPongAt = Date.now();\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      if (client._errorHandler) {\n        await client._errorHandler(err);\n      }\n      if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\n        console.error(err);\n      }\n      lastPongAt = undefined;\n      if (client._sender.isReconnecting || client._isSwitchingDc) {\n        continue;\n      }\n      client._sender.reconnect();\n    }\n    // We need to send some content-related request at least hourly\n    // for Telegram to keep delivering updates, otherwise they will\n    // just stop even if we're connected. Do so every 30 minutes.\n    if (Date.now() - (client._lastRequest || 0) > 30 * 60 * 1000) {\n      try {\n        await client.invoke(new tl_1.Api.updates.GetState());\n      } catch (e) {\n        // we don't care about errors here\n      }\n      lastPongAt = undefined;\n    }\n  }\n  await client.disconnect();\n}\n/** @hidden */\nasync function attempts(cb, times, pause) {\n  for (let i = 0; i < times; i++) {\n    try {\n      // We need to `return await` here so it can be caught locally\n      return await cb();\n    } catch (err) {\n      if (i === times - 1) {\n        throw err;\n      }\n      await (0, Helpers_1.sleep)(pause);\n    }\n  }\n  return undefined;\n}\n/** @hidden */\nfunction timeout(cb, ms) {\n  let isResolved = false;\n  return Promise.race([cb(), (0, Helpers_1.sleep)(ms).then(() => isResolved ? undefined : Promise.reject(new Error(\"TIMEOUT\")))]).finally(() => {\n    isResolved = true;\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","StopPropagation","on","addEventHandler","removeEventHandler","listEventHandlers","catchUp","_handleUpdate","_processUpdate","_dispatchUpdate","_updateLoop","tl_1","require","network_1","index_1","Helpers_1","Logger_1","PING_INTERVAL","PING_TIMEOUT","PING_FAIL_ATTEMPTS","PING_FAIL_INTERVAL","PING_DISCONNECT_DELAY","PING_INTERVAL_TO_WAKE_UP","PING_WAKE_UP_TIMEOUT","PING_WAKE_UP_WARNING_TIMEOUT","Error","client","event","f","callback","undefined","raw","Raw","_eventBuilders","push","filter","item","update","includes","UpdateConnectionState","_entityCache","add","session","processEntities","Api","Updates","UpdatesCombined","entities","Map","x","users","chats","set","utils","getPeerId","u","updates","UpdateShort","others","_entities","args","builder","resolved","resolve","_selfInputPeer","getMe","e","build","returnBigInt","userId","_client","_setClient","originalUpdate","_errorHandler","_log","canSend","LogLevel","ERROR","console","error","lastPongAt","_destroyed","sleep","_sender","isReconnecting","_isSwitchingDc","ping","send","PingDelayDisconnect","pingId","getRandomInt","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","disconnectDelay","pingAt","Date","now","lastInterval","attempts","timeout","wakeUpWarningTimeout","setTimeout","disconnected","clearTimeout","connected","err","reconnect","_lastRequest","invoke","GetState","disconnect","cb","times","pause","i","ms","isResolved","Promise","race","then","reject","finally"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/client/updates.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StopPropagation = void 0;\nexports.on = on;\nexports.addEventHandler = addEventHandler;\nexports.removeEventHandler = removeEventHandler;\nexports.listEventHandlers = listEventHandlers;\nexports.catchUp = catchUp;\nexports._handleUpdate = _handleUpdate;\nexports._processUpdate = _processUpdate;\nexports._dispatchUpdate = _dispatchUpdate;\nexports._updateLoop = _updateLoop;\nconst tl_1 = require(\"../tl\");\nconst network_1 = require(\"../network\");\nconst index_1 = require(\"../index\");\nconst Helpers_1 = require(\"../Helpers\");\nconst Logger_1 = require(\"../extensions/Logger\");\nconst PING_INTERVAL = 9000; // 9 sec\nconst PING_TIMEOUT = 10000; // 10 sec\nconst PING_FAIL_ATTEMPTS = 3;\nconst PING_FAIL_INTERVAL = 100; // ms\nconst PING_DISCONNECT_DELAY = 60000; // 1 min\n// An unusually long interval is a sign of returning from background mode...\nconst PING_INTERVAL_TO_WAKE_UP = 5000; // 5 sec\n// ... so we send a quick \"wake-up\" ping to confirm than connection was dropped ASAP\nconst PING_WAKE_UP_TIMEOUT = 3000; // 3 sec\n// We also send a warning to the user even a bit more quickly\nconst PING_WAKE_UP_WARNING_TIMEOUT = 1000; // 1 sec\n/**\n If this exception is raised in any of the handlers for a given event,\n it will stop the execution of all other registered event handlers.\n It can be seen as the ``StopIteration`` in a for loop but for events.\n */\nclass StopPropagation extends Error {\n}\nexports.StopPropagation = StopPropagation;\n/** @hidden */\nfunction on(client, event) {\n    return (f) => {\n        client.addEventHandler(f, event);\n        return f;\n    };\n}\n/** @hidden */\nfunction addEventHandler(client, callback, event) {\n    if (event == undefined) {\n        // recursive imports :(\n        const raw = require(\"../events/Raw\").Raw;\n        event = new raw({});\n    }\n    event.client = client;\n    client._eventBuilders.push([event, callback]);\n}\n/** @hidden */\nfunction removeEventHandler(client, callback, event) {\n    client._eventBuilders = client._eventBuilders.filter(function (item) {\n        return item[0] !== event && item[1] !== callback;\n    });\n}\n/** @hidden */\nfunction listEventHandlers(client) {\n    return client._eventBuilders;\n}\n/** @hidden */\nfunction catchUp() {\n    // TODO\n}\n/** @hidden */\nfunction _handleUpdate(client, update) {\n    if (typeof update === \"number\") {\n        if ([-1, 0, 1].includes(update)) {\n            _dispatchUpdate(client, {\n                update: new network_1.UpdateConnectionState(update),\n            });\n            return;\n        }\n    }\n    //this.session.processEntities(update)\n    client._entityCache.add(update);\n    client.session.processEntities(update);\n    if (update instanceof tl_1.Api.Updates ||\n        update instanceof tl_1.Api.UpdatesCombined) {\n        // TODO deal with entities\n        const entities = new Map();\n        for (const x of [...update.users, ...update.chats]) {\n            entities.set(index_1.utils.getPeerId(x), x);\n        }\n        for (const u of update.updates) {\n            _processUpdate(client, u, update.updates, entities);\n        }\n    }\n    else if (update instanceof tl_1.Api.UpdateShort) {\n        _processUpdate(client, update.update, null);\n    }\n    else {\n        _processUpdate(client, update, null);\n    }\n}\n/** @hidden */\nfunction _processUpdate(client, update, others, entities) {\n    update._entities = entities || new Map();\n    const args = {\n        update: update,\n        others: others,\n    };\n    _dispatchUpdate(client, args);\n}\n/** @hidden */\nasync function _dispatchUpdate(client, args) {\n    for (const [builder, callback] of client._eventBuilders) {\n        if (!builder || !callback) {\n            continue;\n        }\n        if (!builder.resolved) {\n            await builder.resolve(client);\n        }\n        let event = args.update;\n        if (event) {\n            if (!client._selfInputPeer) {\n                try {\n                    await client.getMe(true);\n                }\n                catch (e) {\n                    // do nothing\n                }\n            }\n            if (!(event instanceof network_1.UpdateConnectionState)) {\n                // TODO fix me\n            }\n            // TODO fix others not being passed\n            event = builder.build(event, callback, client._selfInputPeer\n                ? (0, Helpers_1.returnBigInt)(client._selfInputPeer.userId)\n                : undefined);\n            if (event) {\n                event._client = client;\n                if (\"_eventName\" in event) {\n                    event._setClient(client);\n                    event.originalUpdate = args.update;\n                    event._entities = args.update._entities;\n                }\n                const filter = await builder.filter(event);\n                if (!filter) {\n                    continue;\n                }\n                try {\n                    await callback(event);\n                }\n                catch (e) {\n                    if (e instanceof StopPropagation) {\n                        break;\n                    }\n                    if (client._errorHandler) {\n                        await client._errorHandler(e);\n                    }\n                    if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\n                        console.error(e);\n                    }\n                }\n            }\n        }\n    }\n}\n/** @hidden */\nasync function _updateLoop(client) {\n    let lastPongAt;\n    while (!client._destroyed) {\n        await (0, Helpers_1.sleep)(PING_INTERVAL, true);\n        if (client._destroyed)\n            break;\n        if (client._sender.isReconnecting || client._isSwitchingDc) {\n            lastPongAt = undefined;\n            continue;\n        }\n        try {\n            const ping = () => {\n                return client._sender.send(new tl_1.Api.PingDelayDisconnect({\n                    pingId: (0, Helpers_1.returnBigInt)((0, Helpers_1.getRandomInt)(Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)),\n                    disconnectDelay: PING_DISCONNECT_DELAY,\n                }));\n            };\n            const pingAt = Date.now();\n            const lastInterval = lastPongAt ? pingAt - lastPongAt : undefined;\n            if (!lastInterval || lastInterval < PING_INTERVAL_TO_WAKE_UP) {\n                await attempts(() => timeout(ping, PING_TIMEOUT), PING_FAIL_ATTEMPTS, PING_FAIL_INTERVAL);\n            }\n            else {\n                let wakeUpWarningTimeout = setTimeout(() => {\n                    _handleUpdate(client, network_1.UpdateConnectionState.disconnected);\n                    wakeUpWarningTimeout = undefined;\n                }, PING_WAKE_UP_WARNING_TIMEOUT);\n                await timeout(ping, PING_WAKE_UP_TIMEOUT);\n                if (wakeUpWarningTimeout) {\n                    clearTimeout(wakeUpWarningTimeout);\n                    wakeUpWarningTimeout = undefined;\n                }\n                _handleUpdate(client, network_1.UpdateConnectionState.connected);\n            }\n            lastPongAt = Date.now();\n        }\n        catch (err) {\n            // eslint-disable-next-line no-console\n            if (client._errorHandler) {\n                await client._errorHandler(err);\n            }\n            if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\n                console.error(err);\n            }\n            lastPongAt = undefined;\n            if (client._sender.isReconnecting || client._isSwitchingDc) {\n                continue;\n            }\n            client._sender.reconnect();\n        }\n        // We need to send some content-related request at least hourly\n        // for Telegram to keep delivering updates, otherwise they will\n        // just stop even if we're connected. Do so every 30 minutes.\n        if (Date.now() - (client._lastRequest || 0) > 30 * 60 * 1000) {\n            try {\n                await client.invoke(new tl_1.Api.updates.GetState());\n            }\n            catch (e) {\n                // we don't care about errors here\n            }\n            lastPongAt = undefined;\n        }\n    }\n    await client.disconnect();\n}\n/** @hidden */\nasync function attempts(cb, times, pause) {\n    for (let i = 0; i < times; i++) {\n        try {\n            // We need to `return await` here so it can be caught locally\n            return await cb();\n        }\n        catch (err) {\n            if (i === times - 1) {\n                throw err;\n            }\n            await (0, Helpers_1.sleep)(pause);\n        }\n    }\n    return undefined;\n}\n/** @hidden */\nfunction timeout(cb, ms) {\n    let isResolved = false;\n    return Promise.race([\n        cb(),\n        (0, Helpers_1.sleep)(ms).then(() => isResolved ? undefined : Promise.reject(new Error(\"TIMEOUT\"))),\n    ]).finally(() => {\n        isResolved = true;\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}