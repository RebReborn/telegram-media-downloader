{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GenericDownloadIter = exports.DirectDownloadIter = void 0;\nexports.iterDownload = iterDownload;\nexports.downloadFileV2 = downloadFileV2;\nexports.downloadMedia = downloadMedia;\nexports._downloadDocument = _downloadDocument;\nexports._downloadContact = _downloadContact;\nexports._downloadWebDocument = _downloadWebDocument;\nexports._downloadCachedPhotoSize = _downloadCachedPhotoSize;\nexports._downloadPhoto = _downloadPhoto;\nexports.downloadProfilePhoto = downloadProfilePhoto;\nconst tl_1 = require(\"../tl\");\nconst Utils_1 = require(\"../Utils\");\nconst Helpers_1 = require(\"../Helpers\");\nconst __1 = require(\"../\");\nconst requestIter_1 = require(\"../requestIter\");\nconst errors_1 = require(\"../errors\");\nconst fs_1 = require(\"./fs\");\nconst extensions_1 = require(\"../extensions\");\nconst fs = __importStar(require(\"./fs\"));\nconst path_1 = __importDefault(require(\"./path\"));\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\n// All types\nconst sizeTypes = [\"w\", \"y\", \"d\", \"x\", \"c\", \"m\", \"b\", \"a\", \"s\"];\n// Chunk sizes for `upload.getFile` must be multiple of the smallest size\nconst MIN_CHUNK_SIZE = 4096;\nconst DEFAULT_CHUNK_SIZE = 64; // kb\nconst ONE_MB = 1024 * 1024;\nconst REQUEST_TIMEOUT = 15000;\nconst DISCONNECT_SLEEP = 1000;\nconst TIMED_OUT_SLEEP = 1000;\nconst MAX_CHUNK_SIZE = 512 * 1024;\nclass DirectDownloadIter extends requestIter_1.RequestIter {\n  constructor() {\n    super(...arguments);\n    this._timedOut = false;\n  }\n  async _init({\n    fileLocation,\n    dcId,\n    offset,\n    stride,\n    chunkSize,\n    requestSize,\n    fileSize,\n    msgData\n  }) {\n    this.request = new tl_1.Api.upload.GetFile({\n      location: fileLocation,\n      offset,\n      limit: requestSize\n    });\n    this.total = fileSize;\n    this._stride = stride;\n    this._chunkSize = chunkSize;\n    this._lastPart = undefined;\n    //this._msgData = msgData;\n    this._timedOut = false;\n    this._sender = await this.client.getSender(dcId);\n  }\n  async _loadNextChunk() {\n    const current = await this._request();\n    this.buffer.push(current);\n    if (current.length < this.request.limit) {\n      // we finished downloading\n      this.left = this.buffer.length;\n      await this.close();\n      return true;\n    } else {\n      this.request.offset = this.request.offset.add(this._stride);\n    }\n  }\n  async _request() {\n    try {\n      this._sender = await this.client.getSender(this._sender.dcId);\n      const result = await this.client.invokeWithSender(this.request, this._sender);\n      this._timedOut = false;\n      if (result instanceof tl_1.Api.upload.FileCdnRedirect) {\n        throw new Error(\"CDN Not supported. Please Add an issue in github\");\n      }\n      return result.bytes;\n    } catch (e) {\n      if (e.errorMessage == \"TIMEOUT\") {\n        if (this._timedOut) {\n          this.client._log.warn(\"Got two timeouts in a row while downloading file\");\n          throw e;\n        }\n        this._timedOut = true;\n        this.client._log.info(\"Got timeout while downloading file, retrying once\");\n        await (0, Helpers_1.sleep)(TIMED_OUT_SLEEP);\n        return await this._request();\n      } else if (e instanceof errors_1.FileMigrateError) {\n        this.client._log.info(\"File lives in another DC\");\n        this._sender = await this.client.getSender(e.newDc);\n        return await this._request();\n      } else if (e.errorMessage == \"FILEREF_UPGRADE_NEEDED\") {\n        // TODO later\n        throw e;\n      } else {\n        throw e;\n      }\n    }\n  }\n  async close() {\n    this.client._log.debug(\"Finished downloading file ...\");\n  }\n  [Symbol.asyncIterator]() {\n    return super[Symbol.asyncIterator]();\n  }\n}\nexports.DirectDownloadIter = DirectDownloadIter;\nclass GenericDownloadIter extends DirectDownloadIter {\n  async _loadNextChunk() {\n    // 1. Fetch enough for one chunk\n    let data = Buffer.alloc(0);\n    //  1.1. ``bad`` is how much into the data we have we need to offset\n    const bad = this.request.offset.mod(this.request.limit).toJSNumber();\n    const before = this.request.offset;\n    // 1.2. We have to fetch from a valid offset, so remove that bad part\n    this.request.offset = this.request.offset.subtract(bad);\n    let done = false;\n    while (!done && data.length - bad < this._chunkSize) {\n      const current = await this._request();\n      this.request.offset = this.request.offset.add(this.request.limit);\n      data = Buffer.concat([data, current]);\n      done = current.length < this.request.limit;\n    }\n    // 1.3 Restore our last desired offset\n    this.request.offset = before;\n    // 2. Fill the buffer with the data we have\n    // 2.1. The current chunk starts at ``bad`` offset into the data,\n    //  and each new chunk is ``stride`` bytes apart of the other\n    for (let i = bad; i < data.length; i += this._stride) {\n      this.buffer.push(data.slice(i, i + this._chunkSize));\n      // 2.2. We will yield this offset, so move to the next one\n      this.request.offset = this.request.offset.add(this._stride);\n    }\n    // 2.3. If we are in the last chunk, we will return the last partial data\n    if (done) {\n      this.left = this.buffer.length;\n      await this.close();\n      return;\n    }\n    // 2.4 If we are not done, we can't return incomplete chunks.\n    if (this.buffer[this.buffer.length - 1].length != this._chunkSize) {\n      this._lastPart = this.buffer.pop();\n      //   3. Be careful with the offsets. Re-fetching a bit of data\n      //   is fine, since it greatly simplifies things.\n      // TODO Try to not re-fetch data\n      this.request.offset = this.request.offset.subtract(this._stride);\n    }\n  }\n}\nexports.GenericDownloadIter = GenericDownloadIter;\n/** @hidden */\nfunction iterDownload(client, {\n  file,\n  offset = big_integer_1.default.zero,\n  stride,\n  limit,\n  chunkSize,\n  requestSize = MAX_CHUNK_SIZE,\n  fileSize,\n  dcId,\n  msgData\n}) {\n  // we're ignoring here to make it more flexible (which is probably a bad idea)\n  // @ts-ignore\n  const info = __1.utils.getFileInfo(file);\n  if (info.dcId != undefined) {\n    dcId = info.dcId;\n  }\n  if (fileSize == undefined) {\n    fileSize = info.size;\n  }\n  file = info.location;\n  if (chunkSize == undefined) {\n    chunkSize = requestSize;\n  }\n  if (limit == undefined && fileSize != undefined) {\n    limit = Math.floor(fileSize.add(chunkSize).subtract(1).divide(chunkSize).toJSNumber());\n  }\n  if (stride == undefined) {\n    stride = chunkSize;\n  } else if (stride < chunkSize) {\n    throw new Error(\"Stride must be >= chunkSize\");\n  }\n  requestSize -= requestSize % MIN_CHUNK_SIZE;\n  if (requestSize < MIN_CHUNK_SIZE) {\n    requestSize = MIN_CHUNK_SIZE;\n  } else if (requestSize > MAX_CHUNK_SIZE) {\n    requestSize = MAX_CHUNK_SIZE;\n  }\n  let cls;\n  if (chunkSize == requestSize && offset.divide(MAX_CHUNK_SIZE).eq(big_integer_1.default.zero) && stride % MIN_CHUNK_SIZE == 0 && (limit == undefined || offset.divide(limit).eq(big_integer_1.default.zero))) {\n    cls = DirectDownloadIter;\n    client._log.info(`Starting direct file download in chunks of ${requestSize} at ${offset}, stride ${stride}`);\n  } else {\n    cls = GenericDownloadIter;\n    client._log.info(`Starting indirect file download in chunks of ${requestSize} at ${offset}, stride ${stride}`);\n  }\n  return new cls(client, limit, {}, {\n    fileLocation: file,\n    dcId,\n    offset,\n    stride,\n    chunkSize,\n    requestSize,\n    fileSize,\n    msgData\n  });\n}\nfunction getWriter(outputFile) {\n  if (!outputFile || Buffer.isBuffer(outputFile)) {\n    return new extensions_1.BinaryWriter(Buffer.alloc(0));\n  } else if (typeof outputFile == \"string\") {\n    // We want to make sure that the path exists.\n    return (0, fs_1.createWriteStream)(outputFile);\n  } else {\n    return outputFile;\n  }\n}\nfunction closeWriter(writer) {\n  if (\"close\" in writer && writer.close) {\n    writer.close();\n  }\n}\nfunction returnWriterValue(writer) {\n  if (writer instanceof extensions_1.BinaryWriter) {\n    return writer.getValue();\n  }\n  if (writer instanceof fs.WriteStream) {\n    if (typeof writer.path == \"string\") {\n      return path_1.default.resolve(writer.path);\n    } else {\n      return Buffer.from(writer.path);\n    }\n  }\n}\n/** @hidden */\nasync function downloadFileV2(client, inputLocation, {\n  outputFile = undefined,\n  partSizeKb = undefined,\n  fileSize = undefined,\n  progressCallback = undefined,\n  dcId = undefined,\n  msgData = undefined\n}) {\n  var _a, e_1, _b, _c;\n  if (!partSizeKb) {\n    if (!fileSize) {\n      partSizeKb = 64;\n    } else {\n      partSizeKb = __1.utils.getAppropriatedPartSize(fileSize);\n    }\n  }\n  const partSize = Math.floor(partSizeKb * 1024);\n  if (partSize % MIN_CHUNK_SIZE != 0) {\n    throw new Error(\"The part size must be evenly divisible by 4096\");\n  }\n  const writer = getWriter(outputFile);\n  let downloaded = big_integer_1.default.zero;\n  try {\n    try {\n      for (var _d = true, _e = __asyncValues(iterDownload(client, {\n          file: inputLocation,\n          requestSize: partSize,\n          dcId: dcId,\n          msgData: msgData\n        })), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {\n        _c = _f.value;\n        _d = false;\n        const chunk = _c;\n        await writer.write(chunk);\n        downloaded = downloaded.add(chunk.length);\n        if (progressCallback) {\n          await progressCallback(downloaded, (0, big_integer_1.default)(fileSize || big_integer_1.default.zero));\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return returnWriterValue(writer);\n  } finally {\n    closeWriter(writer);\n  }\n}\nclass Foreman {\n  constructor(maxWorkers) {\n    this.maxWorkers = maxWorkers;\n    this.activeWorkers = 0;\n  }\n  requestWorker() {\n    this.activeWorkers++;\n    if (this.activeWorkers > this.maxWorkers) {\n      this.deferred = createDeferred();\n      return this.deferred.promise;\n    }\n    return Promise.resolve();\n  }\n  releaseWorker() {\n    this.activeWorkers--;\n    if (this.deferred && this.activeWorkers <= this.maxWorkers) {\n      this.deferred.resolve();\n    }\n  }\n}\nfunction createDeferred() {\n  let resolve;\n  const promise = new Promise(_resolve => {\n    resolve = _resolve;\n  });\n  return {\n    promise,\n    resolve: resolve\n  };\n}\n/** @hidden */\nasync function downloadMedia(client, messageOrMedia, outputFile, thumb, progressCallback) {\n  /*\n    Downloading large documents may be slow enough to require a new file reference\n    to be obtained mid-download. Store (input chat, message id) so that the message\n    can be re-fetched.\n   */\n  let msgData;\n  let date;\n  let media;\n  if (messageOrMedia instanceof tl_1.Api.Message) {\n    media = messageOrMedia.media;\n    date = messageOrMedia.date;\n    msgData = messageOrMedia.inputChat ? [messageOrMedia.inputChat, messageOrMedia.id] : undefined;\n  } else {\n    media = messageOrMedia;\n    date = Date.now();\n  }\n  if (typeof media == \"string\") {\n    throw new Error(\"not implemented\");\n  }\n  if (media instanceof tl_1.Api.MessageMediaWebPage) {\n    if (media.webpage instanceof tl_1.Api.WebPage) {\n      media = media.webpage.document || media.webpage.photo;\n    }\n  }\n  if (media instanceof tl_1.Api.MessageMediaPhoto || media instanceof tl_1.Api.Photo) {\n    return _downloadPhoto(client, media, outputFile, date, thumb, progressCallback);\n  } else if (media instanceof tl_1.Api.MessageMediaDocument || media instanceof tl_1.Api.Document) {\n    return _downloadDocument(client, media, outputFile, date, thumb, progressCallback, msgData);\n  } else if (media instanceof tl_1.Api.MessageMediaContact) {\n    return _downloadContact(client, media, {});\n  } else if (media instanceof tl_1.Api.WebDocument || media instanceof tl_1.Api.WebDocumentNoProxy) {\n    return _downloadWebDocument(client, media, {});\n  } else {\n    return Buffer.alloc(0);\n  }\n}\n/** @hidden */\nasync function _downloadDocument(client, doc, outputFile, date, thumb, progressCallback, msgData) {\n  if (doc instanceof tl_1.Api.MessageMediaDocument) {\n    if (!doc.document) {\n      return Buffer.alloc(0);\n    }\n    doc = doc.document;\n  }\n  if (!(doc instanceof tl_1.Api.Document)) {\n    return Buffer.alloc(0);\n  }\n  let size;\n  if (thumb == undefined) {\n    outputFile = getProperFilename(outputFile, \"document\", \".\" + (__1.utils.getExtension(doc) || \"bin\"), date);\n  } else {\n    outputFile = getProperFilename(outputFile, \"photo\", \".jpg\", date);\n    size = getThumb(doc.thumbs || [], thumb);\n    if (size instanceof tl_1.Api.PhotoCachedSize || size instanceof tl_1.Api.PhotoStrippedSize) {\n      return _downloadCachedPhotoSize(size, outputFile);\n    }\n  }\n  return await downloadFileV2(client, new tl_1.Api.InputDocumentFileLocation({\n    id: doc.id,\n    accessHash: doc.accessHash,\n    fileReference: doc.fileReference,\n    thumbSize: size && \"type\" in size ? size.type : \"\"\n  }), {\n    outputFile: outputFile,\n    fileSize: size && \"size\" in size ? (0, big_integer_1.default)(size.size) : doc.size,\n    progressCallback: progressCallback,\n    msgData: msgData\n  });\n}\n/** @hidden */\nasync function _downloadContact(client, media, args) {\n  throw new Error(\"not implemented\");\n}\n/** @hidden */\nasync function _downloadWebDocument(client, media, args) {\n  throw new Error(\"not implemented\");\n}\nfunction pickFileSize(sizes, sizeType) {\n  if (!sizeType || !sizes || !sizes.length) {\n    return undefined;\n  }\n  const indexOfSize = sizeTypes.indexOf(sizeType);\n  let size;\n  for (let i = indexOfSize; i < sizeTypes.length; i++) {\n    size = sizes.find(s => s.type === sizeTypes[i]);\n    if (size && !(size instanceof tl_1.Api.PhotoPathSize)) {\n      return size;\n    }\n  }\n  return undefined;\n}\n/** @hidden */\nfunction getThumb(thumbs, thumb) {\n  function sortThumb(thumb) {\n    if (thumb instanceof tl_1.Api.PhotoStrippedSize) {\n      return thumb.bytes.length;\n    }\n    if (thumb instanceof tl_1.Api.PhotoCachedSize) {\n      return thumb.bytes.length;\n    }\n    if (thumb instanceof tl_1.Api.PhotoSize) {\n      return thumb.size;\n    }\n    if (thumb instanceof tl_1.Api.PhotoSizeProgressive) {\n      return Math.max(...thumb.sizes);\n    }\n    if (thumb instanceof tl_1.Api.VideoSize) {\n      return thumb.size;\n    }\n    return 0;\n  }\n  thumbs = thumbs.sort((a, b) => sortThumb(a) - sortThumb(b));\n  const correctThumbs = [];\n  for (const t of thumbs) {\n    if (!(t instanceof tl_1.Api.PhotoPathSize)) {\n      correctThumbs.push(t);\n    }\n  }\n  if (thumb == undefined) {\n    return correctThumbs.pop();\n  } else if (typeof thumb == \"number\") {\n    return correctThumbs[thumb];\n  } else if (typeof thumb == \"string\") {\n    for (const t of correctThumbs) {\n      if (\"type\" in t && t.type == thumb) {\n        return t;\n      }\n    }\n  } else if (thumb instanceof tl_1.Api.PhotoSize || thumb instanceof tl_1.Api.PhotoCachedSize || thumb instanceof tl_1.Api.PhotoStrippedSize || thumb instanceof tl_1.Api.VideoSize) {\n    return thumb;\n  }\n}\n/** @hidden */\nasync function _downloadCachedPhotoSize(size, outputFile) {\n  // No need to download anything, simply write the bytes\n  let data;\n  if (size instanceof tl_1.Api.PhotoStrippedSize) {\n    data = (0, Utils_1.strippedPhotoToJpg)(size.bytes);\n  } else {\n    data = size.bytes;\n  }\n  const writer = getWriter(outputFile);\n  try {\n    await writer.write(data);\n  } finally {\n    closeWriter(writer);\n  }\n  return returnWriterValue(writer);\n}\n/** @hidden */\nfunction getProperFilename(file, fileType, extension, date) {\n  if (!file || typeof file != \"string\") {\n    return file;\n  }\n  if (fs.existsSync(file) && fs.lstatSync(file).isDirectory()) {\n    let fullName = fileType + date + extension;\n    return path_1.default.join(file, fullName);\n  }\n  return file;\n}\n/** @hidden */\nasync function _downloadPhoto(client, photo, file, date, thumb, progressCallback) {\n  if (photo instanceof tl_1.Api.MessageMediaPhoto) {\n    if (photo.photo instanceof tl_1.Api.PhotoEmpty || !photo.photo) {\n      return Buffer.alloc(0);\n    }\n    photo = photo.photo;\n  }\n  if (!(photo instanceof tl_1.Api.Photo)) {\n    return Buffer.alloc(0);\n  }\n  const photoSizes = [...(photo.sizes || []), ...(photo.videoSizes || [])];\n  const size = getThumb(photoSizes, thumb);\n  if (!size || size instanceof tl_1.Api.PhotoSizeEmpty) {\n    return Buffer.alloc(0);\n  }\n  if (!date) {\n    date = Date.now();\n  }\n  file = getProperFilename(file, \"photo\", \".jpg\", date);\n  if (size instanceof tl_1.Api.PhotoCachedSize || size instanceof tl_1.Api.PhotoStrippedSize) {\n    return _downloadCachedPhotoSize(size, file);\n  }\n  let fileSize;\n  if (size instanceof tl_1.Api.PhotoSizeProgressive) {\n    fileSize = Math.max(...size.sizes);\n  } else {\n    fileSize = \"size\" in size ? size.size : 512;\n  }\n  return downloadFileV2(client, new tl_1.Api.InputPhotoFileLocation({\n    id: photo.id,\n    accessHash: photo.accessHash,\n    fileReference: photo.fileReference,\n    thumbSize: \"type\" in size ? size.type : \"\"\n  }), {\n    outputFile: file,\n    fileSize: (0, big_integer_1.default)(fileSize),\n    progressCallback: progressCallback,\n    dcId: photo.dcId\n  });\n}\n/** @hidden */\nasync function downloadProfilePhoto(client, entity, fileParams) {\n  let photo;\n  if (typeof entity == \"object\" && \"photo\" in entity) {\n    photo = entity.photo;\n  } else {\n    entity = await client.getEntity(entity);\n    if (\"photo\" in entity) {\n      photo = entity.photo;\n    } else {\n      throw new Error(`Could not get photo from ${entity ? entity.className : undefined}`);\n    }\n  }\n  let dcId;\n  let loc;\n  if (photo instanceof tl_1.Api.UserProfilePhoto || photo instanceof tl_1.Api.ChatPhoto) {\n    dcId = photo.dcId;\n    loc = new tl_1.Api.InputPeerPhotoFileLocation({\n      peer: __1.utils.getInputPeer(entity),\n      photoId: photo.photoId,\n      big: fileParams.isBig\n    });\n  } else {\n    return Buffer.alloc(0);\n  }\n  return client.downloadFile(loc, {\n    outputFile: fileParams.outputFile,\n    dcId\n  });\n}","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__asyncValues","Symbol","asyncIterator","TypeError","i","__values","iterator","verb","n","Promise","resolve","reject","settle","done","d","then","__importDefault","exports","GenericDownloadIter","DirectDownloadIter","iterDownload","downloadFileV2","downloadMedia","_downloadDocument","_downloadContact","_downloadWebDocument","_downloadCachedPhotoSize","_downloadPhoto","downloadProfilePhoto","tl_1","require","Utils_1","Helpers_1","__1","requestIter_1","errors_1","fs_1","extensions_1","fs","path_1","big_integer_1","sizeTypes","MIN_CHUNK_SIZE","DEFAULT_CHUNK_SIZE","ONE_MB","REQUEST_TIMEOUT","DISCONNECT_SLEEP","TIMED_OUT_SLEEP","MAX_CHUNK_SIZE","RequestIter","constructor","arguments","_timedOut","_init","fileLocation","dcId","offset","stride","chunkSize","requestSize","fileSize","msgData","request","Api","upload","GetFile","location","limit","total","_stride","_chunkSize","_lastPart","_sender","client","getSender","_loadNextChunk","current","_request","buffer","push","length","left","close","add","invokeWithSender","FileCdnRedirect","Error","bytes","e","errorMessage","_log","warn","info","sleep","FileMigrateError","newDc","debug","data","Buffer","alloc","bad","toJSNumber","before","subtract","concat","slice","pop","file","default","zero","utils","getFileInfo","size","Math","floor","divide","cls","eq","getWriter","outputFile","isBuffer","BinaryWriter","createWriteStream","closeWriter","writer","returnWriterValue","getValue","WriteStream","path","from","inputLocation","partSizeKb","progressCallback","_a","e_1","_b","_c","getAppropriatedPartSize","partSize","downloaded","_d","_e","_f","next","chunk","write","e_1_1","error","return","Foreman","maxWorkers","activeWorkers","requestWorker","deferred","createDeferred","promise","releaseWorker","_resolve","messageOrMedia","thumb","date","media","Message","inputChat","id","Date","now","MessageMediaWebPage","webpage","WebPage","document","photo","MessageMediaPhoto","Photo","MessageMediaDocument","Document","MessageMediaContact","WebDocument","WebDocumentNoProxy","doc","getProperFilename","getExtension","getThumb","thumbs","PhotoCachedSize","PhotoStrippedSize","InputDocumentFileLocation","accessHash","fileReference","thumbSize","type","args","pickFileSize","sizes","sizeType","indexOfSize","indexOf","find","s","PhotoPathSize","sortThumb","PhotoSize","PhotoSizeProgressive","max","VideoSize","sort","a","b","correctThumbs","t","strippedPhotoToJpg","fileType","extension","existsSync","lstatSync","isDirectory","fullName","join","PhotoEmpty","photoSizes","videoSizes","PhotoSizeEmpty","InputPhotoFileLocation","entity","fileParams","getEntity","className","loc","UserProfilePhoto","ChatPhoto","InputPeerPhotoFileLocation","peer","getInputPeer","photoId","big","isBig","downloadFile"],"sources":["C:/Users/Rodrick/Documents/telegram-media-downloader/node_modules/telegram/client/downloads.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GenericDownloadIter = exports.DirectDownloadIter = void 0;\nexports.iterDownload = iterDownload;\nexports.downloadFileV2 = downloadFileV2;\nexports.downloadMedia = downloadMedia;\nexports._downloadDocument = _downloadDocument;\nexports._downloadContact = _downloadContact;\nexports._downloadWebDocument = _downloadWebDocument;\nexports._downloadCachedPhotoSize = _downloadCachedPhotoSize;\nexports._downloadPhoto = _downloadPhoto;\nexports.downloadProfilePhoto = downloadProfilePhoto;\nconst tl_1 = require(\"../tl\");\nconst Utils_1 = require(\"../Utils\");\nconst Helpers_1 = require(\"../Helpers\");\nconst __1 = require(\"../\");\nconst requestIter_1 = require(\"../requestIter\");\nconst errors_1 = require(\"../errors\");\nconst fs_1 = require(\"./fs\");\nconst extensions_1 = require(\"../extensions\");\nconst fs = __importStar(require(\"./fs\"));\nconst path_1 = __importDefault(require(\"./path\"));\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\n// All types\nconst sizeTypes = [\"w\", \"y\", \"d\", \"x\", \"c\", \"m\", \"b\", \"a\", \"s\"];\n// Chunk sizes for `upload.getFile` must be multiple of the smallest size\nconst MIN_CHUNK_SIZE = 4096;\nconst DEFAULT_CHUNK_SIZE = 64; // kb\nconst ONE_MB = 1024 * 1024;\nconst REQUEST_TIMEOUT = 15000;\nconst DISCONNECT_SLEEP = 1000;\nconst TIMED_OUT_SLEEP = 1000;\nconst MAX_CHUNK_SIZE = 512 * 1024;\nclass DirectDownloadIter extends requestIter_1.RequestIter {\n    constructor() {\n        super(...arguments);\n        this._timedOut = false;\n    }\n    async _init({ fileLocation, dcId, offset, stride, chunkSize, requestSize, fileSize, msgData, }) {\n        this.request = new tl_1.Api.upload.GetFile({\n            location: fileLocation,\n            offset,\n            limit: requestSize,\n        });\n        this.total = fileSize;\n        this._stride = stride;\n        this._chunkSize = chunkSize;\n        this._lastPart = undefined;\n        //this._msgData = msgData;\n        this._timedOut = false;\n        this._sender = await this.client.getSender(dcId);\n    }\n    async _loadNextChunk() {\n        const current = await this._request();\n        this.buffer.push(current);\n        if (current.length < this.request.limit) {\n            // we finished downloading\n            this.left = this.buffer.length;\n            await this.close();\n            return true;\n        }\n        else {\n            this.request.offset = this.request.offset.add(this._stride);\n        }\n    }\n    async _request() {\n        try {\n            this._sender = await this.client.getSender(this._sender.dcId);\n            const result = await this.client.invokeWithSender(this.request, this._sender);\n            this._timedOut = false;\n            if (result instanceof tl_1.Api.upload.FileCdnRedirect) {\n                throw new Error(\"CDN Not supported. Please Add an issue in github\");\n            }\n            return result.bytes;\n        }\n        catch (e) {\n            if (e.errorMessage == \"TIMEOUT\") {\n                if (this._timedOut) {\n                    this.client._log.warn(\"Got two timeouts in a row while downloading file\");\n                    throw e;\n                }\n                this._timedOut = true;\n                this.client._log.info(\"Got timeout while downloading file, retrying once\");\n                await (0, Helpers_1.sleep)(TIMED_OUT_SLEEP);\n                return await this._request();\n            }\n            else if (e instanceof errors_1.FileMigrateError) {\n                this.client._log.info(\"File lives in another DC\");\n                this._sender = await this.client.getSender(e.newDc);\n                return await this._request();\n            }\n            else if (e.errorMessage == \"FILEREF_UPGRADE_NEEDED\") {\n                // TODO later\n                throw e;\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n    async close() {\n        this.client._log.debug(\"Finished downloading file ...\");\n    }\n    [Symbol.asyncIterator]() {\n        return super[Symbol.asyncIterator]();\n    }\n}\nexports.DirectDownloadIter = DirectDownloadIter;\nclass GenericDownloadIter extends DirectDownloadIter {\n    async _loadNextChunk() {\n        // 1. Fetch enough for one chunk\n        let data = Buffer.alloc(0);\n        //  1.1. ``bad`` is how much into the data we have we need to offset\n        const bad = this.request.offset.mod(this.request.limit).toJSNumber();\n        const before = this.request.offset;\n        // 1.2. We have to fetch from a valid offset, so remove that bad part\n        this.request.offset = this.request.offset.subtract(bad);\n        let done = false;\n        while (!done && data.length - bad < this._chunkSize) {\n            const current = await this._request();\n            this.request.offset = this.request.offset.add(this.request.limit);\n            data = Buffer.concat([data, current]);\n            done = current.length < this.request.limit;\n        }\n        // 1.3 Restore our last desired offset\n        this.request.offset = before;\n        // 2. Fill the buffer with the data we have\n        // 2.1. The current chunk starts at ``bad`` offset into the data,\n        //  and each new chunk is ``stride`` bytes apart of the other\n        for (let i = bad; i < data.length; i += this._stride) {\n            this.buffer.push(data.slice(i, i + this._chunkSize));\n            // 2.2. We will yield this offset, so move to the next one\n            this.request.offset = this.request.offset.add(this._stride);\n        }\n        // 2.3. If we are in the last chunk, we will return the last partial data\n        if (done) {\n            this.left = this.buffer.length;\n            await this.close();\n            return;\n        }\n        // 2.4 If we are not done, we can't return incomplete chunks.\n        if (this.buffer[this.buffer.length - 1].length != this._chunkSize) {\n            this._lastPart = this.buffer.pop();\n            //   3. Be careful with the offsets. Re-fetching a bit of data\n            //   is fine, since it greatly simplifies things.\n            // TODO Try to not re-fetch data\n            this.request.offset = this.request.offset.subtract(this._stride);\n        }\n    }\n}\nexports.GenericDownloadIter = GenericDownloadIter;\n/** @hidden */\nfunction iterDownload(client, { file, offset = big_integer_1.default.zero, stride, limit, chunkSize, requestSize = MAX_CHUNK_SIZE, fileSize, dcId, msgData, }) {\n    // we're ignoring here to make it more flexible (which is probably a bad idea)\n    // @ts-ignore\n    const info = __1.utils.getFileInfo(file);\n    if (info.dcId != undefined) {\n        dcId = info.dcId;\n    }\n    if (fileSize == undefined) {\n        fileSize = info.size;\n    }\n    file = info.location;\n    if (chunkSize == undefined) {\n        chunkSize = requestSize;\n    }\n    if (limit == undefined && fileSize != undefined) {\n        limit = Math.floor(fileSize.add(chunkSize).subtract(1).divide(chunkSize).toJSNumber());\n    }\n    if (stride == undefined) {\n        stride = chunkSize;\n    }\n    else if (stride < chunkSize) {\n        throw new Error(\"Stride must be >= chunkSize\");\n    }\n    requestSize -= requestSize % MIN_CHUNK_SIZE;\n    if (requestSize < MIN_CHUNK_SIZE) {\n        requestSize = MIN_CHUNK_SIZE;\n    }\n    else if (requestSize > MAX_CHUNK_SIZE) {\n        requestSize = MAX_CHUNK_SIZE;\n    }\n    let cls;\n    if (chunkSize == requestSize &&\n        offset.divide(MAX_CHUNK_SIZE).eq(big_integer_1.default.zero) &&\n        stride % MIN_CHUNK_SIZE == 0 &&\n        (limit == undefined || offset.divide(limit).eq(big_integer_1.default.zero))) {\n        cls = DirectDownloadIter;\n        client._log.info(`Starting direct file download in chunks of ${requestSize} at ${offset}, stride ${stride}`);\n    }\n    else {\n        cls = GenericDownloadIter;\n        client._log.info(`Starting indirect file download in chunks of ${requestSize} at ${offset}, stride ${stride}`);\n    }\n    return new cls(client, limit, {}, {\n        fileLocation: file,\n        dcId,\n        offset,\n        stride,\n        chunkSize,\n        requestSize,\n        fileSize,\n        msgData,\n    });\n}\nfunction getWriter(outputFile) {\n    if (!outputFile || Buffer.isBuffer(outputFile)) {\n        return new extensions_1.BinaryWriter(Buffer.alloc(0));\n    }\n    else if (typeof outputFile == \"string\") {\n        // We want to make sure that the path exists.\n        return (0, fs_1.createWriteStream)(outputFile);\n    }\n    else {\n        return outputFile;\n    }\n}\nfunction closeWriter(writer) {\n    if (\"close\" in writer && writer.close) {\n        writer.close();\n    }\n}\nfunction returnWriterValue(writer) {\n    if (writer instanceof extensions_1.BinaryWriter) {\n        return writer.getValue();\n    }\n    if (writer instanceof fs.WriteStream) {\n        if (typeof writer.path == \"string\") {\n            return path_1.default.resolve(writer.path);\n        }\n        else {\n            return Buffer.from(writer.path);\n        }\n    }\n}\n/** @hidden */\nasync function downloadFileV2(client, inputLocation, { outputFile = undefined, partSizeKb = undefined, fileSize = undefined, progressCallback = undefined, dcId = undefined, msgData = undefined, }) {\n    var _a, e_1, _b, _c;\n    if (!partSizeKb) {\n        if (!fileSize) {\n            partSizeKb = 64;\n        }\n        else {\n            partSizeKb = __1.utils.getAppropriatedPartSize(fileSize);\n        }\n    }\n    const partSize = Math.floor(partSizeKb * 1024);\n    if (partSize % MIN_CHUNK_SIZE != 0) {\n        throw new Error(\"The part size must be evenly divisible by 4096\");\n    }\n    const writer = getWriter(outputFile);\n    let downloaded = big_integer_1.default.zero;\n    try {\n        try {\n            for (var _d = true, _e = __asyncValues(iterDownload(client, {\n                file: inputLocation,\n                requestSize: partSize,\n                dcId: dcId,\n                msgData: msgData,\n            })), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {\n                _c = _f.value;\n                _d = false;\n                const chunk = _c;\n                await writer.write(chunk);\n                downloaded = downloaded.add(chunk.length);\n                if (progressCallback) {\n                    await progressCallback(downloaded, (0, big_integer_1.default)(fileSize || big_integer_1.default.zero));\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return returnWriterValue(writer);\n    }\n    finally {\n        closeWriter(writer);\n    }\n}\nclass Foreman {\n    constructor(maxWorkers) {\n        this.maxWorkers = maxWorkers;\n        this.activeWorkers = 0;\n    }\n    requestWorker() {\n        this.activeWorkers++;\n        if (this.activeWorkers > this.maxWorkers) {\n            this.deferred = createDeferred();\n            return this.deferred.promise;\n        }\n        return Promise.resolve();\n    }\n    releaseWorker() {\n        this.activeWorkers--;\n        if (this.deferred && this.activeWorkers <= this.maxWorkers) {\n            this.deferred.resolve();\n        }\n    }\n}\nfunction createDeferred() {\n    let resolve;\n    const promise = new Promise((_resolve) => {\n        resolve = _resolve;\n    });\n    return {\n        promise,\n        resolve: resolve,\n    };\n}\n/** @hidden */\nasync function downloadMedia(client, messageOrMedia, outputFile, thumb, progressCallback) {\n    /*\n      Downloading large documents may be slow enough to require a new file reference\n      to be obtained mid-download. Store (input chat, message id) so that the message\n      can be re-fetched.\n     */\n    let msgData;\n    let date;\n    let media;\n    if (messageOrMedia instanceof tl_1.Api.Message) {\n        media = messageOrMedia.media;\n        date = messageOrMedia.date;\n        msgData = messageOrMedia.inputChat\n            ? [messageOrMedia.inputChat, messageOrMedia.id]\n            : undefined;\n    }\n    else {\n        media = messageOrMedia;\n        date = Date.now();\n    }\n    if (typeof media == \"string\") {\n        throw new Error(\"not implemented\");\n    }\n    if (media instanceof tl_1.Api.MessageMediaWebPage) {\n        if (media.webpage instanceof tl_1.Api.WebPage) {\n            media = media.webpage.document || media.webpage.photo;\n        }\n    }\n    if (media instanceof tl_1.Api.MessageMediaPhoto || media instanceof tl_1.Api.Photo) {\n        return _downloadPhoto(client, media, outputFile, date, thumb, progressCallback);\n    }\n    else if (media instanceof tl_1.Api.MessageMediaDocument ||\n        media instanceof tl_1.Api.Document) {\n        return _downloadDocument(client, media, outputFile, date, thumb, progressCallback, msgData);\n    }\n    else if (media instanceof tl_1.Api.MessageMediaContact) {\n        return _downloadContact(client, media, {});\n    }\n    else if (media instanceof tl_1.Api.WebDocument ||\n        media instanceof tl_1.Api.WebDocumentNoProxy) {\n        return _downloadWebDocument(client, media, {});\n    }\n    else {\n        return Buffer.alloc(0);\n    }\n}\n/** @hidden */\nasync function _downloadDocument(client, doc, outputFile, date, thumb, progressCallback, msgData) {\n    if (doc instanceof tl_1.Api.MessageMediaDocument) {\n        if (!doc.document) {\n            return Buffer.alloc(0);\n        }\n        doc = doc.document;\n    }\n    if (!(doc instanceof tl_1.Api.Document)) {\n        return Buffer.alloc(0);\n    }\n    let size;\n    if (thumb == undefined) {\n        outputFile = getProperFilename(outputFile, \"document\", \".\" + (__1.utils.getExtension(doc) || \"bin\"), date);\n    }\n    else {\n        outputFile = getProperFilename(outputFile, \"photo\", \".jpg\", date);\n        size = getThumb(doc.thumbs || [], thumb);\n        if (size instanceof tl_1.Api.PhotoCachedSize ||\n            size instanceof tl_1.Api.PhotoStrippedSize) {\n            return _downloadCachedPhotoSize(size, outputFile);\n        }\n    }\n    return await downloadFileV2(client, new tl_1.Api.InputDocumentFileLocation({\n        id: doc.id,\n        accessHash: doc.accessHash,\n        fileReference: doc.fileReference,\n        thumbSize: size && \"type\" in size ? size.type : \"\",\n    }), {\n        outputFile: outputFile,\n        fileSize: size && \"size\" in size ? (0, big_integer_1.default)(size.size) : doc.size,\n        progressCallback: progressCallback,\n        msgData: msgData,\n    });\n}\n/** @hidden */\nasync function _downloadContact(client, media, args) {\n    throw new Error(\"not implemented\");\n}\n/** @hidden */\nasync function _downloadWebDocument(client, media, args) {\n    throw new Error(\"not implemented\");\n}\nfunction pickFileSize(sizes, sizeType) {\n    if (!sizeType || !sizes || !sizes.length) {\n        return undefined;\n    }\n    const indexOfSize = sizeTypes.indexOf(sizeType);\n    let size;\n    for (let i = indexOfSize; i < sizeTypes.length; i++) {\n        size = sizes.find((s) => s.type === sizeTypes[i]);\n        if (size && !(size instanceof tl_1.Api.PhotoPathSize)) {\n            return size;\n        }\n    }\n    return undefined;\n}\n/** @hidden */\nfunction getThumb(thumbs, thumb) {\n    function sortThumb(thumb) {\n        if (thumb instanceof tl_1.Api.PhotoStrippedSize) {\n            return thumb.bytes.length;\n        }\n        if (thumb instanceof tl_1.Api.PhotoCachedSize) {\n            return thumb.bytes.length;\n        }\n        if (thumb instanceof tl_1.Api.PhotoSize) {\n            return thumb.size;\n        }\n        if (thumb instanceof tl_1.Api.PhotoSizeProgressive) {\n            return Math.max(...thumb.sizes);\n        }\n        if (thumb instanceof tl_1.Api.VideoSize) {\n            return thumb.size;\n        }\n        return 0;\n    }\n    thumbs = thumbs.sort((a, b) => sortThumb(a) - sortThumb(b));\n    const correctThumbs = [];\n    for (const t of thumbs) {\n        if (!(t instanceof tl_1.Api.PhotoPathSize)) {\n            correctThumbs.push(t);\n        }\n    }\n    if (thumb == undefined) {\n        return correctThumbs.pop();\n    }\n    else if (typeof thumb == \"number\") {\n        return correctThumbs[thumb];\n    }\n    else if (typeof thumb == \"string\") {\n        for (const t of correctThumbs) {\n            if (\"type\" in t && t.type == thumb) {\n                return t;\n            }\n        }\n    }\n    else if (thumb instanceof tl_1.Api.PhotoSize ||\n        thumb instanceof tl_1.Api.PhotoCachedSize ||\n        thumb instanceof tl_1.Api.PhotoStrippedSize ||\n        thumb instanceof tl_1.Api.VideoSize) {\n        return thumb;\n    }\n}\n/** @hidden */\nasync function _downloadCachedPhotoSize(size, outputFile) {\n    // No need to download anything, simply write the bytes\n    let data;\n    if (size instanceof tl_1.Api.PhotoStrippedSize) {\n        data = (0, Utils_1.strippedPhotoToJpg)(size.bytes);\n    }\n    else {\n        data = size.bytes;\n    }\n    const writer = getWriter(outputFile);\n    try {\n        await writer.write(data);\n    }\n    finally {\n        closeWriter(writer);\n    }\n    return returnWriterValue(writer);\n}\n/** @hidden */\nfunction getProperFilename(file, fileType, extension, date) {\n    if (!file || typeof file != \"string\") {\n        return file;\n    }\n    if (fs.existsSync(file) && fs.lstatSync(file).isDirectory()) {\n        let fullName = fileType + date + extension;\n        return path_1.default.join(file, fullName);\n    }\n    return file;\n}\n/** @hidden */\nasync function _downloadPhoto(client, photo, file, date, thumb, progressCallback) {\n    if (photo instanceof tl_1.Api.MessageMediaPhoto) {\n        if (photo.photo instanceof tl_1.Api.PhotoEmpty || !photo.photo) {\n            return Buffer.alloc(0);\n        }\n        photo = photo.photo;\n    }\n    if (!(photo instanceof tl_1.Api.Photo)) {\n        return Buffer.alloc(0);\n    }\n    const photoSizes = [...(photo.sizes || []), ...(photo.videoSizes || [])];\n    const size = getThumb(photoSizes, thumb);\n    if (!size || size instanceof tl_1.Api.PhotoSizeEmpty) {\n        return Buffer.alloc(0);\n    }\n    if (!date) {\n        date = Date.now();\n    }\n    file = getProperFilename(file, \"photo\", \".jpg\", date);\n    if (size instanceof tl_1.Api.PhotoCachedSize ||\n        size instanceof tl_1.Api.PhotoStrippedSize) {\n        return _downloadCachedPhotoSize(size, file);\n    }\n    let fileSize;\n    if (size instanceof tl_1.Api.PhotoSizeProgressive) {\n        fileSize = Math.max(...size.sizes);\n    }\n    else {\n        fileSize = \"size\" in size ? size.size : 512;\n    }\n    return downloadFileV2(client, new tl_1.Api.InputPhotoFileLocation({\n        id: photo.id,\n        accessHash: photo.accessHash,\n        fileReference: photo.fileReference,\n        thumbSize: \"type\" in size ? size.type : \"\",\n    }), {\n        outputFile: file,\n        fileSize: (0, big_integer_1.default)(fileSize),\n        progressCallback: progressCallback,\n        dcId: photo.dcId,\n    });\n}\n/** @hidden */\nasync function downloadProfilePhoto(client, entity, fileParams) {\n    let photo;\n    if (typeof entity == \"object\" && \"photo\" in entity) {\n        photo = entity.photo;\n    }\n    else {\n        entity = await client.getEntity(entity);\n        if (\"photo\" in entity) {\n            photo = entity.photo;\n        }\n        else {\n            throw new Error(`Could not get photo from ${entity ? entity.className : undefined}`);\n        }\n    }\n    let dcId;\n    let loc;\n    if (photo instanceof tl_1.Api.UserProfilePhoto ||\n        photo instanceof tl_1.Api.ChatPhoto) {\n        dcId = photo.dcId;\n        loc = new tl_1.Api.InputPeerPhotoFileLocation({\n            peer: __1.utils.getInputPeer(entity),\n            photoId: photo.photoId,\n            big: fileParams.isBig,\n        });\n    }\n    else {\n        return Buffer.alloc(0);\n    }\n    return client.downloadFile(loc, {\n        outputFile: fileParams.outputFile,\n        dcId,\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}