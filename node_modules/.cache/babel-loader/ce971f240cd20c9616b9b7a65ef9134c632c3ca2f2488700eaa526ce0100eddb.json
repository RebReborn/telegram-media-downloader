{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessagePacker = void 0;\nconst core_1 = require(\"../tl/core\");\nconst core_2 = require(\"../tl/core\");\nconst BinaryWriter_1 = require(\"./BinaryWriter\");\nconst USE_INVOKE_AFTER_WITH = new Set([\"messages.SendMessage\", \"messages.SendMedia\", \"messages.SendMultiMedia\", \"messages.ForwardMessages\", \"messages.SendInlineBotResult\"]);\nclass MessagePacker {\n  constructor(state, logger) {\n    this._state = state;\n    this._queue = [];\n    this._pendingStates = [];\n    this._ready = new Promise(resolve => {\n      this.setReady = resolve;\n    });\n    this._log = logger;\n  }\n  values() {\n    return this._queue;\n  }\n  append(state) {\n    let setReady = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let atStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var _a, _b;\n    // We need to check if there is already a `USE_INVOKE_AFTER_WITH` request\n    if (state && USE_INVOKE_AFTER_WITH.has(state.request.className)) {\n      if (atStart) {\n        // Assign `after` for the previously first `USE_INVOKE_AFTER_WITH` request\n        for (let i = 0; i < this._queue.length; i++) {\n          if (USE_INVOKE_AFTER_WITH.has((_a = this._queue[i]) === null || _a === void 0 ? void 0 : _a.request.className)) {\n            this._queue[i].after = state;\n            break;\n          }\n        }\n      } else {\n        // Assign after for the previous `USE_INVOKE_AFTER_WITH` request\n        for (let i = this._queue.length - 1; i >= 0; i--) {\n          if (USE_INVOKE_AFTER_WITH.has((_b = this._queue[i]) === null || _b === void 0 ? void 0 : _b.request.className)) {\n            state.after = this._queue[i];\n            break;\n          }\n        }\n      }\n    }\n    if (atStart) {\n      this._queue.unshift(state);\n    } else {\n      this._queue.push(state);\n    }\n    if (setReady && this.setReady) {\n      this.setReady(true);\n    }\n    // 1658238041=MsgsAck, we don't care about MsgsAck here because they never resolve anyway.\n    if (state && state.request.CONSTRUCTOR_ID !== 1658238041) {\n      this._pendingStates.push(state);\n      state.promise // Using finally causes triggering `unhandledrejection` event\n      .catch(err => {}).finally(() => {\n        this._pendingStates = this._pendingStates.filter(s => s !== state);\n      });\n    }\n  }\n  prepend(states) {\n    states.reverse().forEach(state => {\n      this.append(state, false, true);\n    });\n    if (this.setReady) {\n      this.setReady(true);\n    }\n  }\n  extend(states) {\n    states.forEach(state => {\n      this.append(state, false);\n    });\n    if (this.setReady) {\n      this.setReady(true);\n    }\n  }\n  clear() {\n    this._queue = [];\n    this.append(undefined);\n  }\n  async wait() {\n    if (!this._queue.length) {\n      this._ready = new Promise(resolve => {\n        this.setReady = resolve;\n      });\n      await this._ready;\n    }\n  }\n  async get() {\n    if (!this._queue[this._queue.length - 1]) {\n      this._queue = this._queue.filter(Boolean);\n      return undefined;\n    }\n    let data;\n    let buffer = new BinaryWriter_1.BinaryWriter(Buffer.alloc(0));\n    const batch = [];\n    let size = 0;\n    while (this._queue.length && batch.length <= core_1.MessageContainer.MAXIMUM_LENGTH) {\n      const state = this._queue.shift();\n      if (!state) {\n        continue;\n      }\n      size += state.data.length + core_2.TLMessage.SIZE_OVERHEAD;\n      if (size <= core_1.MessageContainer.MAXIMUM_SIZE) {\n        let afterId;\n        if (state.after) {\n          afterId = state.after.msgId;\n        }\n        if (state.after) {\n          afterId = state.after.msgId;\n        }\n        state.msgId = await this._state.writeDataAsMessage(buffer, state.data, state.request.classType === \"request\", afterId);\n        this._log.debug(`Assigned msgId = ${state.msgId} to ${state.request.className || state.request.constructor.name}`);\n        batch.push(state);\n        continue;\n      }\n      if (batch.length) {\n        this._queue.unshift(state);\n        break;\n      }\n      this._log.warn(`Message payload for ${state.request.className || state.request.constructor.name} is too long ${state.data.length} and cannot be sent`);\n      state.promise.reject(\"Request Payload is too big\");\n      size = 0;\n    }\n    if (!batch.length) {\n      return null;\n    }\n    if (batch.length > 1) {\n      const b = Buffer.alloc(8);\n      b.writeUInt32LE(core_1.MessageContainer.CONSTRUCTOR_ID, 0);\n      b.writeInt32LE(batch.length, 4);\n      data = Buffer.concat([b, buffer.getValue()]);\n      buffer = new BinaryWriter_1.BinaryWriter(Buffer.alloc(0));\n      const containerId = await this._state.writeDataAsMessage(buffer, data, false);\n      for (const s of batch) {\n        s.containerId = containerId;\n      }\n    }\n    data = buffer.getValue();\n    return {\n      batch,\n      data\n    };\n  }\n}\nexports.MessagePacker = MessagePacker;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}