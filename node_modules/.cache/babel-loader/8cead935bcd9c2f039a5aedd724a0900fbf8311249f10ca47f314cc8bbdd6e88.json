{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CustomMessage = void 0;\nconst senderGetter_1 = require(\"./senderGetter\");\nconst api_1 = require(\"../api\");\nconst chatGetter_1 = require(\"./chatGetter\");\nconst utils = __importStar(require(\"../../Utils\"));\nconst forward_1 = require(\"./forward\");\nconst file_1 = require(\"./file\");\nconst Helpers_1 = require(\"../../Helpers\");\nconst users_1 = require(\"../../client/users\");\nconst Logger_1 = require(\"../../extensions/Logger\");\nconst messageButton_1 = require(\"./messageButton\");\nconst inspect_1 = require(\"../../inspect\");\n/**\n * This custom class aggregates both {@link Api.Message} and {@link Api.MessageService} to ease accessing their members.<br/>\n * <br/>\n * Remember that this class implements {@link ChatGetter} and {@link SenderGetter}<br/>\n * which means you have access to all their sender and chat properties and methods.\n */\nclass CustomMessage extends senderGetter_1.SenderGetter {\n  [inspect_1.inspect.custom]() {\n    return (0, Helpers_1.betterConsoleLog)(this);\n  }\n  init({\n    id,\n    peerId = undefined,\n    date = undefined,\n    out = undefined,\n    mentioned = undefined,\n    mediaUnread = undefined,\n    silent = undefined,\n    post = undefined,\n    fromId = undefined,\n    replyTo = undefined,\n    message = undefined,\n    fwdFrom = undefined,\n    viaBotId = undefined,\n    media = undefined,\n    replyMarkup = undefined,\n    entities = undefined,\n    views = undefined,\n    editDate = undefined,\n    postAuthor = undefined,\n    groupedId = undefined,\n    fromScheduled = undefined,\n    legacy = undefined,\n    editHide = undefined,\n    pinned = undefined,\n    restrictionReason = undefined,\n    forwards = undefined,\n    replies = undefined,\n    action = undefined,\n    reactions = undefined,\n    noforwards = undefined,\n    ttlPeriod = undefined,\n    _entities = new Map()\n  }) {\n    if (!id) throw new Error(\"id is a required attribute for Message\");\n    let senderId = undefined;\n    if (fromId) {\n      senderId = utils.getPeerId(fromId);\n    } else if (peerId) {\n      if (post || !out && peerId instanceof api_1.Api.PeerUser) {\n        senderId = utils.getPeerId(peerId);\n      }\n    }\n    // Common properties to all messages\n    this._entities = _entities;\n    this.out = out;\n    this.mentioned = mentioned;\n    this.mediaUnread = mediaUnread;\n    this.silent = silent;\n    this.post = post;\n    this.post = post;\n    this.fromScheduled = fromScheduled;\n    this.legacy = legacy;\n    this.editHide = editHide;\n    this.ttlPeriod = ttlPeriod;\n    this.id = id;\n    this.fromId = fromId;\n    this.peerId = peerId;\n    this.fwdFrom = fwdFrom;\n    this.viaBotId = viaBotId;\n    this.replyTo = replyTo;\n    this.date = date;\n    this.message = message;\n    this.media = media instanceof api_1.Api.MessageMediaEmpty ? media : undefined;\n    this.replyMarkup = replyMarkup;\n    this.entities = entities;\n    this.views = views;\n    this.forwards = forwards;\n    this.replies = replies;\n    this.editDate = editDate;\n    this.pinned = pinned;\n    this.postAuthor = postAuthor;\n    this.groupedId = groupedId;\n    this.restrictionReason = restrictionReason;\n    this.action = action;\n    this.noforwards = noforwards;\n    this.reactions = reactions;\n    this._client = undefined;\n    this._text = undefined;\n    this._file = undefined;\n    this._replyMessage = undefined;\n    this._buttons = undefined;\n    this._buttonsFlat = undefined;\n    this._buttonsCount = 0;\n    this._viaBot = undefined;\n    this._viaInputBot = undefined;\n    this._actionEntities = undefined;\n    // Note: these calls would reset the client\n    chatGetter_1.ChatGetter.initChatClass(this, {\n      chatPeer: peerId,\n      broadcast: post\n    });\n    senderGetter_1.SenderGetter.initSenderClass(this, {\n      senderId: senderId ? (0, Helpers_1.returnBigInt)(senderId) : undefined\n    });\n    this._forward = undefined;\n  }\n  constructor(args) {\n    super();\n    this.init(args);\n  }\n  _finishInit(client, entities, inputChat) {\n    this._client = client;\n    const cache = client._entityCache;\n    if (this.senderId) {\n      [this._sender, this._inputSender] = utils._getEntityPair(this.senderId.toString(), entities, cache);\n    }\n    if (this.chatId) {\n      [this._chat, this._inputChat] = utils._getEntityPair(this.chatId.toString(), entities, cache);\n    }\n    if (inputChat) {\n      // This has priority\n      this._inputChat = inputChat;\n    }\n    if (this.viaBotId) {\n      [this._viaBot, this._viaInputBot] = utils._getEntityPair(this.viaBotId.toString(), entities, cache);\n    }\n    if (this.fwdFrom) {\n      this._forward = new forward_1.Forward(this._client, this.fwdFrom, entities);\n    }\n    if (this.action) {\n      if (this.action instanceof api_1.Api.MessageActionChatAddUser || this.action instanceof api_1.Api.MessageActionChatCreate) {\n        this._actionEntities = this.action.users.map(i => entities.get(i.toString()));\n      } else if (this.action instanceof api_1.Api.MessageActionChatDeleteUser) {\n        this._actionEntities = [entities.get(this.action.userId.toString())];\n      } else if (this.action instanceof api_1.Api.MessageActionChatJoinedByLink) {\n        this._actionEntities = [entities.get(utils.getPeerId(new api_1.Api.PeerChannel({\n          channelId: this.action.inviterId\n        })))];\n      } else if (this.action instanceof api_1.Api.MessageActionChannelMigrateFrom) {\n        this._actionEntities = [entities.get(utils.getPeerId(new api_1.Api.PeerChat({\n          chatId: this.action.chatId\n        })))];\n      }\n    }\n  }\n  get client() {\n    return this._client;\n  }\n  get text() {\n    if (this._text === undefined && this._client) {\n      if (!this._client.parseMode) {\n        this._text = this.message;\n      } else {\n        this._text = this._client.parseMode.unparse(this.message || \"\", this.entities || []);\n      }\n    }\n    return this._text || \"\";\n  }\n  set text(value) {\n    this._text = value;\n    if (this._client && this._client.parseMode) {\n      [this.message, this.entities] = this._client.parseMode.parse(value);\n    } else {\n      this.message = value;\n      this.entities = [];\n    }\n  }\n  get rawText() {\n    return this.message || \"\";\n  }\n  /**\n   * @param {string} value\n   */\n  set rawText(value) {\n    this.message = value;\n    this.entities = [];\n    this._text = \"\";\n  }\n  get isReply() {\n    return !!this.replyTo;\n  }\n  get forward() {\n    return this._forward;\n  }\n  async _refetchSender() {\n    await this._reloadMessage();\n  }\n  /**\n   * Re-fetches this message to reload the sender and chat entities,\n   * along with their input versions.\n   * @private\n   */\n  async _reloadMessage() {\n    if (!this._client) return;\n    let msg = undefined;\n    try {\n      const chat = this.isChannel ? await this.getInputChat() : undefined;\n      let temp = await this._client.getMessages(chat, {\n        ids: this.id\n      });\n      if (temp) {\n        msg = temp[0];\n      }\n    } catch (e) {\n      this._client._log.error(\"Got error while trying to finish init message with id \" + this.id);\n      if (this._client._errorHandler) {\n        await this._client._errorHandler(e);\n      }\n      if (this._client._log.canSend(Logger_1.LogLevel.ERROR)) {\n        console.error(e);\n      }\n    }\n    if (msg == undefined) return;\n    this._sender = msg._sender;\n    this._inputSender = msg._inputSender;\n    this._chat = msg._chat;\n    this._inputChat = msg._inputChat;\n    this._viaBot = msg._viaBot;\n    this._viaInputBot = msg._viaInputBot;\n    this._forward = msg._forward;\n    this._actionEntities = msg._actionEntities;\n  }\n  /**\n   * Returns a list of lists of `MessageButton <MessageButton>`, if any.\n   * Otherwise, it returns `undefined`.\n   */\n  get buttons() {\n    if (!this._buttons && this.replyMarkup) {\n      if (!this.inputChat) {\n        return;\n      }\n      try {\n        const bot = this._neededMarkupBot();\n        this._setButtons(this.inputChat, bot);\n      } catch (e) {\n        return;\n      }\n    }\n    return this._buttons;\n  }\n  /**\n   * Returns `buttons` when that property fails (this is rarely needed).\n   */\n  async getButtons() {\n    if (!this.buttons && this.replyMarkup) {\n      const chat = await this.getInputChat();\n      if (!chat) return;\n      let bot;\n      try {\n        bot = this._neededMarkupBot();\n      } catch (e) {\n        await this._reloadMessage();\n        bot = this._neededMarkupBot();\n      }\n      this._setButtons(chat, bot);\n    }\n    return this._buttons;\n  }\n  get buttonCount() {\n    if (!this._buttonsCount) {\n      if (this.replyMarkup instanceof api_1.Api.ReplyInlineMarkup || this.replyMarkup instanceof api_1.Api.ReplyKeyboardMarkup) {\n        this._buttonsCount = this.replyMarkup.rows.map(r => r.buttons.length).reduce(function (a, b) {\n          return a + b;\n        }, 0);\n      } else {\n        this._buttonsCount = 0;\n      }\n    }\n    return this._buttonsCount;\n  }\n  get file() {\n    if (!this._file) {\n      const media = this.photo || this.document;\n      if (media) {\n        this._file = new file_1.File(media);\n      }\n    }\n    return this._file;\n  }\n  get photo() {\n    if (this.media instanceof api_1.Api.MessageMediaPhoto) {\n      if (this.media.photo instanceof api_1.Api.Photo) return this.media.photo;\n    } else if (this.action instanceof api_1.Api.MessageActionChatEditPhoto) {\n      return this.action.photo;\n    } else {\n      return this.webPreview && this.webPreview.photo instanceof api_1.Api.Photo ? this.webPreview.photo : undefined;\n    }\n    return undefined;\n  }\n  get document() {\n    if (this.media instanceof api_1.Api.MessageMediaDocument) {\n      if (this.media.document instanceof api_1.Api.Document) return this.media.document;\n    } else {\n      const web = this.webPreview;\n      return web && web.document instanceof api_1.Api.Document ? web.document : undefined;\n    }\n    return undefined;\n  }\n  get webPreview() {\n    if (this.media instanceof api_1.Api.MessageMediaWebPage) {\n      if (this.media.webpage instanceof api_1.Api.WebPage) return this.media.webpage;\n    }\n  }\n  get audio() {\n    return this._documentByAttribute(api_1.Api.DocumentAttributeAudio, attr => !attr.voice);\n  }\n  get voice() {\n    return this._documentByAttribute(api_1.Api.DocumentAttributeAudio, attr => !!attr.voice);\n  }\n  get video() {\n    return this._documentByAttribute(api_1.Api.DocumentAttributeVideo);\n  }\n  get videoNote() {\n    return this._documentByAttribute(api_1.Api.DocumentAttributeVideo, attr => !!attr.roundMessage);\n  }\n  get gif() {\n    return this._documentByAttribute(api_1.Api.DocumentAttributeAnimated);\n  }\n  get sticker() {\n    return this._documentByAttribute(api_1.Api.DocumentAttributeSticker);\n  }\n  get contact() {\n    if (this.media instanceof api_1.Api.MessageMediaContact) {\n      return this.media;\n    }\n  }\n  get game() {\n    if (this.media instanceof api_1.Api.MessageMediaGame) {\n      return this.media.game;\n    }\n  }\n  get geo() {\n    if (this.media instanceof api_1.Api.MessageMediaGeo || this.media instanceof api_1.Api.MessageMediaGeoLive || this.media instanceof api_1.Api.MessageMediaVenue) {\n      return this.media.geo;\n    }\n  }\n  get invoice() {\n    if (this.media instanceof api_1.Api.MessageMediaInvoice) {\n      return this.media;\n    }\n  }\n  get poll() {\n    if (this.media instanceof api_1.Api.MessageMediaPoll) {\n      return this.media;\n    }\n  }\n  get venue() {\n    if (this.media instanceof api_1.Api.MessageMediaVenue) {\n      return this.media;\n    }\n  }\n  get dice() {\n    if (this.media instanceof api_1.Api.MessageMediaDice) {\n      return this.media;\n    }\n  }\n  get actionEntities() {\n    return this._actionEntities;\n  }\n  get viaBot() {\n    return this._viaBot;\n  }\n  get viaInputBot() {\n    return this._viaInputBot;\n  }\n  get replyToMsgId() {\n    var _a;\n    return (_a = this.replyTo) === null || _a === void 0 ? void 0 : _a.replyToMsgId;\n  }\n  get toId() {\n    if (this._client && !this.out && this.isPrivate) {\n      return new api_1.Api.PeerUser({\n        userId: (0, users_1._selfId)(this._client)\n      });\n    }\n    return this.peerId;\n  }\n  getEntitiesText(cls) {\n    let ent = this.entities;\n    if (!ent || ent.length == 0) return;\n    if (cls) {\n      ent = ent.filter(v => v instanceof cls);\n    }\n    const texts = utils.getInnerText(this.message || \"\", ent);\n    const zip = rows => rows[0].map((_, c) => rows.map(row => row[c]));\n    return zip([ent, texts]);\n  }\n  async getReplyMessage() {\n    if (!this._replyMessage && this._client) {\n      if (!this.replyTo) return undefined;\n      // Bots cannot access other bots' messages by their ID.\n      // However they can access them through replies...\n      this._replyMessage = (await this._client.getMessages(this.isChannel ? await this.getInputChat() : undefined, {\n        ids: new api_1.Api.InputMessageReplyTo({\n          id: this.id\n        })\n      }))[0];\n      if (!this._replyMessage) {\n        // ...unless the current message got deleted.\n        //\n        // If that's the case, give it a second chance accessing\n        // directly by its ID.\n        this._replyMessage = (await this._client.getMessages(this.isChannel ? this._inputChat : undefined, {\n          ids: this.replyToMsgId\n        }))[0];\n      }\n    }\n    return this._replyMessage;\n  }\n  async respond(params) {\n    if (this._client) {\n      return this._client.sendMessage(await this.getInputChat(), params);\n    }\n  }\n  async reply(params) {\n    if (this._client) {\n      params.replyTo = this.id;\n      return this._client.sendMessage(await this.getInputChat(), params);\n    }\n  }\n  async forwardTo(entity) {\n    if (this._client) {\n      entity = await this._client.getInputEntity(entity);\n      const params = {\n        messages: [this.id],\n        fromPeer: await this.getInputChat()\n      };\n      return this._client.forwardMessages(entity, params);\n    }\n  }\n  async edit(params) {\n    const param = params;\n    if (this.fwdFrom || !this._client) return undefined;\n    if (param.linkPreview == undefined) {\n      param.linkPreview = !!this.webPreview;\n    }\n    if (param.buttons == undefined) {\n      param.buttons = this.replyMarkup;\n    }\n    param.message = this.id;\n    return this._client.editMessage(await this.getInputChat(), param);\n  }\n  async delete({\n    revoke\n  } = {\n    revoke: false\n  }) {\n    if (this._client) {\n      return this._client.deleteMessages(await this.getInputChat(), [this.id], {\n        revoke\n      });\n    }\n  }\n  async pin(params) {\n    if (this._client) {\n      const entity = await this.getInputChat();\n      if (entity === undefined) {\n        throw Error(\"Failed to pin message due to cannot get input chat.\");\n      }\n      return this._client.pinMessage(entity, this.id, params);\n    }\n  }\n  async unpin(params) {\n    if (this._client) {\n      const entity = await this.getInputChat();\n      if (entity === undefined) {\n        throw Error(\"Failed to unpin message due to cannot get input chat.\");\n      }\n      return this._client.unpinMessage(entity, this.id, params);\n    }\n  }\n  async downloadMedia(params) {\n    // small hack for patched method\n    if (this._client) return this._client.downloadMedia(this, params || {});\n  }\n  async markAsRead() {\n    if (this._client) {\n      const entity = await this.getInputChat();\n      if (entity === undefined) {\n        throw Error(`Failed to mark message id ${this.id} as read due to cannot get input chat.`);\n      }\n      return this._client.markAsRead(entity, this.id);\n    }\n  }\n  async click({\n    i,\n    j,\n    text,\n    filter,\n    data,\n    sharePhone,\n    shareGeo,\n    password\n  }) {\n    if (!this.client) {\n      return;\n    }\n    if (data) {\n      const chat = await this.getInputChat();\n      if (!chat) {\n        return;\n      }\n      const button = new api_1.Api.KeyboardButtonCallback({\n        text: \"\",\n        data: data\n      });\n      return await new messageButton_1.MessageButton(this.client, button, chat, undefined, this.id).click({\n        sharePhone: sharePhone,\n        shareGeo: shareGeo,\n        password: password\n      });\n    }\n    if (this.poll) {\n      function findPoll(answers) {\n        if (i != undefined) {\n          if (Array.isArray(i)) {\n            const corrects = [];\n            for (let x = 0; x < i.length; x++) {\n              corrects.push(answers[x].option);\n            }\n            return corrects;\n          }\n          return [answers[i].option];\n        }\n        if (text != undefined) {\n          if (typeof text == \"function\") {\n            for (const answer of answers) {\n              if (text(answer.text)) {\n                return [answer.option];\n              }\n            }\n          } else {\n            for (const answer of answers) {\n              if (answer.text.text == text) {\n                return [answer.option];\n              }\n            }\n          }\n          return;\n        }\n        if (filter != undefined) {\n          for (const answer of answers) {\n            if (filter(answer)) {\n              return [answer.option];\n            }\n          }\n          return;\n        }\n      }\n      const options = findPoll(this.poll.poll.answers) || [];\n      return await this.client.invoke(new api_1.Api.messages.SendVote({\n        peer: this.inputChat,\n        msgId: this.id,\n        options: options\n      }));\n    }\n    if (!(await this.getButtons())) {\n      return; // Accessing the property sets this._buttons[_flat]\n    }\n    function findButton(self) {\n      if (!self._buttonsFlat || !self._buttons) {\n        return;\n      }\n      if (Array.isArray(i)) {\n        i = i[0];\n      }\n      if (text != undefined) {\n        if (typeof text == \"function\") {\n          for (const button of self._buttonsFlat) {\n            if (text(button.text)) {\n              return button;\n            }\n          }\n        } else {\n          for (const button of self._buttonsFlat) {\n            if (button.text == text) {\n              return button;\n            }\n          }\n        }\n        return;\n      }\n      if (filter != undefined) {\n        for (const button of self._buttonsFlat) {\n          if (filter(button)) {\n            return button;\n          }\n        }\n        return;\n      }\n      if (i == undefined) {\n        i = 0;\n      }\n      if (j == undefined) {\n        return self._buttonsFlat[i];\n      } else {\n        return self._buttons[i][j];\n      }\n    }\n    const button = findButton(this);\n    if (button) {\n      return await button.click({\n        sharePhone: sharePhone,\n        shareGeo: shareGeo,\n        password: password\n      });\n    }\n  }\n  /**\n   * Helper methods to set the buttons given the input sender and chat.\n   */\n  _setButtons(chat, bot) {\n    if (this.client && (this.replyMarkup instanceof api_1.Api.ReplyInlineMarkup || this.replyMarkup instanceof api_1.Api.ReplyKeyboardMarkup)) {\n      this._buttons = [];\n      this._buttonsFlat = [];\n      for (const row of this.replyMarkup.rows) {\n        const tmp = [];\n        for (const button of row.buttons) {\n          const btn = new messageButton_1.MessageButton(this.client, button, chat, bot, this.id);\n          tmp.push(btn);\n          this._buttonsFlat.push(btn);\n        }\n        this._buttons.push(tmp);\n      }\n    }\n  }\n  /**\n   *Returns the input peer of the bot that's needed for the reply markup.\n    This is necessary for `KeyboardButtonSwitchInline` since we need\n   to know what bot we want to start. Raises ``Error`` if the bot\n   cannot be found but is needed. Returns `None` if it's not needed.\n   */\n  _neededMarkupBot() {\n    if (!this.client || this.replyMarkup == undefined) {\n      return;\n    }\n    if (!(this.replyMarkup instanceof api_1.Api.ReplyInlineMarkup || this.replyMarkup instanceof api_1.Api.ReplyKeyboardMarkup)) {\n      return;\n    }\n    for (const row of this.replyMarkup.rows) {\n      for (const button of row.buttons) {\n        if (button instanceof api_1.Api.KeyboardButtonSwitchInline) {\n          if (button.samePeer || !this.viaBotId) {\n            const bot = this._inputSender;\n            if (!bot) throw new Error(\"No input sender\");\n            return bot;\n          } else {\n            const ent = this.client._entityCache.get(this.viaBotId);\n            if (!ent) throw new Error(\"No input sender\");\n            return ent;\n          }\n        }\n      }\n    }\n  }\n  // TODO fix this\n  _documentByAttribute(kind, condition) {\n    const doc = this.document;\n    if (doc) {\n      for (const attr of doc.attributes) {\n        if (attr instanceof kind) {\n          if (condition == undefined || typeof condition == \"function\" && condition(attr)) {\n            return doc;\n          }\n          return undefined;\n        }\n      }\n    }\n  }\n}\nexports.CustomMessage = CustomMessage;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}