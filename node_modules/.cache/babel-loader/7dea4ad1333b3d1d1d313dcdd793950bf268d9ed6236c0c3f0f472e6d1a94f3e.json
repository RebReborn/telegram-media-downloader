{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._DialogsIter = void 0;\nexports.iterDialogs = iterDialogs;\nexports.getDialogs = getDialogs;\nconst tl_1 = require(\"../tl\");\nconst requestIter_1 = require(\"../requestIter\");\nconst index_1 = require(\"../index\");\nconst dialog_1 = require(\"../tl/custom/dialog\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst Logger_1 = require(\"../extensions/Logger\");\nconst _MAX_CHUNK_SIZE = 100;\n/**\n Get the key to get messages from a dialog.\n\n We cannot just use the message ID because channels share message IDs,\n and the peer ID is required to distinguish between them. But it is not\n necessary in small group chats and private chats.\n * @param {Api.TypePeer} [peer] the dialog peer\n * @param {number} [messageId] the message id\n * @return {[number,number]} the channel id and message id\n */\nfunction _dialogMessageKey(peer, messageId) {\n  // can't use arrays as keys for map :( need to convert to string.\n  return \"\" + [peer instanceof tl_1.Api.PeerChannel ? peer.channelId : undefined, messageId];\n}\nclass _DialogsIter extends requestIter_1.RequestIter {\n  async _init(_ref) {\n    let {\n      offsetDate,\n      offsetId,\n      offsetPeer,\n      ignorePinned,\n      ignoreMigrated,\n      folder\n    } = _ref;\n    this.request = new tl_1.Api.messages.GetDialogs({\n      offsetDate,\n      offsetId,\n      offsetPeer,\n      limit: 1,\n      hash: big_integer_1.default.zero,\n      excludePinned: ignorePinned,\n      folderId: folder\n    });\n    if (this.limit <= 0) {\n      // Special case, get a single dialog and determine count\n      const dialogs = await this.client.invoke(this.request);\n      if (\"count\" in dialogs) {\n        this.total = dialogs.count;\n      } else {\n        this.total = dialogs.dialogs.length;\n      }\n      return true;\n    }\n    this.seen = new Set();\n    this.offsetDate = offsetDate;\n    this.ignoreMigrated = ignoreMigrated;\n  }\n  [Symbol.asyncIterator]() {\n    return super[Symbol.asyncIterator]();\n  }\n  async _loadNextChunk() {\n    var _a;\n    if (!this.request || !this.seen || !this.buffer) {\n      return;\n    }\n    this.request.limit = Math.min(this.left, _MAX_CHUNK_SIZE);\n    const r = await this.client.invoke(this.request);\n    if (r instanceof tl_1.Api.messages.DialogsNotModified) {\n      return;\n    }\n    if (\"count\" in r) {\n      this.total = r.count;\n    } else {\n      this.total = r.dialogs.length;\n    }\n    const entities = new Map();\n    const messages = new Map();\n    for (const entity of [...r.users, ...r.chats]) {\n      if (entity instanceof tl_1.Api.UserEmpty || entity instanceof tl_1.Api.ChatEmpty) {\n        continue;\n      }\n      entities.set(index_1.utils.getPeerId(entity), entity);\n    }\n    for (const m of r.messages) {\n      let message = m;\n      try {\n        if (message && \"_finishInit\" in message) {\n          // todo make sure this never fails\n          message._finishInit(this.client, entities, undefined);\n        }\n      } catch (e) {\n        console.log(\"msg\", message);\n        this.client._log.error(\"Got error while trying to finish init message with id \" + m.id);\n        if (this.client._log.canSend(Logger_1.LogLevel.ERROR)) {\n          console.error(e);\n        }\n        if (this.client._errorHandler) {\n          await this.client._errorHandler(e);\n        }\n      }\n      messages.set(_dialogMessageKey(message.peerId, message.id), message);\n    }\n    for (const d of r.dialogs) {\n      if (d instanceof tl_1.Api.DialogFolder) {\n        continue;\n      }\n      const message = messages.get(_dialogMessageKey(d.peer, d.topMessage));\n      if (this.offsetDate != undefined) {\n        const date = message === null || message === void 0 ? void 0 : message.date;\n        if (date == undefined || date > this.offsetDate) {\n          continue;\n        }\n      }\n      const peerId = index_1.utils.getPeerId(d.peer);\n      if (!this.seen.has(peerId)) {\n        this.seen.add(peerId);\n        if (!entities.has(peerId)) {\n          /*\n           > In which case can a UserEmpty appear in the list of banned members?\n           > In a very rare cases. This is possible but isn't an expected behavior.\n           Real world example: https://t.me/TelethonChat/271471\n           */\n          continue;\n        }\n        const cd = new dialog_1.Dialog(this.client, d, entities, message);\n        if (!this.ignoreMigrated || cd.entity != undefined && \"migratedTo\" in cd.entity) {\n          this.buffer.push(cd);\n        }\n      }\n    }\n    if (r.dialogs.length < this.request.limit || !(r instanceof tl_1.Api.messages.DialogsSlice)) {\n      return true;\n    }\n    let lastMessage;\n    for (let dialog of r.dialogs.reverse()) {\n      lastMessage = messages.get(_dialogMessageKey(dialog.peer, dialog.topMessage));\n      if (lastMessage) {\n        break;\n      }\n    }\n    this.request.excludePinned = true;\n    this.request.offsetId = lastMessage ? lastMessage.id : 0;\n    this.request.offsetDate = lastMessage ? lastMessage.date : 0;\n    this.request.offsetPeer = (_a = this.buffer[this.buffer.length - 1]) === null || _a === void 0 ? void 0 : _a.inputEntity;\n  }\n}\nexports._DialogsIter = _DialogsIter;\n/** @hidden */\nfunction iterDialogs(client, _ref2) {\n  let {\n    limit = undefined,\n    offsetDate = undefined,\n    offsetId = 0,\n    offsetPeer = new tl_1.Api.InputPeerEmpty(),\n    ignorePinned = false,\n    ignoreMigrated = false,\n    folder = undefined,\n    archived = undefined\n  } = _ref2;\n  if (archived != undefined) {\n    folder = archived ? 1 : 0;\n  }\n  return new _DialogsIter(client, limit, {}, {\n    offsetDate,\n    offsetId,\n    offsetPeer,\n    ignorePinned,\n    ignoreMigrated,\n    folder\n  });\n}\n/** @hidden */\nasync function getDialogs(client, params) {\n  return await client.iterDialogs(params).collect();\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}